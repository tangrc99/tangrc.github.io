<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tangrc99.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="技术爱好者">
<meta property="og:type" content="website">
<meta property="og:title" content="Sepk">
<meta property="og:url" content="https://tangrc99.com/page/2/index.html">
<meta property="og:site_name" content="Sepk">
<meta property="og:description" content="技术爱好者">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="tangrc99">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tangrc99.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Sepk</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sepk</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tangrc99.com/2023/03/01/%E4%BB%8Eunsafe.Pointer%E5%87%BA%E5%8F%91%EF%BC%8C%E6%B5%85%E6%9E%90Go%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="tangrc99">
      <meta itemprop="description" content="技术爱好者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sepk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/01/%E4%BB%8Eunsafe.Pointer%E5%87%BA%E5%8F%91%EF%BC%8C%E6%B5%85%E6%9E%90Go%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">从unsafe.Pointer出发，浅析Go反射原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-01 01:09:33 / 修改时间：15:25:37" itemprop="dateCreated datePublished" datetime="2023-03-01T01:09:33+08:00">2023-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>反射是 Go 语言中较为难以理解的一个特性，网上讲解反射的文章有很多，但是要么讲解细致但是篇幅过长，要么讲解稍微模糊。但其实如果掌握了反射所使用到了一些技术，反射本身是很好理解的，其原理就是一个向上和向下转换的过程。本文会从反射所基于的语言特性出发，简要地分析反射这一特性是如何实现的。</p>
<h2 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h2><p>在讨论<code>unsafe.Pointer</code>之前，我们先来讨论一下 C 语言中的原始指针类型以及指针之间的相互转换。在 C 语言中，所有指针都是可以相互转换的，而对指针取值其实就相当于取当前指针所声明类型长度的一段内存。我们可以利用 C 语言指针的这种特性在不同长度的结构体实现变换，最为经典的例子是 linux 链表。Go 中同样也有指针，但由于 Go 是一种 GC 语言，如果保留 C 指针的这样灵活性，将会对 GC 扫描带来很大的挑战，如果一个指针向上转换了，那么很有可能会造成内存泄露的问题。</p>
<p>为了实现 C 语言中这种灵活转换的特性，Go 中引入了<code>unsafe.Pointer</code>这一类型。<code>unsafe.Pointer</code>是 go 中用于实现类型转换的一种中间类，我们可以将一个长度为 n 的<code>unsafe.Pointer</code>视作是一个长度为 n 的数组（即内存中的某一段数据），但是这一段数组中的数据对用户来说是不可见的。在某种意义上来说，<code>unsafe.Pointer</code>是用来告诉 GC 扫描器这段内存已经被分配，如果需要进行垃圾清理，必须释放这段内存，防止内存泄露。在 C++ 中，这一特性是通过将析构函数作为虚函数来实现的。</p>
<p>为了更直观地表示这一功能，以一个代码实例来演示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    header <span class="type">int</span></span><br><span class="line">    hidden unsafe.Pointer	<span class="comment">// 占位，该字段的所有信息对用户隐藏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    header  <span class="type">int</span></span><br><span class="line">    toHide <span class="type">int</span>	<span class="comment">// 将会被隐藏的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := B&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> a A</span><br><span class="line">    a = *(*A)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是可以编译通过并运行的，通过调试器来观察 a 中的值。</p>
<p><img src="/images/image-20230301110108021.png" alt="image-20230301110108021"></p>
<p>可以看到，b 中 header 字段的值被拷贝给了 a，而 hidden 字段则成为了一个 8 字节长度（int 长度）的<code>unsafe.Pointer</code>用于占位，当 a 声明周期结束时，将会释放 header + hidden 长度的内存。要实现这一功能，必须要保证两个结构体的几个起始字段类型和顺序是相同的，并且“基类”需要以<code>unsafe.Pointer</code>字段结尾。</p>
<p>在 go 语言中，为了实现反射大量使用了这一特性，如果对这一特性不了解，建议先学习一下 linux 中的链表实现，这将有助于理解 go 的反射原理。</p>
<h2 id="eface-和-iface"><a href="#eface-和-iface" class="headerlink" title="eface 和 iface"></a>eface 和 iface</h2><p><code>eface</code>和<code>iface</code>是 go 中非空接口与空接口的底层实现，其原始定义代码出现在 runtime2.go:202：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab	<span class="comment">// 存储接口与原始类的类型信息</span></span><br><span class="line">    data unsafe.Pointer <span class="comment">// 存储原始类的其他信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type	<span class="comment">// 存储原始类的类型信息</span></span><br><span class="line">    data  unsafe.Pointer	<span class="comment">// 存储原始类的其他信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将代码展开，来比较两个结构体之间的差异：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 原 tab 字段 start</span></span><br><span class="line">    inter *interfacetype	<span class="comment">// 存储接口类型信息</span></span><br><span class="line">    _type *_type	<span class="comment">// 存储原始类的类型信息</span></span><br><span class="line">    hash  <span class="type">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">    _     [<span class="number">4</span>]<span class="type">byte</span>	<span class="comment">// 占位，4 字节</span></span><br><span class="line">    fun   [<span class="number">1</span>]<span class="type">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter.</span></span><br><span class="line">    <span class="comment">// 原 tab 字段 end</span></span><br><span class="line"></span><br><span class="line">    data unsafe.Pointer <span class="comment">// 存储原始类的其他信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type	<span class="comment">// 存储原始类的类型信息</span></span><br><span class="line">    data  unsafe.Pointer	<span class="comment">// 存储原始类的其他信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这两个类型展开后的区别，<code>iface</code>在起始位置比<code>eface</code>多了一个 inter 字段，该字段用于存储接口信息，这是为了比较不同的非空接口是否相等；而<code>iface</code>和<code>eface</code>的最后一个字段都是<code>unsafe.Pointer</code>类型。暂时不考虑其中存储的数据类型，将<code>iface.hash</code>字段至<code>iface.data</code>字段也都视为字节（这些字段是为了实现与 XXtype 之间的相互转换），那么可以发现，<code>iface</code>实际上可以表示为如下的形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter *interfacetype	<span class="comment">// 存储接口类型信息</span></span><br><span class="line">    _type *_type	<span class="comment">// 存储原始类的类型信息</span></span><br><span class="line">    data  unsafe.Pointer	<span class="comment">// 存储原始类的其他信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，去掉<code>inter</code>字段后，<code>iface</code>就成为了<code>eface</code>，因此只需要在该字段上进行相关操作，就能够实现两者之间的相互转换。用一张图来表示两者之间的关系：</p>
<p><img src="/images/eface%20and%20iface.png" alt="eface and iface"></p>
<h2 id="XXtype-类型"><a href="#XXtype-类型" class="headerlink" title="XXtype 类型"></a>XXtype 类型</h2><p>在 runtime/type.go 文件中，有如下结构体的定义：<code>interfacetype</code>, <code>methodtype</code> , <code>maptype</code>, <code>arraytype</code>, <code>chantype</code>, <code>slicetype</code>, <code>functype</code>, <code>ptrtype</code>, <code>structtype</code>。这些结构体表示了在接口中，go 语言中各种类型的存储形式。值得注意的是，这些结构体全部以<code>_type</code>类型的字段作为起始，这一类型同样被接口用于记录类型。以 <code>structtype</code>为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> structtype <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Type 信息</span></span><br><span class="line">    typ     _type</span><br><span class="line">    <span class="comment">// Value 信息</span></span><br><span class="line">    pkgPath name	<span class="comment">// 4 字节</span></span><br><span class="line">    fields  []structfield	<span class="comment">// 24 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以同一字段作为起始位置，这种做法在 C 中比较常见，其实就是通过统一字段加类型转换的方式实现了零成本的多态，例如 linux 链表，Lua LValue 的实现，都是使用了这种思想。go 中的指针虽然带有类型检查，不能强制转换，但是同样可以使用<code>unsafe.Pointer</code>来实现类似的“向上转换”。事实上，如果将<code>structtype</code>中 Value 信息部分视作一个<code>unsafe.Pointer</code>，那么就可以将其视作是一个<code>eface</code>类型。在 go 中，空接口就是使用这种方式来存储类型信息的，因为空接口没有任何方法，只需要进行类型转换和比较，因此只需要保留 Type 信息字段即可。另外注意到在 typ 字段后的字节（不同 struct 中字段名不同）都是一个指针类型，长度是四个字节，这个长度与<code>iface</code>中的 hash 字段是相互对应的。</p>
<p><img src="/images/iface-xxtype.png" alt="iface-xxtype"></p>
<p>用一张图像来表示更为直观，<code>iface</code>结构体的第二和第三个字段与 XXtype 中的第一个和第二个字段是对齐的，两个结构体的长度也是相同的；这也意味着 XXtype 与<code>eface</code>结构体的第一个字段是对齐的，二者的结构体也是相同的。三者之间可以通过一定的方式相互转换，这是接口赋值与反射的基础原理。</p>
<h2 id="struct-与-interface-的转换"><a href="#struct-与-interface-的转换" class="headerlink" title="struct 与 interface 的转换"></a>struct 与 interface 的转换</h2><p>读到这里，应该可以隐约明白 Relect 是如何实现的了，但是其中还有比较关键的一步，那就是<code>structtype</code>类型究竟是如何生成并且被存储到一个空接口或非空接口中的。许多博客文章起始都没有提到这一点，或者是对这一点介绍地较为简略。</p>
<p>在零成本抽样的 C++ 中以虚函数表的形式来实现了多态，然而这一功能并非 Zero Cost；同样地，在 go 中一个 struct 被赋值给一个它所实现的 interface，这个过程并不是零成本的。go 编译器隐藏了一些必要的工作：在编译时，编译器会增加一些代码来完成这些额外的工作。</p>
<p>在如下的代码片段中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B 是一个接口</span></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"><span class="comment">// A 是一个结构体</span></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b B</span><br><span class="line">    a := A&#123;&#125;</span><br><span class="line">    <span class="comment">// 编译器会做许多额外工作</span></span><br><span class="line">    b = a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 struct A 被赋值给 interface B 时，经过 go 编译器编译后的代码，实际上会实现如下的逻辑：</p>
<ul>
<li>若生成一个非空接口，将接口所需的<code>interfacetype</code>类型信息拷贝到栈上；</li>
<li>在符号表中寻找 A 类型及其实现的方法，以及 A 实例 data，将这些拷贝到栈上；</li>
<li>调用<code>convT2E64(t *_type, elem unsafe.Pointer) (e eface)</code>生成空接口，或调用<code>convT2I(tab *itab, elem unsafe.Pointer) (i iface)</code>生成非空接口。</li>
</ul>
<p>这个过程实际上是在搜寻所需要的类型信息，并将类型信息与类型实例中各字段的值打包在一起，<strong>生成一个 XXtype 类型实例</strong>，最终使用“向上转换”生成接口实例。<strong>这个过程中发生了值的拷贝</strong>，因为利用<code>unsafe.Pointer</code>实现“向上转换”的前提是数据是连续的。无法确定 A 实例中值在内存中的地址前有足够的空间来分配生成接口所需的字段，因为需要将 A 实例的值拷贝到内存中的其他区域。可以看到，struct 到 interface 的转换其实是一个代价较大的操作。</p>
<h2 id="Reflect-的实现"><a href="#Reflect-的实现" class="headerlink" title="Reflect 的实现"></a>Reflect 的实现</h2><p>既然已经知道，struct 赋值给 interface 之后会发生什么，那么理解 Reflect 的实现就是一个非常简单的事情。Reflect 主要实现了取值和取类型这两类的操作。</p>
<h3 id="取类型"><a href="#取类型" class="headerlink" title="取类型"></a>取类型</h3><p>首先分析一下取类型的源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i any)</span></span> Type &#123;</span><br><span class="line">    <span class="comment">// 这一步是为了取空接口中完整的数据类型</span></span><br><span class="line">    eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))	<span class="comment">// emptyInterface 与 eface 是 alias 的关系</span></span><br><span class="line">    <span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型转换与封装</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toType</span><span class="params">(t *rtype)</span></span> Type &#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段源码虽然很短，但是理解起来还是稍微困难的。感觉这里理解困难的点主要在于 go 是自举，这里用了一些 go 语言编译中的一些特性，如果用 C 的眼光去看这段代码，其实会更好理解。这段代码其实主要做了以下工作：</p>
<ul>
<li>在传参阶段，将 struct 转换为 any 类型，这一步发生了上一节中所讲内容；</li>
<li>对 any 类型 i 进行原地转换，这一步是为了取接口中存储的原始值；</li>
<li>将原始值中的 type 字段传递给一个接口 Type，实现封装。</li>
</ul>
<p>可以注意到，这个过程中发生了<strong>两次接口的赋值</strong>，由于接口赋值需要拷贝数据，因此在反射中只取类型也是一个代价高昂的操作。最好不要重复获取一个对象的 Type。</p>
<h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><p>对一个对象进行反射取值操作，最终会得到一个<code>Value</code>结构体，结构体的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ *rtype	</span><br><span class="line">    ptr unsafe.Pointer	<span class="comment">// data</span></span><br><span class="line">    flag	<span class="comment">// 操作标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>Value</code>其实就是一个<code>eface</code>加上一个<code>flag</code>标识位，该标识位用于表示可以被采取什么样的操作。事实上，它就是由<code>eface</code>拼接得到的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i any)</span></span> Value &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止 GC，这里不需要关心</span></span><br><span class="line">    escapes(i)</span><br><span class="line">    <span class="comment">// 关键过程发生在这里</span></span><br><span class="line">    <span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i any)</span></span> Value &#123;</span><br><span class="line">    <span class="comment">// 取得空接口中的原始数据</span></span><br><span class="line">    e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> don&#x27;t read e.word until we know whether it is really a pointer or not.</span></span><br><span class="line">    t := e.typ</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成标志位</span></span><br><span class="line">    f := flag(t.Kind())</span><br><span class="line">    <span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">      f |= flagIndir</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将类型，数据，标志位进行拼接</span></span><br><span class="line">    <span class="keyword">return</span> Value&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个过程中仍然是发生了两次拷贝，一次是 struct 传入 any 接口，一次是创建 Value 结构体。注意到，Value 这里使用的是复制后的数据，因此如果想使用反射来修改原数据，一定要传入指针。</p>
<h3 id="取字段"><a href="#取字段" class="headerlink" title="取字段"></a>取字段</h3><p>反射中的取字段是将<code>Value</code>类型向下转换来实现的。在<code>Value.ptr</code>字段中存储了 XXtype 除类型头外的所有信息，在获取 Value 的基础上再使用“向下转换”可以获取类型具体，我们以获取 struct 中字段个数的方法为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> NumField() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 flag 字段检验类型</span></span><br><span class="line">    v.mustBe(Struct)</span><br><span class="line">    <span class="comment">// Value 向下转换，得到 structType</span></span><br><span class="line">    tt := (*structType)(unsafe.Pointer(v.typ))</span><br><span class="line">    <span class="comment">// 返回 structType 中的信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(tt.fields)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中比较关键的过程就是使用<code>unsafe.Pointer</code>来向下转换，这里向下转换能够成为是因为<code>Value</code>，<code>eface</code>，<code>XXtype</code>的同源性，这三者本身就是相同的。</p>
<p>在反射中需要如果使用字段的名称来获取字段，需要经过如下代码，该代码最终是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> FieldByName(name <span class="type">string</span>) Value &#123;</span><br><span class="line">    v.mustBe(Struct)</span><br><span class="line">    <span class="keyword">if</span> f, ok := v.typ.FieldByName(name); ok &#123;</span><br><span class="line">      <span class="keyword">return</span> v.FieldByIndex(f.Index)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该函数是调用链的最后一环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *structType)</span></span> FieldByName(name <span class="type">string</span>) (f StructField, present <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// Quick check for top-level name, or struct without embedded fields.</span></span><br><span class="line">    hasEmbeds := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      <span class="comment">// 核心：遍历并且比较各个字段的名称</span></span><br><span class="line">      <span class="keyword">for</span> i := <span class="keyword">range</span> t.fields &#123;</span><br><span class="line">        tf := &amp;t.fields[i]</span><br><span class="line">        <span class="keyword">if</span> tf.name.name() == name &#123;</span><br><span class="line">          <span class="keyword">return</span> t.Field(i), <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> tf.embedded() &#123;</span><br><span class="line">          hasEmbeds = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !hasEmbeds &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.FieldByNameFunc(<span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> s == name &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>FieldByName</code>函数其实是使用遍历加比较字符串的方式来确认字段是否匹配的，当结构体的字段数量较大，并且字段名较长时，性能就会比较差。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Reflect 的实现其实并不是很难，阻碍理解的地方主要在于 struct 与 interface 的转换、unsafe.Pointer 的使用这两点。由于 interface 和 Reflect 中需要全量拷贝值，因此使用引用类型是一个非常明智的抉择。但与之相对的，大量使用引用类型会导致 GC 问题。可以考虑将类型取指针后再赋值给接口。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tangrc99.com/2023/02/25/Ristretto-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="tangrc99">
      <meta itemprop="description" content="技术爱好者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sepk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/25/Ristretto-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Ristretto 源码阅读笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-25 22:02:44" itemprop="dateCreated datePublished" datetime="2023-02-25T22:02:44+08:00">2023-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-26 14:22:10" itemprop="dateModified" datetime="2023-02-26T14:22:10+08:00">2023-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Ristretto 是一个基于 Go 语言的、可并发访问的、可设置内存存储上限的高性能进程内缓存库。Ristretto 的含义为“超浓缩咖啡”，该命名是因为该项目的目标是与知名 JAVA 缓存库 Caffeine 竞争。</p>
<p>相比其他 Go 语言的进程内缓存项目，Ristretto 的设计与实现上具有以下几个显著特点：</p>
<ul>
<li>基于<strong>近似</strong> LFU 算法实现缓存逐出；</li>
<li>支持多种 key 与 value 类型，能够在进程内缓存较为复杂的结构体；</li>
<li><strong>写入门限</strong>（DoorKeeper）设计，过滤写入键值对，提高缓存命中率；</li>
<li>Key Cost 设计，能够更好地描述一个键值对对缓存的负载量；</li>
<li>利用<code>sync.Pool</code>实现类似 thread_local 缓存，减少并发竞争。</li>
</ul>
<h2 id="Ristretto-软件框架"><a href="#Ristretto-软件框架" class="headerlink" title="Ristretto 软件框架"></a>Ristretto 软件框架</h2><p>Ristretto 的实现并不复杂，从功能上可以将 Ristretto 划分为几个模块：存储模块、操作缓冲模块、缓存控制模块、缓存计数模块，几个模块分别由不同的数据结构来负责。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 存储模块</span></span><br><span class="line">    store store</span><br><span class="line">    <span class="comment">// 缓存控制模块</span></span><br><span class="line">    policy policy</span><br><span class="line">    <span class="comment">// 读写操作缓冲</span></span><br><span class="line">    getBuf *ringBuffer</span><br><span class="line">    setBuf <span class="keyword">chan</span> *Item</span><br><span class="line">    <span class="comment">// 缓存计数</span></span><br><span class="line">    Metrics *Metrics</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作缓冲模块可以分为读操作缓冲与写操作缓冲，两者会采取不同的策略来减少对缓存控制模块的访问。缓存控制模块具有 tinyLFU 和 sampledLFU，分别负责缓存的准入和逐出。缓存计数模块则是用于读取 Ristretto 的缓存命中率等日志信息。</p>
<h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>存储模块使用了 Go 语言中非常经典的分片哈希表设计，目前的实践已经证明这是在 Go 中综合并发性能最好的并发哈希表设计，其他的一些同类型项目也都采用了类似的设计。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存 metadata</span></span><br><span class="line"><span class="keyword">type</span> storeItem <span class="keyword">struct</span> &#123;</span><br><span class="line">    key        <span class="type">uint64</span>	<span class="comment">// 键</span></span><br><span class="line">    conflict   <span class="type">uint64</span>	<span class="comment">// 用于解决哈希冲突</span></span><br><span class="line">    value      <span class="keyword">interface</span>&#123;&#125;	<span class="comment">// 值</span></span><br><span class="line">    expiration time.Time	<span class="comment">// 过期时间，0 代表无</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓存大表</span></span><br><span class="line"><span class="keyword">type</span> shardedMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    shards    []*lockedMap	<span class="comment">// 分片表</span></span><br><span class="line">    expiryMap *expirationMap	<span class="comment">// 过期时间表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓存分片表</span></span><br><span class="line"><span class="keyword">type</span> lockedMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    data <span class="keyword">map</span>[<span class="type">uint64</span>]storeItem</span><br><span class="line">    em   *expirationMap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Ristretto 中，哈希表的分片和存储都使用了同一个哈希值，为了解决哈希冲突的问题，每一个键值对都带有使用另一个哈希算法计算出的 conflict 值，避免冲突的策略是不允许覆盖。当键值对时为数字类型时，哈希值会使用转化后的 uint64 类型；当键值对为<code>string</code>或<code>[]byte</code>类型时会使用 Go runtime 中的<code>runtime.memhash</code>函数来计算哈希值。由于使用了汇编代码来实现哈希值计算，该哈希算法相比其他常见类型的哈希算法计算速度更快。</p>
<h2 id="getBuf"><a href="#getBuf" class="headerlink" title="getBuf"></a>getBuf</h2><p><code>getBuf</code>用于控制“用户读取缓存”这一行为传递到 tinyLFU 的速度和方式，具象化来说就是记录下每一次读取操作需要访问的键值对，在 Ristretto 中的实现中使用了键的哈希值。相比于 LRU 和近似 LRU 算法，实现一个 LFU 或近似 LFU 算法需要记录更多的数据。而进程内缓存这一应用场景，通常都要求较高的并发读写性能，会有较多的线程访问。一个进程内共享的缓存意味着记录 LFU 相关信息的数据结构同样会被高并发地访问，因此有必要降低 LFU 数据结构的竞争来提高缓存的整体性能。</p>
<p>降低并发度，常用的方法就是队列和分片这两种模式，Ristretto 中选择的是队列方式。其核心思想是将 stream 转化为 batch stream，具体做法是在每一个协程栈上使用一个thread local 数据结构来缓存该协程读取的键值对，当协程本地的数据聚合到一定规模时再批量写入缓存控制模块中。由于 Go 中并不存在<code>thread_local</code>关键字，Ristretto 利用了<code>sync.Pool</code>的特性来实现了一个近似的 thread local。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ringBuffer)</span></span> Push(item <span class="type">uint64</span>) &#123;</span><br><span class="line">    <span class="comment">// 从 Pool 中取出一个对象，将数据放入后归还</span></span><br><span class="line">    stripe := b.pool.Get().(*ringStripe)</span><br><span class="line">    stripe.Push(item)</span><br><span class="line">    <span class="comment">// 对象归还时，内部信息并不会清楚</span></span><br><span class="line">    b.pool.Put(stripe)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ringStripe)</span></span> Push(item <span class="type">uint64</span>) &#123;</span><br><span class="line">    <span class="comment">// 将读取的键值对放入切片中</span></span><br><span class="line">    s.data = <span class="built_in">append</span>(s.data, item)</span><br><span class="line">    <span class="comment">// 切片满了之后，通过 channel 无阻塞地发送</span></span><br><span class="line">    <span class="comment">// 若 channel 已满，丢弃消息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s.data) &gt;= s.capa &#123;</span><br><span class="line">        <span class="keyword">if</span> s.cons.Push(s.data) &#123;</span><br><span class="line">            s.data = <span class="built_in">make</span>([]<span class="type">uint64</span>, <span class="number">0</span>, s.capa)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.data = s.data[:<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个协程需要读取键值对时，会首先从<code>sync.Pool</code>中取出一个<code>ringStripe</code>对象，这里获取对象会优先考虑从 P 的本地栈来获取。<code>ringStripe</code>对象内具有一个切片，用来暂时存储该键值对，只有当切片存满之后，才会非阻塞地通过 channel 发送给缓存控制模块。在官方博客中提到，该 channel 的长度设置得比较小，并且当 channel 满时会选择丢弃<code>ringStripe</code>中的数据（使用 select实现）。由于缓存控制模块中收到的是 batch stream，因此在获取锁的过程中能够连续处理更多信息，降低了需要获取锁的次数，因此能够大大降低此处的并发冲突。另一点则是利用了<code>sync.Pool</code>的 thread local 特性，避免在聚合的过程中需要访问一个进程内全局可见的数据结构，这也是常用的优化手段。最后，经过聚合后的读取信息将会被<code>defaultPolicy</code>接收，用于调控缓存的准入门限。</p>
<p>当<code>sync.Pool</code>发生 GC、channel 满时，都会导致读取缓存的信息丢失，但是这对 LFU 算法的影响是比较小的。因为在理想情况下，用户在某一时刻对缓存的读取是均匀的，丢弃少部分读取信息相当于是一个抽样。这种处理有助于限制分析用户读取信息时的 CPU 利用率，虽然牺牲了一部分 LFU 的准确性，但是能使得软件整体性能提升。</p>
<p>这里的设计综合了 thread local 降低并发以及批处理降低并发的思想，之所以能够采取这种设计是因为缓存控制模块是允许有延迟的，只需要保持最终一致性即可。</p>
<h2 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf"></a>setbuf</h2><p><code>setbuf</code>用于调节用户的写入流，不同于<code>getbuf</code>，<code>setbuf</code>的设计出发点是提升缓存的写入性能，其核心思想通过保证最终一致性来减少写入链的长度，与数据库中的 WAL 思想有些类似。</p>
<p>Ristretto 的设计中对 UPDATE 操作和 WRITE、DELETE 操作进行了分流，UPDATE 的写入链比其余两个更短。可以使用以下伪代码来表示三个操作的写入链。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Operation</span><span class="params">(key,value any)</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> isUpdateOrWrite &#123;</span><br><span class="line">        CreateObjectToInsert()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> isUpdate &#123;</span><br><span class="line">        <span class="keyword">return</span> Update()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> setBuf &lt;- op:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Update 操作由于不涉及到键的变更，因此与缓存控制模块中的<strong>写入门限</strong>无关，可以直接在缓存表中更新。而 Write 操作因为涉及到了键的变更，需要额外检查是否满足缓存的写入门限，而检查是否满足写入门限又涉及到了并发访问的问题。考虑到写入操作还涉及到键值对的过期，具有较高的时限性，这里再使用 batch 优化就不太合适了。在比较典型的进程缓存场景下，其实写入的并发量是不高的，因此这里只简单地使用了 channel，channel 内部的锁较为特殊比<code>sync.Mutex</code>速度更快。</p>
<p>Delete 操作的设计与 Write 操作的设计是密切相关的。Write 操作由于 channel 缓冲的存在被串行执行，这是一个慢速通道，如果某一时刻中积压的 Write 操作过多，可能会导致用户同时发起的 Delete 操作先于 Write 操作完成。即并发中的快慢路径问题。删除操作对于进程内缓存是及其重要的，如果操作发生乱序，可能会导致用户读取到过期数据，这是不能容忍的——缓存中允许少数据但不能容许多数据，否则缓存就失去了存在的意义。因此在 Ristretto 的设计中， Delete 操作同样也使用 channel 来执行。</p>
<p>使用 channel 还有另外一点考虑。如果进程中某一时刻突然有较多的写入，缓存的压力将会骤增，Ristretto 中使用了非阻塞的 channel 来丢弃过多的写入操作，这将会有助于缓解缓存压力。要知道，并不是每一次缓存写入都是极其重要的，但是我们可以确认如果一次缓存及其重要，那么它将会在未来一段时间内再次被写入。因此，丢弃一部分写操作有助于让缓存的写入性能变得更加平滑。</p>
<p>经 channel 发送出的数据会被一个后台 goroutine 处理，该 goroutine 负责检查该操作能否最终应用到缓存中，若被缓存拒绝，则操作会被丢弃并且不会通知用户。该 goroutine 的核心逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有被延迟的操作都会在这里被处理</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> i := &lt;-c.setBuf:</span><br><span class="line">      <span class="comment">// 如果没有指定 cost，根据指定策略计算 cost</span></span><br><span class="line">      <span class="keyword">if</span> i.Cost == <span class="number">0</span> &amp;&amp; c.cost != <span class="literal">nil</span> &amp;&amp; i.flag != itemDelete &#123;</span><br><span class="line">         i.Cost = c.cost(i.Value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !c.ignoreInternalCost &#123;</span><br><span class="line">         i.Cost += itemSize</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据不同的操作类型采取不同操作</span></span><br><span class="line">      <span class="keyword">switch</span> i.flag &#123;</span><br><span class="line">      <span class="keyword">case</span> itemNew:</span><br><span class="line">         <span class="comment">// 根据策略判断能否写入</span></span><br><span class="line">         victims, added := c.policy.Add(i.Key, i.Cost)</span><br><span class="line">         <span class="keyword">if</span> added &#123;</span><br><span class="line">            c.store.Set(i)</span><br><span class="line">            c.Metrics.add(keyAdd, i.Key, <span class="number">1</span>)</span><br><span class="line">            trackAdmission(i.Key)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.onReject(i)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 驱逐失效的缓存</span></span><br><span class="line">         <span class="keyword">for</span> _, victim := <span class="keyword">range</span> victims &#123;</span><br><span class="line">            victim.Conflict, victim.Value = c.store.Del(victim.Key, <span class="number">0</span>)</span><br><span class="line">            onEvict(victim)</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> itemUpdate:</span><br><span class="line">         c.policy.Update(i.Key, i.Cost)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> itemDelete:</span><br><span class="line">         c.policy.Del(i.Key) <span class="comment">// Deals with metrics updates.</span></span><br><span class="line">         _, val := c.store.Del(i.Key, i.Conflict)</span><br><span class="line">         c.onExit(val)</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">// 清理和退出逻辑</span></span><br><span class="line">   <span class="keyword">case</span> &lt;-c.cleanupTicker.C:</span><br><span class="line">      c.store.Cleanup(c.policy, onEvict)</span><br><span class="line">   <span class="keyword">case</span> &lt;-c.stop:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码片段的逻辑非常简单，不过多描述。</p>
<h2 id="写入与逐出策略"><a href="#写入与逐出策略" class="headerlink" title="写入与逐出策略"></a>写入与逐出策略</h2><p>当 Ristretto 并没有达到缓存使用的内存上限时，所有的键值对都可以自由地写入缓存中；当缓存使用的内存达到上限时，则会根据写入门限和逐出策略来决定哪些键值对需要保留，哪些键值对需要被逐出。<code>defaultPolicy</code>结构体中包括了使用的写入门限实现与逐出策略实现，该结构体使用互斥锁进行保护，其中<code>admit</code>字段实现了写入控制策略，<code>evict</code>字段实现了逐出策略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> defaultPolicy <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    admit    *tinyLFU    <span class="comment">// 写入策略实现</span></span><br><span class="line">    evict    *sampledLFU <span class="comment">// 逐出策略实现</span></span><br><span class="line">    itemsCh  <span class="keyword">chan</span> []<span class="type">uint64</span></span><br><span class="line">    stop     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    isClosed <span class="type">bool</span></span><br><span class="line">    metrics  *Metrics</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进程内缓存达到上限时，一个 key 能否写入取决于自身准入值和 Cost 以及缓存中存储的其余键的准入值和 Cost。一个键的准入值描述了它在<strong>当前的采样周期内</strong>被读取操作所需求的程度高低，在不同的采样周期内，一个键的准入值是不同的。这种定义方式不仅有助于更好地描述缓存使用者在最近一段时间内的需求，也有助于降低计算准入值所需要的数据量。在这种定义方式下，准入值是与时间相关的，每次获得准入值都需要计算，因此对 LFU 算法的效率有一定要求。</p>
<p>为了更好地衡量一个键值对带来的影响，Ristretto 还引入了 Cost 来描述键值对的体量。一个键值对的 Cost 越大，就意味着它需要逐出缓存中更多的键来满足空间需求。而 Ristretto 在一轮比较中只会逐出一个键值对。这代表了 Cost 较大的键值对在写入时会经历更多轮的比较，这意味着更多的键值对会被抽样和比较，如果 newKey 的准入值并不够高，那么它很有可能会在多轮比较中被淘汰。这种逐出算法有利于筛选出准入值和 Cost 都较为适中的键值对，保证缓存在<strong>有限的空间内</strong>保留更多更有价值的键值对。</p>
<p>当缓存已写满时，Ristretto 会使用 tinyLFU 算法计算出需要新写入的 newKey 的准入值，然后在缓存已有的键值对中随机抽样一组，并选出其中准入值最小的键 minKey。如果 minKey 的准入值大于 newKey，那么会拒绝写入 newKey；否则会将 minKey 从缓存中逐出，更新缓存中的剩余空间并判断是否有足够空间写入。如果空间仍不足够，会重复上述过程，直至 newKey 被拒绝或被接受。该过程在 Ristretto 中的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数会尝试将键插入缓存中，如果判别过程中发生了键的逐出，被逐出的键会被记录在返回值evicted中</span></span><br><span class="line"><span class="comment">// 返回值accepted代表键是否允许写入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *defaultPolicy)</span></span> Add(key <span class="type">uint64</span>, cost <span class="type">int64</span>) (evicted []*Item,accepted <span class="type">bool</span>) &#123;</span><br><span class="line">    p.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.Unlock()</span><br><span class="line">    <span class="comment">// Cannot add an item bigger than entire cache.</span></span><br><span class="line">    <span class="keyword">if</span> cost &gt; p.evict.getMaxCost() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Double Check，由于写操作的延迟，本应该是更新操作</span></span><br><span class="line">    <span class="keyword">if</span> has := p.evict.updateIfHas(key, cost); has &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算剩余空间</span></span><br><span class="line">    room := p.evict.roomLeft(cost) </span><br><span class="line">    <span class="comment">// 还有剩余空间就直接插入</span></span><br><span class="line">    <span class="keyword">if</span> room &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        p.evict.add(key, cost)</span><br><span class="line">        p.metrics.add(costAdd, key, <span class="type">uint64</span>(cost))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算将要插入键的准入值</span></span><br><span class="line">    incHits := p.admit.Estimate(key)</span><br><span class="line">    sample := <span class="built_in">make</span>([]*policyPair, <span class="number">0</span>, lfuSample)</span><br><span class="line">    victims := <span class="built_in">make</span>([]*Item, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 重复逐出键直至有足够空间</span></span><br><span class="line">    <span class="keyword">for</span> ; room &lt; <span class="number">0</span>; room = p.evict.roomLeft(cost) &#123;</span><br><span class="line">        <span class="comment">// 随机采样几个键，并计算其中的最小准入值</span></span><br><span class="line">        sample = p.evict.fillSample(sample)</span><br><span class="line">        minKey, minHits, minId, minCost := <span class="type">uint64</span>(<span class="number">0</span>), <span class="type">int64</span>(math.MaxInt64), <span class="number">0</span>, <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i, pair := <span class="keyword">range</span> sample &#123;</span><br><span class="line">            <span class="keyword">if</span> hits := p.admit.Estimate(pair.key); hits &lt; minHits &#123;</span><br><span class="line">                minKey, minHits, minId, minCost = pair.key, hits, i, pair.cost</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最小准入值大于要插入键的准入值，拒绝进入缓存</span></span><br><span class="line">        <span class="keyword">if</span> incHits &lt; minHits &#123;</span><br><span class="line">            p.metrics.add(rejectSets, key, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> victims, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逐出准入值最小的键</span></span><br><span class="line">        p.evict.del(minKey)</span><br><span class="line">        sample[minId] = sample[<span class="built_in">len</span>(sample)<span class="number">-1</span>]</span><br><span class="line">        sample = sample[:<span class="built_in">len</span>(sample)<span class="number">-1</span>]</span><br><span class="line">        victims = <span class="built_in">append</span>(victims, &amp;Item&#123;</span><br><span class="line">            Key:      minKey,</span><br><span class="line">            Conflict: <span class="number">0</span>,</span><br><span class="line">            Cost:     minCost,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    p.evict.add(key, cost)</span><br><span class="line">    p.metrics.add(costAdd, key, <span class="type">uint64</span>(cost))</span><br><span class="line">    <span class="keyword">return</span> victims, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当尝试插入一个 newKey 时，可能会出现 newKey 并没有写入，但是仍有一部分键被逐出的情况。</p>
<h2 id="tinyLFU-准入门限"><a href="#tinyLFU-准入门限" class="headerlink" title="tinyLFU 准入门限"></a>tinyLFU 准入门限</h2><p>写入策略主要实现在<code>tinyLFU</code>结构体中，该结构体及其算法实现了 tinyLFU 算法，它包含四个字段。其中，freq 字段是一个 Count-Min sketch（cmSketch is a Count-Min sketch implementation with 4-bit counters, heavily based on Damian Gryski’s <a target="_blank" rel="noopener" href="https://github.com/dgryski/go-tinylfu/blob/master/cm4.go">CM4</a>），door 字段是一个布隆过滤器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tinyLFU <span class="keyword">struct</span> &#123;</span><br><span class="line">    freq    *cmSketch	<span class="comment">// Count-Min sketch</span></span><br><span class="line">    door    *z.Bloom 	<span class="comment">// 布隆过滤器</span></span><br><span class="line">    incrs   <span class="type">int64</span>		<span class="comment">// 当前记录的键值对数量</span></span><br><span class="line">    resetAt <span class="type">int64</span>		<span class="comment">// 重置门限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 tinyLFU 算法中，一个 Key 的准入门限是由 freq 和 door 两者共同决定的，先简要介绍一下 Count-Min sketch 算法。</p>
<p>Count-Min sketch 是一个类似于 HyperLogLog 的计数算法，在数据量较大时通过牺牲一定的准确度来提升运算效率。但 HyperLogLog 算法目的是估算数据量的多少，而 Count-Min sketch 则为了估算一个数出现的频率。该算法内部包含了 n 个哈希算法和一个 n*m 大小的数组，当一个 key 需要被记录时，会使用不同的哈希算法计算出哈希值并对 m 取模后存入到数组对应位置。当需要统计时，使用同样的方法得到一个 n 大小的数组，被统计数的出现频率被视为该数组中的最小值。</p>
<p>Count-Min sketch 算法的准确率与数据规模是密切相关的，该算法需要设置一个阈值以初始化，当数据规模超出阈值后，估算频率的准确度会有较大的偏离。在 tinyLFU 中会只保留一定规模的键值对，当键值对超出规模时会被重置。这种设计不仅保证了 Count-Min sketch 算法的准确度维持在一个相对合理的范围内，还能保证只统计过去一段时间内的读取操作，实践证明不仅取得了较好的缓存命中率，还有助于限制需要记录的数据规模。</p>
<p>当需要评估一个键的准入值时，tinyLFU 主要考虑了两个维度的问题：该键被需要的频率、是否有相似的键值被需要。该键被需要的频率，即该键被读取的次数是需要考虑的主要因素，tinyLFU 中是使用Count-Min sketch 算法实现的。而另外一个因素，是否有相似的键值被需要，则体现了该键在未来一段时间内被读取的可能性。缓存中的键值对在大多数时间内都是具有关联性的，因为这些键很有可能是通过某些算法来实现的。一个键在过去一段时间内曾被读取就意味着一个与之相似的键很有可能在未来的一段时间内被读取，但这种因果关系并不是强因果关系，因此这一因素被作为次要因素来考虑。tinyLFU 中使用布隆过滤器来描述键的相似性问题，在布隆过滤器中相似的键更有可能被写入到相同的哈希槽中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *tinyLFU)</span></span> Estimate(key <span class="type">uint64</span>) <span class="type">int64</span> &#123;</span><br><span class="line">   <span class="comment">// 评估键在过去被读取的频率</span></span><br><span class="line">   hits := p.freq.Estimate(key)</span><br><span class="line">   <span class="comment">// 评估是否有相似键被读取</span></span><br><span class="line">   <span class="keyword">if</span> p.door.Has(key) &#123;</span><br><span class="line">      hits++</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> hits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一方面，布隆过滤器还会限制什么样的键能够进入到 Count-Min sketch。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *tinyLFU)</span></span> Increment(key <span class="type">uint64</span>) &#123;</span><br><span class="line">   <span class="comment">// 过滤布隆过滤器中不存在的key</span></span><br><span class="line">   <span class="keyword">if</span> added := p.door.AddIfNotHas(key); !added &#123;</span><br><span class="line">      p.freq.Increment(key)</span><br><span class="line">   &#125;</span><br><span class="line">   p.incrs++</span><br><span class="line">   <span class="comment">// 超过上限，重置</span></span><br><span class="line">   <span class="keyword">if</span> p.incrs &gt;= p.resetAt &#123;</span><br><span class="line">      p.reset()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据官方的说法，这是为了防止长尾键污染缓存。</p>
<blockquote>
<p>Before we place a new key in TinyLFU, <a target="_blank" rel="noopener" href="https://github.com/dgraph-io/ristretto">Ristretto</a> uses a bloom filter to first check if the key has been seen before. Only if the key is already present in the bloom filter, is it inserted into the TinyLFU. This is to avoid <em>polluting</em> TinyLFU with a long tail of keys that are not seen more than once.</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Ristretto 与其他缓存最大的不同之处是其使用了 LFU 算法。在高并发情景下，为了降低 LFU 计数器这一全局资源所带来的竞争，Ristretto 采用了<strong>本地缓存</strong>、<strong>批处理</strong>、<strong>采样</strong>的思想来改变访问 LFU 计数器的方式，取得了非常好的效果。在工程实现上，最值得学习的是采用<code>sync.Pool</code>搭配 ring_buffer 的模式，实现了一个近似的 thread local 缓存。在允许一定数据丢失的场景下，如采样，使用这种思路可以巧妙地将流处理转换为批处理模式，大大提升系统的吞吐量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="tangrc99"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">tangrc99</p>
  <div class="site-description" itemprop="description">技术爱好者</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element">
    lol welcome!
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/tangrc99" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tangrc99" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:trc99@qq.com" title="E-Mail → mailto:trc99@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/tangrc99" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tangrc99" rel="noopener" target="_blank"><i class="fa fa-link fa-fw"></i>知乎</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tangrc99</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
