<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tangrc99.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="技术爱好者">
<meta property="og:type" content="website">
<meta property="og:title" content="Sepk">
<meta property="og:url" content="https://tangrc99.com/page/5/index.html">
<meta property="og:site_name" content="Sepk">
<meta property="og:description" content="技术爱好者">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="tangrc99">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tangrc99.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Sepk</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sepk</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tangrc99.com/2023/02/25/Ristretto-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="tangrc99">
      <meta itemprop="description" content="技术爱好者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sepk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/25/Ristretto-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Ristretto 源码阅读笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-25 22:02:44" itemprop="dateCreated datePublished" datetime="2023-02-25T22:02:44+08:00">2023-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-26 14:22:10" itemprop="dateModified" datetime="2023-02-26T14:22:10+08:00">2023-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Ristretto 是一个基于 Go 语言的、可并发访问的、可设置内存存储上限的高性能进程内缓存库。Ristretto 的含义为“超浓缩咖啡”，该命名是因为该项目的目标是与知名 JAVA 缓存库 Caffeine 竞争。</p>
<p>相比其他 Go 语言的进程内缓存项目，Ristretto 的设计与实现上具有以下几个显著特点：</p>
<ul>
<li>基于<strong>近似</strong> LFU 算法实现缓存逐出；</li>
<li>支持多种 key 与 value 类型，能够在进程内缓存较为复杂的结构体；</li>
<li><strong>写入门限</strong>（DoorKeeper）设计，过滤写入键值对，提高缓存命中率；</li>
<li>Key Cost 设计，能够更好地描述一个键值对对缓存的负载量；</li>
<li>利用<code>sync.Pool</code>实现类似 thread_local 缓存，减少并发竞争。</li>
</ul>
<h2 id="Ristretto-软件框架"><a href="#Ristretto-软件框架" class="headerlink" title="Ristretto 软件框架"></a>Ristretto 软件框架</h2><p>Ristretto 的实现并不复杂，从功能上可以将 Ristretto 划分为几个模块：存储模块、操作缓冲模块、缓存控制模块、缓存计数模块，几个模块分别由不同的数据结构来负责。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 存储模块</span></span><br><span class="line">    store store</span><br><span class="line">    <span class="comment">// 缓存控制模块</span></span><br><span class="line">    policy policy</span><br><span class="line">    <span class="comment">// 读写操作缓冲</span></span><br><span class="line">    getBuf *ringBuffer</span><br><span class="line">    setBuf <span class="keyword">chan</span> *Item</span><br><span class="line">    <span class="comment">// 缓存计数</span></span><br><span class="line">    Metrics *Metrics</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作缓冲模块可以分为读操作缓冲与写操作缓冲，两者会采取不同的策略来减少对缓存控制模块的访问。缓存控制模块具有 tinyLFU 和 sampledLFU，分别负责缓存的准入和逐出。缓存计数模块则是用于读取 Ristretto 的缓存命中率等日志信息。</p>
<h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>存储模块使用了 Go 语言中非常经典的分片哈希表设计，目前的实践已经证明这是在 Go 中综合并发性能最好的并发哈希表设计，其他的一些同类型项目也都采用了类似的设计。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存 metadata</span></span><br><span class="line"><span class="keyword">type</span> storeItem <span class="keyword">struct</span> &#123;</span><br><span class="line">    key        <span class="type">uint64</span>	<span class="comment">// 键</span></span><br><span class="line">    conflict   <span class="type">uint64</span>	<span class="comment">// 用于解决哈希冲突</span></span><br><span class="line">    value      <span class="keyword">interface</span>&#123;&#125;	<span class="comment">// 值</span></span><br><span class="line">    expiration time.Time	<span class="comment">// 过期时间，0 代表无</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓存大表</span></span><br><span class="line"><span class="keyword">type</span> shardedMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    shards    []*lockedMap	<span class="comment">// 分片表</span></span><br><span class="line">    expiryMap *expirationMap	<span class="comment">// 过期时间表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓存分片表</span></span><br><span class="line"><span class="keyword">type</span> lockedMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    data <span class="keyword">map</span>[<span class="type">uint64</span>]storeItem</span><br><span class="line">    em   *expirationMap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Ristretto 中，哈希表的分片和存储都使用了同一个哈希值，为了解决哈希冲突的问题，每一个键值对都带有使用另一个哈希算法计算出的 conflict 值，避免冲突的策略是不允许覆盖。当键值对时为数字类型时，哈希值会使用转化后的 uint64 类型；当键值对为<code>string</code>或<code>[]byte</code>类型时会使用 Go runtime 中的<code>runtime.memhash</code>函数来计算哈希值。由于使用了汇编代码来实现哈希值计算，该哈希算法相比其他常见类型的哈希算法计算速度更快。</p>
<h2 id="getBuf"><a href="#getBuf" class="headerlink" title="getBuf"></a>getBuf</h2><p><code>getBuf</code>用于控制“用户读取缓存”这一行为传递到 tinyLFU 的速度和方式，具象化来说就是记录下每一次读取操作需要访问的键值对，在 Ristretto 中的实现中使用了键的哈希值。相比于 LRU 和近似 LRU 算法，实现一个 LFU 或近似 LFU 算法需要记录更多的数据。而进程内缓存这一应用场景，通常都要求较高的并发读写性能，会有较多的线程访问。一个进程内共享的缓存意味着记录 LFU 相关信息的数据结构同样会被高并发地访问，因此有必要降低 LFU 数据结构的竞争来提高缓存的整体性能。</p>
<p>降低并发度，常用的方法就是队列和分片这两种模式，Ristretto 中选择的是队列方式。其核心思想是将 stream 转化为 batch stream，具体做法是在每一个协程栈上使用一个thread local 数据结构来缓存该协程读取的键值对，当协程本地的数据聚合到一定规模时再批量写入缓存控制模块中。由于 Go 中并不存在<code>thread_local</code>关键字，Ristretto 利用了<code>sync.Pool</code>的特性来实现了一个近似的 thread local。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ringBuffer)</span></span> Push(item <span class="type">uint64</span>) &#123;</span><br><span class="line">    <span class="comment">// 从 Pool 中取出一个对象，将数据放入后归还</span></span><br><span class="line">    stripe := b.pool.Get().(*ringStripe)</span><br><span class="line">    stripe.Push(item)</span><br><span class="line">    <span class="comment">// 对象归还时，内部信息并不会清楚</span></span><br><span class="line">    b.pool.Put(stripe)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ringStripe)</span></span> Push(item <span class="type">uint64</span>) &#123;</span><br><span class="line">    <span class="comment">// 将读取的键值对放入切片中</span></span><br><span class="line">    s.data = <span class="built_in">append</span>(s.data, item)</span><br><span class="line">    <span class="comment">// 切片满了之后，通过 channel 无阻塞地发送</span></span><br><span class="line">    <span class="comment">// 若 channel 已满，丢弃消息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s.data) &gt;= s.capa &#123;</span><br><span class="line">        <span class="keyword">if</span> s.cons.Push(s.data) &#123;</span><br><span class="line">            s.data = <span class="built_in">make</span>([]<span class="type">uint64</span>, <span class="number">0</span>, s.capa)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.data = s.data[:<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个协程需要读取键值对时，会首先从<code>sync.Pool</code>中取出一个<code>ringStripe</code>对象，这里获取对象会优先考虑从 P 的本地栈来获取。<code>ringStripe</code>对象内具有一个切片，用来暂时存储该键值对，只有当切片存满之后，才会非阻塞地通过 channel 发送给缓存控制模块。在官方博客中提到，该 channel 的长度设置得比较小，并且当 channel 满时会选择丢弃<code>ringStripe</code>中的数据（使用 select实现）。由于缓存控制模块中收到的是 batch stream，因此在获取锁的过程中能够连续处理更多信息，降低了需要获取锁的次数，因此能够大大降低此处的并发冲突。另一点则是利用了<code>sync.Pool</code>的 thread local 特性，避免在聚合的过程中需要访问一个进程内全局可见的数据结构，这也是常用的优化手段。最后，经过聚合后的读取信息将会被<code>defaultPolicy</code>接收，用于调控缓存的准入门限。</p>
<p>当<code>sync.Pool</code>发生 GC、channel 满时，都会导致读取缓存的信息丢失，但是这对 LFU 算法的影响是比较小的。因为在理想情况下，用户在某一时刻对缓存的读取是均匀的，丢弃少部分读取信息相当于是一个抽样。这种处理有助于限制分析用户读取信息时的 CPU 利用率，虽然牺牲了一部分 LFU 的准确性，但是能使得软件整体性能提升。</p>
<p>这里的设计综合了 thread local 降低并发以及批处理降低并发的思想，之所以能够采取这种设计是因为缓存控制模块是允许有延迟的，只需要保持最终一致性即可。</p>
<h2 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf"></a>setbuf</h2><p><code>setbuf</code>用于调节用户的写入流，不同于<code>getbuf</code>，<code>setbuf</code>的设计出发点是提升缓存的写入性能，其核心思想通过保证最终一致性来减少写入链的长度，与数据库中的 WAL 思想有些类似。</p>
<p>Ristretto 的设计中对 UPDATE 操作和 WRITE、DELETE 操作进行了分流，UPDATE 的写入链比其余两个更短。可以使用以下伪代码来表示三个操作的写入链。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Operation</span><span class="params">(key,value any)</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> isUpdateOrWrite &#123;</span><br><span class="line">        CreateObjectToInsert()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> isUpdate &#123;</span><br><span class="line">        <span class="keyword">return</span> Update()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> setBuf &lt;- op:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Update 操作由于不涉及到键的变更，因此与缓存控制模块中的<strong>写入门限</strong>无关，可以直接在缓存表中更新。而 Write 操作因为涉及到了键的变更，需要额外检查是否满足缓存的写入门限，而检查是否满足写入门限又涉及到了并发访问的问题。考虑到写入操作还涉及到键值对的过期，具有较高的时限性，这里再使用 batch 优化就不太合适了。在比较典型的进程缓存场景下，其实写入的并发量是不高的，因此这里只简单地使用了 channel，channel 内部的锁较为特殊比<code>sync.Mutex</code>速度更快。</p>
<p>Delete 操作的设计与 Write 操作的设计是密切相关的。Write 操作由于 channel 缓冲的存在被串行执行，这是一个慢速通道，如果某一时刻中积压的 Write 操作过多，可能会导致用户同时发起的 Delete 操作先于 Write 操作完成。即并发中的快慢路径问题。删除操作对于进程内缓存是及其重要的，如果操作发生乱序，可能会导致用户读取到过期数据，这是不能容忍的——缓存中允许少数据但不能容许多数据，否则缓存就失去了存在的意义。因此在 Ristretto 的设计中， Delete 操作同样也使用 channel 来执行。</p>
<p>使用 channel 还有另外一点考虑。如果进程中某一时刻突然有较多的写入，缓存的压力将会骤增，Ristretto 中使用了非阻塞的 channel 来丢弃过多的写入操作，这将会有助于缓解缓存压力。要知道，并不是每一次缓存写入都是极其重要的，但是我们可以确认如果一次缓存及其重要，那么它将会在未来一段时间内再次被写入。因此，丢弃一部分写操作有助于让缓存的写入性能变得更加平滑。</p>
<p>经 channel 发送出的数据会被一个后台 goroutine 处理，该 goroutine 负责检查该操作能否最终应用到缓存中，若被缓存拒绝，则操作会被丢弃并且不会通知用户。该 goroutine 的核心逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有被延迟的操作都会在这里被处理</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> i := &lt;-c.setBuf:</span><br><span class="line">      <span class="comment">// 如果没有指定 cost，根据指定策略计算 cost</span></span><br><span class="line">      <span class="keyword">if</span> i.Cost == <span class="number">0</span> &amp;&amp; c.cost != <span class="literal">nil</span> &amp;&amp; i.flag != itemDelete &#123;</span><br><span class="line">         i.Cost = c.cost(i.Value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !c.ignoreInternalCost &#123;</span><br><span class="line">         i.Cost += itemSize</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据不同的操作类型采取不同操作</span></span><br><span class="line">      <span class="keyword">switch</span> i.flag &#123;</span><br><span class="line">      <span class="keyword">case</span> itemNew:</span><br><span class="line">         <span class="comment">// 根据策略判断能否写入</span></span><br><span class="line">         victims, added := c.policy.Add(i.Key, i.Cost)</span><br><span class="line">         <span class="keyword">if</span> added &#123;</span><br><span class="line">            c.store.Set(i)</span><br><span class="line">            c.Metrics.add(keyAdd, i.Key, <span class="number">1</span>)</span><br><span class="line">            trackAdmission(i.Key)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.onReject(i)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 驱逐失效的缓存</span></span><br><span class="line">         <span class="keyword">for</span> _, victim := <span class="keyword">range</span> victims &#123;</span><br><span class="line">            victim.Conflict, victim.Value = c.store.Del(victim.Key, <span class="number">0</span>)</span><br><span class="line">            onEvict(victim)</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> itemUpdate:</span><br><span class="line">         c.policy.Update(i.Key, i.Cost)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> itemDelete:</span><br><span class="line">         c.policy.Del(i.Key) <span class="comment">// Deals with metrics updates.</span></span><br><span class="line">         _, val := c.store.Del(i.Key, i.Conflict)</span><br><span class="line">         c.onExit(val)</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">// 清理和退出逻辑</span></span><br><span class="line">   <span class="keyword">case</span> &lt;-c.cleanupTicker.C:</span><br><span class="line">      c.store.Cleanup(c.policy, onEvict)</span><br><span class="line">   <span class="keyword">case</span> &lt;-c.stop:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码片段的逻辑非常简单，不过多描述。</p>
<h2 id="写入与逐出策略"><a href="#写入与逐出策略" class="headerlink" title="写入与逐出策略"></a>写入与逐出策略</h2><p>当 Ristretto 并没有达到缓存使用的内存上限时，所有的键值对都可以自由地写入缓存中；当缓存使用的内存达到上限时，则会根据写入门限和逐出策略来决定哪些键值对需要保留，哪些键值对需要被逐出。<code>defaultPolicy</code>结构体中包括了使用的写入门限实现与逐出策略实现，该结构体使用互斥锁进行保护，其中<code>admit</code>字段实现了写入控制策略，<code>evict</code>字段实现了逐出策略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> defaultPolicy <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    admit    *tinyLFU    <span class="comment">// 写入策略实现</span></span><br><span class="line">    evict    *sampledLFU <span class="comment">// 逐出策略实现</span></span><br><span class="line">    itemsCh  <span class="keyword">chan</span> []<span class="type">uint64</span></span><br><span class="line">    stop     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    isClosed <span class="type">bool</span></span><br><span class="line">    metrics  *Metrics</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进程内缓存达到上限时，一个 key 能否写入取决于自身准入值和 Cost 以及缓存中存储的其余键的准入值和 Cost。一个键的准入值描述了它在<strong>当前的采样周期内</strong>被读取操作所需求的程度高低，在不同的采样周期内，一个键的准入值是不同的。这种定义方式不仅有助于更好地描述缓存使用者在最近一段时间内的需求，也有助于降低计算准入值所需要的数据量。在这种定义方式下，准入值是与时间相关的，每次获得准入值都需要计算，因此对 LFU 算法的效率有一定要求。</p>
<p>为了更好地衡量一个键值对带来的影响，Ristretto 还引入了 Cost 来描述键值对的体量。一个键值对的 Cost 越大，就意味着它需要逐出缓存中更多的键来满足空间需求。而 Ristretto 在一轮比较中只会逐出一个键值对。这代表了 Cost 较大的键值对在写入时会经历更多轮的比较，这意味着更多的键值对会被抽样和比较，如果 newKey 的准入值并不够高，那么它很有可能会在多轮比较中被淘汰。这种逐出算法有利于筛选出准入值和 Cost 都较为适中的键值对，保证缓存在<strong>有限的空间内</strong>保留更多更有价值的键值对。</p>
<p>当缓存已写满时，Ristretto 会使用 tinyLFU 算法计算出需要新写入的 newKey 的准入值，然后在缓存已有的键值对中随机抽样一组，并选出其中准入值最小的键 minKey。如果 minKey 的准入值大于 newKey，那么会拒绝写入 newKey；否则会将 minKey 从缓存中逐出，更新缓存中的剩余空间并判断是否有足够空间写入。如果空间仍不足够，会重复上述过程，直至 newKey 被拒绝或被接受。该过程在 Ristretto 中的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数会尝试将键插入缓存中，如果判别过程中发生了键的逐出，被逐出的键会被记录在返回值evicted中</span></span><br><span class="line"><span class="comment">// 返回值accepted代表键是否允许写入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *defaultPolicy)</span></span> Add(key <span class="type">uint64</span>, cost <span class="type">int64</span>) (evicted []*Item,accepted <span class="type">bool</span>) &#123;</span><br><span class="line">    p.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.Unlock()</span><br><span class="line">    <span class="comment">// Cannot add an item bigger than entire cache.</span></span><br><span class="line">    <span class="keyword">if</span> cost &gt; p.evict.getMaxCost() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Double Check，由于写操作的延迟，本应该是更新操作</span></span><br><span class="line">    <span class="keyword">if</span> has := p.evict.updateIfHas(key, cost); has &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算剩余空间</span></span><br><span class="line">    room := p.evict.roomLeft(cost) </span><br><span class="line">    <span class="comment">// 还有剩余空间就直接插入</span></span><br><span class="line">    <span class="keyword">if</span> room &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        p.evict.add(key, cost)</span><br><span class="line">        p.metrics.add(costAdd, key, <span class="type">uint64</span>(cost))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算将要插入键的准入值</span></span><br><span class="line">    incHits := p.admit.Estimate(key)</span><br><span class="line">    sample := <span class="built_in">make</span>([]*policyPair, <span class="number">0</span>, lfuSample)</span><br><span class="line">    victims := <span class="built_in">make</span>([]*Item, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 重复逐出键直至有足够空间</span></span><br><span class="line">    <span class="keyword">for</span> ; room &lt; <span class="number">0</span>; room = p.evict.roomLeft(cost) &#123;</span><br><span class="line">        <span class="comment">// 随机采样几个键，并计算其中的最小准入值</span></span><br><span class="line">        sample = p.evict.fillSample(sample)</span><br><span class="line">        minKey, minHits, minId, minCost := <span class="type">uint64</span>(<span class="number">0</span>), <span class="type">int64</span>(math.MaxInt64), <span class="number">0</span>, <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i, pair := <span class="keyword">range</span> sample &#123;</span><br><span class="line">            <span class="keyword">if</span> hits := p.admit.Estimate(pair.key); hits &lt; minHits &#123;</span><br><span class="line">                minKey, minHits, minId, minCost = pair.key, hits, i, pair.cost</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最小准入值大于要插入键的准入值，拒绝进入缓存</span></span><br><span class="line">        <span class="keyword">if</span> incHits &lt; minHits &#123;</span><br><span class="line">            p.metrics.add(rejectSets, key, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> victims, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逐出准入值最小的键</span></span><br><span class="line">        p.evict.del(minKey)</span><br><span class="line">        sample[minId] = sample[<span class="built_in">len</span>(sample)<span class="number">-1</span>]</span><br><span class="line">        sample = sample[:<span class="built_in">len</span>(sample)<span class="number">-1</span>]</span><br><span class="line">        victims = <span class="built_in">append</span>(victims, &amp;Item&#123;</span><br><span class="line">            Key:      minKey,</span><br><span class="line">            Conflict: <span class="number">0</span>,</span><br><span class="line">            Cost:     minCost,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    p.evict.add(key, cost)</span><br><span class="line">    p.metrics.add(costAdd, key, <span class="type">uint64</span>(cost))</span><br><span class="line">    <span class="keyword">return</span> victims, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当尝试插入一个 newKey 时，可能会出现 newKey 并没有写入，但是仍有一部分键被逐出的情况。</p>
<h2 id="tinyLFU-准入门限"><a href="#tinyLFU-准入门限" class="headerlink" title="tinyLFU 准入门限"></a>tinyLFU 准入门限</h2><p>写入策略主要实现在<code>tinyLFU</code>结构体中，该结构体及其算法实现了 tinyLFU 算法，它包含四个字段。其中，freq 字段是一个 Count-Min sketch（cmSketch is a Count-Min sketch implementation with 4-bit counters, heavily based on Damian Gryski’s <a target="_blank" rel="noopener" href="https://github.com/dgryski/go-tinylfu/blob/master/cm4.go">CM4</a>），door 字段是一个布隆过滤器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tinyLFU <span class="keyword">struct</span> &#123;</span><br><span class="line">    freq    *cmSketch	<span class="comment">// Count-Min sketch</span></span><br><span class="line">    door    *z.Bloom 	<span class="comment">// 布隆过滤器</span></span><br><span class="line">    incrs   <span class="type">int64</span>		<span class="comment">// 当前记录的键值对数量</span></span><br><span class="line">    resetAt <span class="type">int64</span>		<span class="comment">// 重置门限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 tinyLFU 算法中，一个 Key 的准入门限是由 freq 和 door 两者共同决定的，先简要介绍一下 Count-Min sketch 算法。</p>
<p>Count-Min sketch 是一个类似于 HyperLogLog 的计数算法，在数据量较大时通过牺牲一定的准确度来提升运算效率。但 HyperLogLog 算法目的是估算数据量的多少，而 Count-Min sketch 则为了估算一个数出现的频率。该算法内部包含了 n 个哈希算法和一个 n*m 大小的数组，当一个 key 需要被记录时，会使用不同的哈希算法计算出哈希值并对 m 取模后存入到数组对应位置。当需要统计时，使用同样的方法得到一个 n 大小的数组，被统计数的出现频率被视为该数组中的最小值。</p>
<p>Count-Min sketch 算法的准确率与数据规模是密切相关的，该算法需要设置一个阈值以初始化，当数据规模超出阈值后，估算频率的准确度会有较大的偏离。在 tinyLFU 中会只保留一定规模的键值对，当键值对超出规模时会被重置。这种设计不仅保证了 Count-Min sketch 算法的准确度维持在一个相对合理的范围内，还能保证只统计过去一段时间内的读取操作，实践证明不仅取得了较好的缓存命中率，还有助于限制需要记录的数据规模。</p>
<p>当需要评估一个键的准入值时，tinyLFU 主要考虑了两个维度的问题：该键被需要的频率、是否有相似的键值被需要。该键被需要的频率，即该键被读取的次数是需要考虑的主要因素，tinyLFU 中是使用Count-Min sketch 算法实现的。而另外一个因素，是否有相似的键值被需要，则体现了该键在未来一段时间内被读取的可能性。缓存中的键值对在大多数时间内都是具有关联性的，因为这些键很有可能是通过某些算法来实现的。一个键在过去一段时间内曾被读取就意味着一个与之相似的键很有可能在未来的一段时间内被读取，但这种因果关系并不是强因果关系，因此这一因素被作为次要因素来考虑。tinyLFU 中使用布隆过滤器来描述键的相似性问题，在布隆过滤器中相似的键更有可能被写入到相同的哈希槽中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *tinyLFU)</span></span> Estimate(key <span class="type">uint64</span>) <span class="type">int64</span> &#123;</span><br><span class="line">   <span class="comment">// 评估键在过去被读取的频率</span></span><br><span class="line">   hits := p.freq.Estimate(key)</span><br><span class="line">   <span class="comment">// 评估是否有相似键被读取</span></span><br><span class="line">   <span class="keyword">if</span> p.door.Has(key) &#123;</span><br><span class="line">      hits++</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> hits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一方面，布隆过滤器还会限制什么样的键能够进入到 Count-Min sketch。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *tinyLFU)</span></span> Increment(key <span class="type">uint64</span>) &#123;</span><br><span class="line">   <span class="comment">// 过滤布隆过滤器中不存在的key</span></span><br><span class="line">   <span class="keyword">if</span> added := p.door.AddIfNotHas(key); !added &#123;</span><br><span class="line">      p.freq.Increment(key)</span><br><span class="line">   &#125;</span><br><span class="line">   p.incrs++</span><br><span class="line">   <span class="comment">// 超过上限，重置</span></span><br><span class="line">   <span class="keyword">if</span> p.incrs &gt;= p.resetAt &#123;</span><br><span class="line">      p.reset()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据官方的说法，这是为了防止长尾键污染缓存。</p>
<blockquote>
<p>Before we place a new key in TinyLFU, <a target="_blank" rel="noopener" href="https://github.com/dgraph-io/ristretto">Ristretto</a> uses a bloom filter to first check if the key has been seen before. Only if the key is already present in the bloom filter, is it inserted into the TinyLFU. This is to avoid <em>polluting</em> TinyLFU with a long tail of keys that are not seen more than once.</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Ristretto 与其他缓存最大的不同之处是其使用了 LFU 算法。在高并发情景下，为了降低 LFU 计数器这一全局资源所带来的竞争，Ristretto 采用了<strong>本地缓存</strong>、<strong>批处理</strong>、<strong>采样</strong>的思想来改变访问 LFU 计数器的方式，取得了非常好的效果。在工程实现上，最值得学习的是采用<code>sync.Pool</code>搭配 ring_buffer 的模式，实现了一个近似的 thread local 缓存。在允许一定数据丢失的场景下，如采样，使用这种思路可以巧妙地将流处理转换为批处理模式，大大提升系统的吞吐量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tangrc99.com/2023/02/13/Lua-%E8%84%9A%E6%9C%AC%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="tangrc99">
      <meta itemprop="description" content="技术爱好者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sepk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/13/Lua-%E8%84%9A%E6%9C%AC%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C/" class="post-title-link" itemprop="url">Lua 脚本如何运行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-13 18:38:52" itemprop="dateCreated datePublished" datetime="2023-02-13T18:38:52+08:00">2023-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-25 22:04:27" itemprop="dateModified" datetime="2023-02-25T22:04:27+08:00">2023-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/" itemprop="url" rel="index"><span itemprop="name">Lua</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文结合了 Lua 源码浅析了 Lua 是如何运行并与 C 语言函数进行交互的，适合不理解 Lua 脚本运行机制、VM 运行机制的读者。</p>
<h2 id="Lua-指令码"><a href="#Lua-指令码" class="headerlink" title="Lua 指令码"></a>Lua 指令码</h2><p>Lua 虽然是脚本语言，但是在运行前需要进行代码编译；与 C/C++ 不同，Lua 脚本经过编译生成后的二进制 chunk 文件并不能够直接被物理机识别和运行，只能够在 Lua Virtual Machine ( LVM ) 中运行。Lua 编译后生成的二进制 chunk 文件是由 Lua 指令集构成的，仅能够被同版本的 Lua 虚拟机环境识别。</p>
<p><img src="/images/lua_compile_run.png" alt="/images/lua_compile_run.png"></p>
<p>在 chunk 文件中，主要负责与 LVM 进行交互的部分为 Lua 指令。在 Lua 的源码中，Lua 指令相关的代码主要集中在<code>lopcodes.h</code>文件中，该文件中也包含了对 Lua 指令的介绍：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment">  We assume that instructions are unsigned 32-bit integers.</span></span><br><span class="line"><span class="comment">  All instructions have an opcode in the first 7 bits.</span></span><br><span class="line"><span class="comment">  Instructions can have the following formats:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">        1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">iABC          C(8)     |      B(8)     |k|     A(8)      |   Op(7)     |</span></span><br><span class="line"><span class="comment">iABx                Bx(17)               |     A(8)      |   Op(7)     |</span></span><br><span class="line"><span class="comment">iAsBx              sBx (signed)(17)      |     A(8)      |   Op(7)     |</span></span><br><span class="line"><span class="comment">iAx                           Ax(25)                     |   Op(7)     |</span></span><br><span class="line"><span class="comment">isJ                           sJ(25)                     |   Op(7)     |</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  A signed argument is represented in excess K: the represented value is</span></span><br><span class="line"><span class="comment">  the written unsigned value minus K, where K is half the maximum for the</span></span><br><span class="line"><span class="comment">  corresponding unsigned argument.</span></span><br><span class="line"><span class="comment">===========================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OpMode</span> &#123;</span>iABC, iABx, iAsBx, iAx, isJ&#125;;  <span class="comment">/* basic instruction formats */</span></span><br></pre></td></tr></table></figure>

<p>一条 Lua 指令一共有 32 bit，即四个字节，可以分为 C、B、k、A、Op 五个部分。其中 A、B、C 都是 Lua 栈的标识位，用于表示当前指令需要操作的 Lua 栈；k 是一个特殊的标识位，作用在源码中已经详细说明。Op 代表了当前 Lua 指令的种类，用于指示 LVM 应当对栈采取何种操作。考虑到一些 Lua 指令并不需要三个操作数、某些情况需要的栈空间大于一个字节，Lua 指令被设计为 5 种不同的编码格式：iABC、iABx、iAsBx、iAx、isJ。后面四种格式编码的 Lua 指令会对 A、B、C、k 四个部分进行合并，以满足不同的需求。OpMode 并不会直接编码进入 chunk 文件中，一条 Lua 指令的编码格式是根据 Op 的种类来判断的。</p>
<h2 id="LVM-中指令的运行"><a href="#LVM-中指令的运行" class="headerlink" title="LVM 中指令的运行"></a>LVM 中指令的运行</h2><p>LVM 是 Lua 中最为核心的部分，它负责解释和运行 Lua 指令，并根据指令修改 Lua 栈上的值。Lua 源码中与 LVM 直接相关的代码集中在<code>lvm.h/lvm.c</code>中，其中函数<code>luaV_execute</code>负责接收 Lua 指令并执行。该函数的主要部分是一个巨型 switch-case 结构，用于区分不同的 Lua 指令，我们截取函数中的一小部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">luaV_execute</span> <span class="params">(lua_State *L, CallInfo *ci)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* main loop of interpreter */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Instruction i;  <span class="comment">/* instruction being executed */</span></span><br><span class="line">        <span class="built_in">vmfetch</span>();	<span class="comment">/* fetch an instruction and prepare its execution */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">lua_assert</span>(base == ci-&gt;func.p + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">lua_assert</span>(base &lt;= L-&gt;top.p &amp;&amp; L-&gt;top.p &lt;= L-&gt;stack_last.p);</span><br><span class="line">        <span class="comment">/* invalidate top for instructions not expecting it */</span></span><br><span class="line">        <span class="built_in">lua_assert</span>(<span class="built_in">isIT</span>(i) || (<span class="built_in">cast_void</span>(L-&gt;top.p = base), <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vmdispatch</span> (<span class="built_in">GET_OPCODE</span>(i)) &#123;    <span class="comment">// i 是指令中 Op 的简写</span></span><br><span class="line">            <span class="comment">// MOVE 指令</span></span><br><span class="line">            <span class="built_in">vmcase</span>(OP_MOVE) &#123;</span><br><span class="line">            StkId ra = <span class="built_in">RA</span>(i);</span><br><span class="line">            <span class="built_in">setobjs2s</span>(L, ra, <span class="built_in">RB</span>(i));</span><br><span class="line">            vmbreak;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>截取的代码片段有一条 MOVE 指令的执行，在判断为 OP_MOVE 指令后，<code>luaV_execute</code>直接根据该指令的编码格式 iABC （虽然只有两个操作数，但是该指令仍为 iABC 格式），获取两个操作数 A 和 B。跟随<code>RA()</code>函数的调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 A 值大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RA(i)	(base+GETARG_A(i))</span></span><br><span class="line"><span class="comment">// 获取 base 偏移量大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GETARG_A(i)	getarg(i, POS_A, SIZE_A)</span></span><br><span class="line"><span class="comment">// 获取 base 偏移量大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> getarg(i,pos,size)	(cast_int(((i)&gt;&gt;(pos)) &amp; MASK1(size,0)))</span></span><br></pre></td></tr></table></figure>

<p>上述代码中的 base 为<code>StkId</code>类型，它是<code>StackValue*</code>类型的 typedef，代表 Lua 栈值的位置：<code>RA()</code>和<code>RB()</code>函数实质上是获取两个 Lua 栈的位置 posA 和 posB，后续的<code>setobjs2s</code>函数的逻辑则是将 posB 的值拷贝给 posA。由于 posA 和 posB 都是根据偏移量计算得到的，因此通过修改 base 的值就可以模拟不同的栈环境进行指令运算。</p>
<p>通过分析不难发现，Lua 脚本的执行过程其实是完全处于 C 环境下的，各个指令的实现也完全是 C 实现的，与 C 环境之间没有任何的隔离。既然 LVM 中完全使用 C 函数来完全相关功能，那么自然也可以通过某种方法在 Lua 指令的运行过程中来使用其他的 C 函数。</p>
<h2 id="函数栈切换"><a href="#函数栈切换" class="headerlink" title="函数栈切换"></a>函数栈切换</h2><p>函数的运行是依赖于函数栈来进行环境隔离的，这一点在 Lua 中也不例外。在不指定函数的情况下，LVM 会运行在 main 函数中，并且使用该函数的栈。当调用其他函数时，LVM 将会切换函数栈，从而实现 local 值可见域的切换。</p>
<p>经过前面对指令寻址的分析，我们得出只需要修改 base 变量就能够实现栈空间的切换，这正是 Lua 源码中的实现方式。当需要调用或退出调用时，LVM 会收到指令<code>OP_CALL</code>和<code>OP_TAILCALL</code>，然后根据指令来进行栈空间的切换。首先分析 LVM 中<code>OP_CALL</code>分支的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">startfunc:</span><br><span class="line">...</span><br><span class="line">base = ci-&gt;func.p + <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">vmcase(OP_CALL) &#123;</span><br><span class="line">    StkId ra = RA(i);</span><br><span class="line">    CallInfo *newci;</span><br><span class="line">    <span class="type">int</span> b = GETARG_B(i);</span><br><span class="line">    <span class="type">int</span> nresults = GETARG_C(i) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="number">0</span>)  <span class="comment">/* fixed number of arguments? */</span></span><br><span class="line">      L-&gt;top.p = ra + b;  <span class="comment">/* top signals number of arguments */</span></span><br><span class="line">    <span class="comment">/* else previous instruction set top */</span></span><br><span class="line">    savepc(L);  <span class="comment">/* in case of errors */</span></span><br><span class="line">    <span class="keyword">if</span> ((newci = luaD_precall(L, ra, nresults)) == <span class="literal">NULL</span>)</span><br><span class="line">      updatetrap(ci);  <span class="comment">/* C call; nothing else to be done */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* Lua call: run function in this same C frame */</span></span><br><span class="line">      ci = newci;</span><br><span class="line">      <span class="keyword">goto</span> startfunc;</span><br><span class="line">    &#125;</span><br><span class="line">    vmbreak;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一分支的实现比较复杂，并且比较分散，这里解释一下主要的逻辑：当一个函数被调用时，LVM 将会更新当前运行的函数，并在 Lua 栈中选取一段合适的大小分配给该函数作为函数的运行栈。完成栈空间的分配后，LVM 会将函数的输入参数按照顺序拷贝到栈空间的起始位置，方便在函数中进行寻址操作。当完成上述这些操作后，LVM 判断需要调用的函数是否为 C 函数，若为 C 函数则运行后退出当前栈空间（C 函数在 LVM 退出逻辑不在这里）；否则将继续在当前栈空间下执行其他指令。</p>
<p>当函数完成执行后，将会使用<code>OP_TAILCALL</code>进行退出函数栈，该分支的实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vmcase(OP_TAILCALL) &#123;</span><br><span class="line">    StkId ra = RA(i);</span><br><span class="line">    <span class="type">int</span> b = GETARG_B(i);  <span class="comment">/* number of arguments + 1 (function) */</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">/* number of results when calling a C function */</span></span><br><span class="line">    <span class="type">int</span> nparams1 = GETARG_C(i);</span><br><span class="line">    <span class="comment">/* delta is virtual &#x27;func&#x27; - real &#x27;func&#x27; (vararg functions) */</span></span><br><span class="line">    <span class="type">int</span> delta = (nparams1) ? ci-&gt;u.l.nextraargs + nparams1 : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="number">0</span>)</span><br><span class="line">        L-&gt;top.p = ra + b;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">/* previous instruction set top */</span></span><br><span class="line">        b = cast_int(L-&gt;top.p - ra);</span><br><span class="line">    savepc(ci);  <span class="comment">/* several calls here can raise errors */</span></span><br><span class="line">    <span class="keyword">if</span> (TESTARG_k(i)) &#123;</span><br><span class="line">        luaF_closeupval(L, base);  <span class="comment">/* close upvalues from current call */</span></span><br><span class="line">        lua_assert(L-&gt;tbclist.p &lt; base);  <span class="comment">/* no pending tbc variables */</span></span><br><span class="line">        lua_assert(base == ci-&gt;func.p + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((n = luaD_pretailcall(L, ci, ra, b, delta)) &lt; <span class="number">0</span>)  <span class="comment">/* Lua function? */</span></span><br><span class="line">        <span class="keyword">goto</span> startfunc;  <span class="comment">/* execute the callee */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* C function? */</span></span><br><span class="line">        ci-&gt;func.p -= delta;  <span class="comment">/* restore &#x27;func&#x27; (if vararg) */</span></span><br><span class="line">        luaD_poscall(L, ci, n);  <span class="comment">/* finish caller */</span></span><br><span class="line">        updatetrap(ci);  <span class="comment">/* &#x27;luaD_poscall&#x27; can change hooks */</span></span><br><span class="line">        <span class="keyword">goto</span> ret;  <span class="comment">/* caller returns after the tail call */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>退出的逻辑更为复杂，因为在退出时还需要处理 upvalue、闭包的相关内容。这里只描述一下函数栈的变化：LVM 将会切换运行函数为上一个运行函数，并将切换前函数栈顶的元素（返回值）拷贝到切换后的栈顶，这样就复原了之前的调用状态。</p>
<h2 id="C-函数的调用"><a href="#C-函数的调用" class="headerlink" title="C 函数的调用"></a>C 函数的调用</h2><p>上一节中，已经分析得到 C 函数与 Lua 函数是以同样的入口调用的，但是调用 C 函数还需要解决一些额外的问题：C 函数不能直接使用 Lua 指令与 Lua 栈交互。这个问题是通过 Lua C API 解决的。在<code>lua.h</code>文件中，Lua 提供了一些 API 来帮助 C 函数完成与 Lua 栈的交互功能。这些函数能够完成 C 环境下的变量与 Lua 环境下的变量之间的相互转换。</p>
<p>由于 C 函数难以支持动态数量的函数参数以及返回值，Lua C API 在接口设计上并没有加入输入输出值的数量，只有一个<code>lua_state</code>类型的函数参数和一个<code>int</code>类型的函数返回值。因此 LVM 无法在调用时确定 C 函数所需要的函数栈，调用 C 函数时必须付出一些额外的代价。</p>
<h2 id="UpValue-和闭包"><a href="#UpValue-和闭包" class="headerlink" title="UpValue 和闭包"></a>UpValue 和闭包</h2><p>UpValue 是 Lua 脚本中一个比较特殊的概念，它代表函数中引用的以非函数形式传递的值。正如其命名，它代表调用函数之前就已经存在的值。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(bar)	<span class="comment">-- bar 是一个 UpValue</span></span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>在上述代码中，bar 就是一个 UpValue，同样，bar 也是一个全局变量。在 Lua 中，全局变量是一种比较特殊的 UpValue，它与普通的 UpValue 存储位置不同。我们使用 luac 工具输出上述 Lua 脚本的指令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">luac -l hello.lua</span><br><span class="line"></span><br><span class="line">main &lt;hello.lua:0,0&gt; (6 instructions at 0x600000928080)</span><br><span class="line">0+ params, 2 slots, 1 upvalue, 0 locals, 1 constant, 1 function</span><br><span class="line">	1	[1]	VARARGPREP	0</span><br><span class="line">	2	[4]	CLOSURE  	0 0	; 0x600000928100</span><br><span class="line">	3	[1]	SETTABUP 	0 0 0	; _ENV &quot;foo&quot;</span><br><span class="line">	4	[5]	GETTABUP 	0 0 0	; _ENV &quot;foo&quot;</span><br><span class="line">	5	[5]	CALL     	0 1 1	; 0 in 0 out</span><br><span class="line">	6	[5]	RETURN   	0 1 1	; 0 out</span><br><span class="line"></span><br><span class="line">function &lt;hello.lua:1,4&gt; (5 instructions at 0x600000928100)</span><br><span class="line">0 params, 2 slots, 1 upvalue, 0 locals, 2 constants, 0 functions</span><br><span class="line">	1	[2]	GETTABUP 	0 0 0	; _ENV &quot;print&quot;</span><br><span class="line">	2	[2]	GETTABUP 	1 0 1	; _ENV &quot;bar&quot;</span><br><span class="line">	3	[2]	CALL     	0 2 1	; 1 in 0 out</span><br><span class="line">	4	[3]	RETURN0  	</span><br><span class="line">	5	[4]	RETURN0  </span><br></pre></td></tr></table></figure>

<p>根据输出的指令集，脚本中的 foo 函数会被 SETTABUP 指令注册到表 _ENV 中，键名为 “foo”；bar 变量则会使用 GETTABUP 指令在 _ENV 表中查找键 “bar”。表 _ENV 是用来存储全局变量的，可以称之为上值表，表中的每一个全局变量都是一个上值，因为在 Lua 环境中的任何位置都可以通过查找上值表来代替参数方式对其引用。同样地，Lua 中的每一个函数都是一个闭包，因为它们至少可以引用全局变量这一特殊的上值。</p>
<p>在上述指令集中，函数的编译是以 CLOSURE 指令集进行的。该指令会根据语义分析阶段生成的<code>Proto</code>类型的函数定义来生成函数的调用入口，如果函数作用域是全局的，会将其放入 _ENV 表中；若函数作用域是局部的，则将其放入栈中。函数经过 CLOSURE 指令编译后，将会在内存中生成一段 chunk 文件，当需要调用该函数时，会通过 CALL 指令在内存中寻址，找到该 chunk 片段。除内存寻址外，还需要进行一些其他操作，在 LVM 的 OP_CALL 分支中，主要功能是通过<code>luaD_precall</code>来完成的，该函数有比较详细的注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Prepares the call to a function (C or Lua). For C functions, also do</span></span><br><span class="line"><span class="comment">** the call. The function to be called is at &#x27;*func&#x27;.  The arguments</span></span><br><span class="line"><span class="comment">** are on the stack, right after the function.  Returns the CallInfo</span></span><br><span class="line"><span class="comment">** to be executed, if it was a Lua function. Otherwise (a C function)</span></span><br><span class="line"><span class="comment">** returns NULL, with all the results on the stack, starting at the</span></span><br><span class="line"><span class="comment">** original function position.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CallInfo *<span class="title function_">luaD_precall</span> <span class="params">(lua_State *L, StkId func, <span class="type">int</span> nresults)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释，该函数的主要功能是将函数的参数拷贝到当前栈顶，然后在 Lua 栈与上值表中查询需要的上值并绑定。不是全局变量的 UpValue 被称为 OpenUpValue，这些值是存储在 Lua 栈中的，如果函数中所需要的上值并不是全局变量，那么该函数需要在 Lua 栈中查找所需的 OpenUpValue。</p>
<h2 id="局部与全局变量"><a href="#局部与全局变量" class="headerlink" title="局部与全局变量"></a>局部与全局变量</h2><p>Lua 中局部全量与全局变量的存储位置不同，全局变量会存储在_ENV 表中，而局部变量则是直接存储在栈上的；由于存储位置不同，对二者的寻址方式也是不同的。以下述的脚本为例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> foo = <span class="number">1</span></span><br><span class="line">bar = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(foo + bar)</span><br></pre></td></tr></table></figure>

<p>使用 luac 工具输出上述 Lua 脚本的指令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">luac -l hello.lua</span><br><span class="line"></span><br><span class="line">main &lt;hello.lua:0,0&gt; (9 instructions at 0x600003c30080)</span><br><span class="line">0+ params, 3 slots, 1 upvalue, 1 local, 3 constants, 0 functions</span><br><span class="line">	1	[1]	VARARGPREP	0</span><br><span class="line">	2	[1]	LOADI    	0 1</span><br><span class="line">	3	[2]	SETTABUP 	0 0 1k	; _ENV &quot;bar&quot; 2</span><br><span class="line">	4	[3]	GETTABUP 	1 0 2	; _ENV &quot;print&quot;</span><br><span class="line">	5	[3]	GETTABUP 	2 0 0	; _ENV &quot;bar&quot;</span><br><span class="line">	6	[3]	ADD      	2 0 2</span><br><span class="line">	7	[3]	MMBIN    	0 2 6	; __add</span><br><span class="line">	8	[3]	CALL     	1 2 1	; 1 in 0 out</span><br><span class="line">	9	[3]	RETURN   	1 1 1	; 0 out</span><br></pre></td></tr></table></figure>

<p>可以看到，foo 变量是直接使用 LOADI 指令存储在栈位置 0 上的；而 bar 则是存储在了 _ENV 表中。在取值阶段，局部变量会直接在栈中寻址，而全局变量则需要使用 GETTABUP 指令先将值拷贝到栈上才能够使用。</p>
<h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p>最后以一张关系图作为结束，该图简单描述了 C 与 Lua 之间的关系。图中的虚线代表着逻辑调用，实现代表着实际调用的逻辑链，属于相同调用的关系用同一种颜色表达。</p>
<p><img src="/images/lua_c.png" alt="/images/lua_c.png"></p>
<p>以下为图中各个部分的解释：</p>
<ul>
<li>LVM：Lua Virtual Machine，以指令方式与 Lua 脚本交互；</li>
<li>cfuncs：注册到 LVM 中的 C 函数，可以被 Lua 脚本直接调用；</li>
<li>C Main：除 LVM 和 cfuncs 外的 C 代码，不能被 Lua 脚本直接调用；</li>
<li>Lua Stack：LVM 中的栈，以 LValue 类型的形式的各种值；</li>
<li>Lua Script：Lua 脚本，经过编译后的脚本以指令形式存储在 Lua 栈中；</li>
</ul>
<p>图中的各种颜色箭头分别代表：</p>
<ul>
<li>橙色：在 C 代码中调用 Lua 脚本中的方法；</li>
<li>蓝色：Lua 脚本访问 Lua Stack；</li>
<li>红色：在注册的 C 代码中调用 Lua 脚本中的方法；</li>
<li>黑色：代表编译后的脚本存储在栈中；</li>
<li>绿色：C 函数访问 Lua Stack中的值</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="tangrc99"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">tangrc99</p>
  <div class="site-description" itemprop="description">技术爱好者</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element">
    lol welcome!
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/tangrc99" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tangrc99" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:trc99@qq.com" title="E-Mail → mailto:trc99@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/tangrc99" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tangrc99" rel="noopener" target="_blank"><i class="fa fa-link fa-fw"></i>知乎</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tangrc99</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
