<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Percolator 的一些记录</title>
      <link href="/2023/03/25/Percolator-%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/03/25/Percolator-%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>Percolator 是一种分布式事务的实现方式，它是一种较为特殊的 2PC 事务提交方式。Percolator 能够提供 Snapshot Isolation 级别的事务隔离，能够解决除 write skew 之外的并发问题。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>这里介绍一下 Percolator 需要了解的前置知识。</p><h3 id="2PC-存在的问题"><a href="#2PC-存在的问题" class="headerlink" title="2PC 存在的问题"></a>2PC 存在的问题</h3><p>2PC 是一种中心化的分布式事务提交方式，所有事务的正常提交都需要依赖于 Coordinator，如果 Coordinator 发生异常，整个系统将无法处理当前事务的状态，必须要等待 Coordinator 进行恢复，整个系统的当前状态才能够确定。因此，在 2PC 的场景下，一般要使用共识算法来保证 Coordinator 的自动恢复，这可能会带来一些性能的问题，并且在恢复阶段系统同样是不可用的。</p><h3 id="Snapshot-Isolation"><a href="#Snapshot-Isolation" class="headerlink" title="Snapshot Isolation"></a>Snapshot Isolation</h3><p>Snapshot Isolation 是一个较为特殊的数据库隔离等级，它能够解决不可重复读和幻读问题，隔离等级位于 Repeatable Read 和 Serialization 之间。Snapshot Isolation 的实现也比较简单，核心思想是使用一个时间戳来对事务的开始和结束时间进行标记，任何一个事务都只能看到在自身开始前就已经提交的事务，相当于每一个事务都只能看到数据库的一个“快照”。相比于 Repeatalbe Read 等级，它能够保证一次事务中的所有行都使用相同的版本，前者则是会读到不同的版本；因此能够解决掉幻读的问题。</p><p>Snapshot Isolation 与 Serialization 隔离之间的区别在于：Serialization 可以解决 write skew 的问题。这是数据库事务并发中的环路问题。以一个简单的例子：考虑两个事务P和Q，两个值 x 和 y，P 将 x 复制到 y 而 Q 将 y 复制到 x，这两个事务存在环路问题。在Serialization 隔离级别下，这两者必须要串行执行，即 P -&gt; Q 或 Q -&gt; P。而在 Snapshot Isolation 下，则会发生以下的序列：</p><ul><li>事务P读取x</li><li>事务Q读取y</li><li>事务P将其读取的值写入y</li><li>事务Q将其读取的值写入x</li></ul><p>这样就会导致 x 和 y 的值最终不相等。核心来说就是 Snapshot Isolation 无法解决环路事务的问题。</p><h2 id="Percolator-的实现思路"><a href="#Percolator-的实现思路" class="headerlink" title="Percolator 的实现思路"></a>Percolator 的实现思路</h2><p>Percolator 的实现主要可以分为两个部分：去中心化的 2PC 和 MVCC 实现 Snapshot Isolation。我们先讨论一下这两个设计目标需要解决的问题。</p><h3 id="去中心化的-2PC"><a href="#去中心化的-2PC" class="headerlink" title="去中心化的 2PC"></a>去中心化的 2PC</h3><p>去中心化的 2PC 意味着两个问题：</p><ol><li>事务的并发问题会从 Coordinator 转移到数据库分片上；</li><li>原有的 Coordinator 节点并不能够自动恢复。</li></ol><p>对于问题一，原因是并没有一个全局统一的事务协调器来进行 MVCC 并发控制，并不能够在事务发起阶段来判定事务是否存在并发冲突。Percolator 的解决思路与传统的数据库事务解决思路是一样的，使用 lock 来解决事务的冲突。为了确保事务能够确认当前 lock 是否是由自己获得，每一个 lock 都需要带有一个 timestamp 来标明自身的所属权。</p><p>问题二比较好理解，解决思路其实也比较清晰：要使用一定的机制来发现客户端遗留的中间事务并进行恢复。Percolator 中选择了让另一个与该事务互斥的客户端来去解决中间事务的问题，这样就能够惰性地去发现中间态事务。而判断一个事务是否处于中间态的依据是 lock 是否已经过期，如果 lock 过期则代表事务已经处于中间态，需要被处理。</p><p>顺着问题二的解决思路，其实又催生出了两个子问题：</p><ul><li>如何判断事务的状态；</li><li>慢事务应该如何处理。</li></ul><p>因为存在慢事务这种情况，所以 Percolator 中事务的提交/回滚阶段是会有竞争的。在这一前提下，Percolator 使用了 Primary Key 来确定一个事务的状态。当 Primary Key 被提交后，整个事务需要被提交，否则事务被回滚。这样 Primary Key 就相当于一个管程的作用，将不同客户端的互斥限定在了 Primary Key 上，这样并发就集中在数据库的一个分片上，就能够使用 latch 来保护临界区。在进入临界区之间，一个事务有必须要去检查当前 lock 状态是否符合自身的预期，这样能够降低临界区的竞争（检查 lock 并不是互斥的）。</p><p>综上所述，在“去中心化的 2PC”这一部分中，Percolator 需要做的就是对写事务加上一个带有过期时间以及事务标识的锁，并且在事务的提交阶段或回滚阶段优先操作 Primary Key 并使用 latch 来保护该操作。而事务中间态的检查则是当客户端发现加锁失败后，检查锁状态，并且依据 Primary Key 来处理遗留事务。</p><h3 id="Snapshot-Isolation-1"><a href="#Snapshot-Isolation-1" class="headerlink" title="Snapshot Isolation"></a>Snapshot Isolation</h3><p>写与写之间是一定冲突的，MVCC 的目的主要是控制读事务。因此，读事务必须要能够看到当前数据库当中所有写事务的视图，才能够实现 MVCC。很显然，不同的数据库分片之间天然是可串行的，因此只需要检查本地分片的写事务视图即可。</p><p>Percolator 中采取的实现是将所有的 write 操作持久化，并且使用 start timestamp 和 commit timestamp 这两个参数对其进行描述。一个读事务同样也具有一个 start timestamp，它只能够看到 commit timestamp 早于自身 start timestamp 的写事务。这就要求一个事务在最终的提交阶段必须再获取一次时间戳。</p><h3 id="Percolator-的实现"><a href="#Percolator-的实现" class="headerlink" title="Percolator 的实现"></a>Percolator 的实现</h3><p>围绕着上述的两个思路，Percolator 的基础框架已经可以被构建起来，但是这距离实际的实现还有一定的差距，因为尚有一些问题还没有被纳入考虑。</p><p>Percolator 的写流程实现可以描述如下：</p><ul><li>Prepare 阶段：客户端将所有数据写入到不同分片的缓冲区中；</li><li>Prewrite 阶段：获取 start timestamp，尝试获取所有行锁，若获取失败进行检查阶段，若获取成功则全部加锁并写入事务；</li><li>Commit 阶段：获取 commit timestamp，检查锁状态，获取 latch，先提交/回滚 Primary Key，后提交/回滚其他数据。</li></ul><p>Percolator 的读流程实现可以描述如下：</p><ul><li>Prepare 阶段：获取 start timestamp；</li><li>Read 阶段：<strong>检查锁状态，若不符合条件则等待/放弃</strong>，否则正常读取。</li></ul><p>可以看到在实际实现中还是有一些细节与之前分析得到的框架是不同的，即读操作在读取之间必须要检查一次锁状态，这主要来自于分布式系统的复杂性。为什么采取这种实现，将会在后面讨论。</p><h2 id="实现的一些细节问题"><a href="#实现的一些细节问题" class="headerlink" title="实现的一些细节问题"></a>实现的一些细节问题</h2><p>Percolator 的实际实现与之前分析的实现思路是有一些不同的细节的。这些细节主要来自于一些 corner case，接下来会讨论这些设计是要解决哪些问题。</p><h3 id="逻辑顺序与物理顺序"><a href="#逻辑顺序与物理顺序" class="headerlink" title="逻辑顺序与物理顺序"></a>逻辑顺序与物理顺序</h3><p>前面提到，Percolator 中事务的起始和结束会通过 timestamp 来记录，这一功能是通过分布式授时中心来实现的。这意味着事务时间的标识位的获取其实是要早于事务到达数据库分片的。我们假设有两个事务 A 和 B，事务 A 先从授时中心获取了时间戳 T1，事务 B 后从授时中心获取时间戳 T2，T1 &lt; T2。这并不代表着事务 A 操作是早于事务 B 操作的，事务 A 完全有可能因为网络延迟等问题晚于事务 B 到达数据库。<strong>Percolator 的实现下，逻辑顺序与物理顺序并不能够保证一致性。</strong></p><p>这种不一致性并不会影响到写-写操作，因为它们本身就是互斥的，但是对于读写操作，就会受到影响。在读事务开始读取前，必须要先检查锁的状态，而并不能直接去读一个已经提交的历史事务，正是因为这种乱序。因为在一个读事务正在读取的过程中，完全有可能有一个 commit timestamp 较小的写事务完成写入，这会造成不可重复读的风险，无法保证 Snapshot Isolation 隔离级别。</p><p>因此，在 Percolator 中一个写事务不仅会造成另一个写事务的阻塞，还会造成另一个读事务的阻塞。这种 lock 机制类似于读写锁，这是与传统单机数据库中的 MVCC 机制有所区别的——传统单机数据库中读写是不会产生互斥的。</p><h3 id="写写不能采用等待的方式"><a href="#写写不能采用等待的方式" class="headerlink" title="写写不能采用等待的方式"></a>写写不能采用等待的方式</h3><p>Percolator 中不能采用等待的方式来进行写并发控制，因为多数情况下事务都是读写混合的，一个写操作很可能依赖于一个读操作。考虑如下一种情况：事务 A 需要读取 k1 来更新 k2 和 k3，而 B 则是读取 k2 来更新 k3，如果 B 先读取了k2，但是并没有来得及获取k3的锁，而 A 立刻获得了 k2 和 k3 的锁，那么 B 需要 等待 A，而 A 写完后，B 需要更新的 k3 数据就错误了。正确的做法必须是 B 放弃当前读取到的所有数据，并且重新开启本次事务，因此不能够采取写写等待的方式来进行写操作的互斥处理。</p><h2 id="Percolator-的缺点"><a href="#Percolator-的缺点" class="headerlink" title="Percolator 的缺点"></a>Percolator 的缺点</h2><h3 id="读写互斥"><a href="#读写互斥" class="headerlink" title="读写互斥"></a>读写互斥</h3><p>经过上述的讨论，Percolator 的实现中由于获取时间戳与操作数据库这两个操作之间是可能会发生重排的，因为 MVCC 相当于退化成为了读写锁的形式，对比传统单机数据库中读写不互斥的实现，性能会比较低。不过分布式事务更重要的是维护事务的正确性，这一些性能牺牲是可以理解的。如果要引入分布式事务，本身就意味着较低的性能，所有的分布式事务性能都会较低。</p><h3 id="两次时间戳的获取"><a href="#两次时间戳的获取" class="headerlink" title="两次时间戳的获取"></a>两次时间戳的获取</h3><p>为了保证 Snapshot Isolation，Percolator 中引入了两个时间戳来描述一次事务。为了维护全局时间戳的一致性，必须要使用分布式时间服务器，这意味着在更多的网络通信，会带来更多的延时问题。但是这一问题是有优化方案的，tikv 中的解决策略是在 prewrite 阶段计算出每一个 region 中读事务的时间戳，求出这些时间戳的最大值作为本次事务的 commit timestamp。这一优化的思路是确保当前写入操作的提交时间发生在所有当前读操作之后。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> tinykv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua 与 Go GC 机制的一些记录</title>
      <link href="/2023/03/23/Lua-%E4%B8%8E-Go-GC-%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/03/23/Lua-%E4%B8%8E-Go-GC-%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>Lua 和 Go 都是具有 GC 机制的语言，两者在标记阶段都采用了三色标记法，但是由于两种语言的类型、特性等方面不同，它们的 GC 机制在实现上具有很大的差别。本文主要概括性地描述两种语言的 GC 实现思路，不讨论具体的实现。</p><h2 id="Lua-的-GC-实现"><a href="#Lua-的-GC-实现" class="headerlink" title="Lua 的 GC 实现"></a>Lua 的 GC 实现</h2><p>Lua 中的 GC 实现是比较简单的，这主要来自于 Lua 不支持用户自定义类型、不支持指针类型，这两个特性决定了 Lua 中的对象引用机制是比较简单的。同时，Lua 是一门脚本语言，但是同样具有编译机制，从 Lua 虚拟机的角度来看，每一个 TValue 都是高度抽象化的，在 GC 的过程中可以将这些分配处的 TValue 当做一个普通的 C 对象来处理。</p><p>在 Lua 的基本对象中，并不是所有的对象都会被 GC 扫描，有一些对象是分配在栈上的，一些对象的生命周期则是由 C 程序来控制的。这些对象是不需要进行 GC 的。而其他需要 GC 的对象，则具有一个统一的 struct 头<code>GCObject</code>，该 struct 的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CommonHeaderstruct GCObject *next; lu_byte tt; lu_byte marked</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Common type for all collectable objects */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GCObject</span> &#123;</span></span><br><span class="line">    CommonHeader;</span><br><span class="line">&#125; GCObject;</span><br></pre></td></tr></table></figure><p><code>GCObject</code>是一个非侵入式链表，所有可以被 GC 的对象都会被放入这个链表中，这是为了方便后续的扫描。Lua 这里的实现得益于它的运行环境是搭建在 C 语言之上的一个虚拟机，而非真实的物理机环境。Lua 栈上的每一个对象都是一个<code>GCObject</code>，而 C 语言中则只能看得到内存段。这里的实现有一些空间换时间的意味，每一个被分配出的 TValue 都加入这个头，就意味着在进行 GC 的时候就不需要再对整个 Lua 栈进行扫描了，因此在 GC 的标记起始阶段就会快很多。不过 Lua 脚本的规模并不大，一段程序需要分配出的对象并不多，所以这里的额外内存消耗的可控的。</p><p>Lua 脚本的运行起点是函数，如果脚本未定义外部函数，那么编译器会为其自动生成 main 函数。除去一些存储在 _ENV 表中的全局变量，其余对象的生命周期都是随着当前函数栈的切换而结束的。Lua 中的函数会被编译为一个<code>Proto</code>类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Function Prototypes</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> &#123;</span></span><br><span class="line">    CommonHeader;</span><br><span class="line">    ...</span><br><span class="line">    GCObject *gclist;</span><br><span class="line">&#125; Proto;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，该类型中具有一个字段<code>gclist</code>，该字段会链接所有分配出的 <code>GCObject</code>。</p><h2 id="Go-的-GC-实现"><a href="#Go-的-GC-实现" class="headerlink" title="Go 的 GC 实现"></a>Go 的 GC 实现</h2><p>有关 Go 中 GC 机制的详细探讨，可以参考<a href="https://www.jianshu.com/p/ebd8b012572e#">博客文章</a>。以下内容参考了该文章。</p><p>Go 中的 GC 实现比 Lua 要更为复杂，复杂度主要来自于：指针类型、struct 类型、物理机环境。指针类型和 struct 类型使得 GC 扫描更加复杂，并且在物理机环境下对象的视图是内存段。另外， Go 主要用来编写大型的程序，如果使用类似 Lua 的 Header，可能会耗费比较多的内存，是不现实的。</p><p>在 Go 语言中，编译器会在编译期为每一个 struct 类型生成一个<code>_type</code>类型的对象，并且记录在 runtime 中。该类型的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="type">uintptr</span></span><br><span class="line">    ptrdata    <span class="type">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">    hash       <span class="type">uint32</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      <span class="type">uint8</span></span><br><span class="line">    fieldalign <span class="type">uint8</span></span><br><span class="line">    kind       <span class="type">uint8</span></span><br><span class="line">    alg        *typeAlg</span><br><span class="line">    <span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line">    <span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line">    <span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">    gcdata    *<span class="type">byte</span></span><br><span class="line">    str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类型中的<code>gcdate</code>字段与 GC 机制密切相关，该字段主要用于保存 struct 中指针的位置。在 GC 扫描中，指针指向的对象地址与当前地址并非连续的，需要做一些额外的处理——因为在内存中，并不能直接去确认某一段存储的是否是一个指针值。在编译期，编译器将会确认一个 struct 中所包含的指针个数以及位置，以 bitmap 的形式存储在<code>gcdata</code>字段中。这种实现的思路将指针的确定在编译期完成，能够避免在程序的运行阶段大幅度地对内存段进行扫描，能够有助于提升效率。</p><p>为了进行 GC，必须为分配出的 Go 对象建立起标识位，从而判断内存段中的对象类型。在生成对象时，go 语言不仅仅会开辟出对象所需要的内存，同样也会开辟出一片内存区域来存储<code>_type</code>类型的指针。可以类比使用<code>malloc</code>函数时，会多出 20 字节的大小来分配空间的相关信息。当需要进行 GC 扫描时，会先读取出<code>_type</code>类型，将当前对象设置为已经标记，然后根据<code>gcdata</code>字段来确定是否含有指针以及下一次扫描的范围。Go 进行对象创建的函数是<code>runtime/malloc.go</code>中的<code>newobject</code>，该函数在内部仅仅调用了<code>mallocgc</code>函数。<code>mallocgc</code>函数较长，但是其中大部分内容与 GC 无关，该函数中与 GC 相关的部分是判别<code>type</code>类型是否需要 GC 扫描，如果对象需要 GC 扫描，会使用<code>heapBitsSetType</code>函数来进行一些工作。</p><p>Go 中 GC 扫描是从 goroutine 栈上开始的，当 GC 开始时，程序将会从栈的起始位置开始，按照已经预留好的类型信息逐个进行扫描和确认。对象的内存区域使用的是<code>scanblock</code>函数，这个函数会以 8 字节为步进值，对一个对象所在的内存空间进行扫描，判断内存空间中是否有指针存在，并且判断指针的有效性。若指针有效会将指针指向的对象加入到灰色标记对象中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanblock</span><span class="params">(b0, n0 <span class="type">uintptr</span>, ptrmask *<span class="type">uint8</span>, gcw *gcWork, stk *stackScanState)</span></span> &#123;</span><br><span class="line">  b := b0</span><br><span class="line">  n := n0</span><br><span class="line">  <span class="comment">// 本次扫描达到地址 n 后结束</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; n; &#123;</span><br><span class="line">    <span class="comment">// 计算当前地址偏移量上是否是指针，如果不是指针则地址 +8 </span></span><br><span class="line">    bits := <span class="type">uint32</span>(*addb(ptrmask, i/(sys.PtrSize*<span class="number">8</span>)))</span><br><span class="line">    <span class="keyword">if</span> bits == <span class="number">0</span> &#123;</span><br><span class="line">      i += sys.PtrSize * <span class="number">8</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前位置上有指针</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">8</span> &amp;&amp; i &lt; n; j++ &#123;</span><br><span class="line">      <span class="comment">// 指针类型？只有标识了指针类型的，才有可能走到下面的逻辑去；</span></span><br><span class="line">      <span class="keyword">if</span> bits&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 类型转换，获取当前内存地址存储的指针值</span></span><br><span class="line">        p := *(*<span class="type">uintptr</span>)(unsafe.Pointer(b + i))</span><br><span class="line">        <span class="keyword">if</span> p != <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> obj, span, objIndex := findObject(p, b, i); obj != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 将指针指向的对象标记为灰色</span></span><br><span class="line">            greyobject(obj, b, i, span, gcw, objIndex)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> stk != <span class="literal">nil</span> &amp;&amp; p &gt;= stk.stack.lo &amp;&amp; p &lt; stk.stack.hi &#123;</span><br><span class="line">            stk.putPtr(p)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      bits &gt;&gt;= <span class="number">1</span></span><br><span class="line">      i += sys.PtrSize</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单对比分析"><a href="#简单对比分析" class="headerlink" title="简单对比分析"></a>简单对比分析</h2><p>本质上来说，Lua 和 Go 中的 GC 思想都是类似的，核心要点就是要记录下每一个内存段上所存储的类型，然后再根据一定的方式来依次访问分配出的每一个对象。Lua 中的 tt 和 Go 中的 _type 都是为了记录类型的相关内容，但由于 Go 的复杂度更高，因此需要实现更多的功能。</p><p>由于 Lua 语言是比较简单的，对象的分配和回收都建立在 C 语言层面之上，天然具有较高的抽象性；Lua 中的 GC 实现使用了链表头的形式，这一组织形式意味着 Lua 中可以更快地寻找到需要 GC 的对象，但是这种实现方式对空间的浪费比较严重。Lua 的 GC 扫描也是较为简单的，这主要还是因为 Lua 中每一段都被包裹在一个函数中，比较容易找到对象的分配位置，只需要在函数中记录每一个分配的对象即可。整体来说，Lua 的 GC 实现比较浪费空间，但是 GC 的性能可能会较好一点，这主要来自于 Lua 独特的对象管理机制。</p><p>Go 中的 GC 机制重点在于指针位置的确认上，借助 struct 的内存对齐机制和 bitmap 存储机制可以简单高效地记录 struct 中的每一个指针。在扫描方面，虽然 Go 程序的运行是以 goroutine 为起点的，但由于 Go 程序一般规模较大，直接记录每一个可 GC 的对象需要耗费大量的内存空间，这是不太现实的。使用栈扫描虽然会在一定程度上降低起始标记阶段的性能，但是会极大地降低因为 GC 而使用的内存空间，这是一个更加合理的做法。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从unsafe.Pointer出发，浅析Go反射原理</title>
      <link href="/2023/03/01/%E4%BB%8Eunsafe.Pointer%E5%87%BA%E5%8F%91%EF%BC%8C%E6%B5%85%E6%9E%90Go%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/"/>
      <url>/2023/03/01/%E4%BB%8Eunsafe.Pointer%E5%87%BA%E5%8F%91%EF%BC%8C%E6%B5%85%E6%9E%90Go%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>反射是 Go 语言中较为难以理解的一个特性，网上讲解反射的文章有很多，但是要么讲解细致但是篇幅过长，要么讲解稍微模糊。但其实如果掌握了反射所使用到了一些技术，反射本身是很好理解的，其原理就是一个向上和向下转换的过程。本文会从反射所基于的语言特性出发，简要地分析反射这一特性是如何实现的。</p><h2 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h2><p>在讨论<code>unsafe.Pointer</code>之前，我们先来讨论一下 C 语言中的原始指针类型以及指针之间的相互转换。在 C 语言中，所有指针都是可以相互转换的，而对指针取值其实就相当于取当前指针所声明类型长度的一段内存。我们可以利用 C 语言指针的这种特性在不同长度的结构体实现变换，最为经典的例子是 linux 链表。Go 中同样也有指针，但由于 Go 是一种 GC 语言，如果保留 C 指针的这样灵活性，将会对 GC 扫描带来很大的挑战，如果一个指针向上转换了，那么很有可能会造成内存泄露的问题。</p><p>为了实现 C 语言中这种灵活转换的特性，Go 中引入了<code>unsafe.Pointer</code>这一类型。<code>unsafe.Pointer</code>是 go 中用于实现类型转换的一种中间类，我们可以将一个长度为 n 的<code>unsafe.Pointer</code>视作是一个长度为 n 的数组（即内存中的某一段数据），但是这一段数组中的数据对用户来说是不可见的。在某种意义上来说，<code>unsafe.Pointer</code>是用来告诉 GC 扫描器这段内存已经被分配，如果需要进行垃圾清理，必须释放这段内存，防止内存泄露。在 C++ 中，这一特性是通过将析构函数作为虚函数来实现的。</p><p>为了更直观地表示这一功能，以一个代码实例来演示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    header <span class="type">int</span></span><br><span class="line">    hidden unsafe.Pointer<span class="comment">// 占位，该字段的所有信息对用户隐藏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    header  <span class="type">int</span></span><br><span class="line">    toHide <span class="type">int</span><span class="comment">// 将会被隐藏的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := B&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> a A</span><br><span class="line">    a = *(*A)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是可以编译通过并运行的，通过调试器来观察 a 中的值。</p><p><img src="/images/image-20230301110108021.png" alt="image-20230301110108021"></p><p>可以看到，b 中 header 字段的值被拷贝给了 a，而 hidden 字段则成为了一个 8 字节长度（int 长度）的<code>unsafe.Pointer</code>用于占位，当 a 声明周期结束时，将会释放 header + hidden 长度的内存。要实现这一功能，必须要保证两个结构体的几个起始字段类型和顺序是相同的，并且“基类”需要以<code>unsafe.Pointer</code>字段结尾。</p><p>在 go 语言中，为了实现反射大量使用了这一特性，如果对这一特性不了解，建议先学习一下 linux 中的链表实现，这将有助于理解 go 的反射原理。</p><h2 id="eface-和-iface"><a href="#eface-和-iface" class="headerlink" title="eface 和 iface"></a>eface 和 iface</h2><p><code>eface</code>和<code>iface</code>是 go 中非空接口与空接口的底层实现，其原始定义代码出现在 runtime2.go:202：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab<span class="comment">// 存储接口与原始类的类型信息</span></span><br><span class="line">    data unsafe.Pointer <span class="comment">// 存储原始类的其他信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type<span class="comment">// 存储原始类的类型信息</span></span><br><span class="line">    data  unsafe.Pointer<span class="comment">// 存储原始类的其他信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将代码展开，来比较两个结构体之间的差异：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 原 tab 字段 start</span></span><br><span class="line">    inter *interfacetype<span class="comment">// 存储接口类型信息</span></span><br><span class="line">    _type *_type<span class="comment">// 存储原始类的类型信息</span></span><br><span class="line">    hash  <span class="type">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">    _     [<span class="number">4</span>]<span class="type">byte</span><span class="comment">// 占位，4 字节</span></span><br><span class="line">    fun   [<span class="number">1</span>]<span class="type">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter.</span></span><br><span class="line">    <span class="comment">// 原 tab 字段 end</span></span><br><span class="line"></span><br><span class="line">    data unsafe.Pointer <span class="comment">// 存储原始类的其他信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type<span class="comment">// 存储原始类的类型信息</span></span><br><span class="line">    data  unsafe.Pointer<span class="comment">// 存储原始类的其他信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这两个类型展开后的区别，<code>iface</code>在起始位置比<code>eface</code>多了一个 inter 字段，该字段用于存储接口信息，这是为了比较不同的非空接口是否相等；而<code>iface</code>和<code>eface</code>的最后一个字段都是<code>unsafe.Pointer</code>类型。暂时不考虑其中存储的数据类型，将<code>iface.hash</code>字段至<code>iface.data</code>字段也都视为字节（这些字段是为了实现与 XXtype 之间的相互转换），那么可以发现，<code>iface</code>实际上可以表示为如下的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter *interfacetype<span class="comment">// 存储接口类型信息</span></span><br><span class="line">    _type *_type<span class="comment">// 存储原始类的类型信息</span></span><br><span class="line">    data  unsafe.Pointer<span class="comment">// 存储原始类的其他信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，去掉<code>inter</code>字段后，<code>iface</code>就成为了<code>eface</code>，因此只需要在该字段上进行相关操作，就能够实现两者之间的相互转换。用一张图来表示两者之间的关系：</p><p><img src="/images/eface%20and%20iface.png" alt="eface and iface"></p><h2 id="XXtype-类型"><a href="#XXtype-类型" class="headerlink" title="XXtype 类型"></a>XXtype 类型</h2><p>在 runtime/type.go 文件中，有如下结构体的定义：<code>interfacetype</code>, <code>methodtype</code> , <code>maptype</code>, <code>arraytype</code>, <code>chantype</code>, <code>slicetype</code>, <code>functype</code>, <code>ptrtype</code>, <code>structtype</code>。这些结构体表示了在接口中，go 语言中各种类型的存储形式。值得注意的是，这些结构体全部以<code>_type</code>类型的字段作为起始，这一类型同样被接口用于记录类型。以 <code>structtype</code>为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> structtype <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Type 信息</span></span><br><span class="line">    typ     _type</span><br><span class="line">    <span class="comment">// Value 信息</span></span><br><span class="line">    pkgPath name<span class="comment">// 4 字节</span></span><br><span class="line">    fields  []structfield<span class="comment">// 24 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以同一字段作为起始位置，这种做法在 C 中比较常见，其实就是通过统一字段加类型转换的方式实现了零成本的多态，例如 linux 链表，Lua LValue 的实现，都是使用了这种思想。go 中的指针虽然带有类型检查，不能强制转换，但是同样可以使用<code>unsafe.Pointer</code>来实现类似的“向上转换”。事实上，如果将<code>structtype</code>中 Value 信息部分视作一个<code>unsafe.Pointer</code>，那么就可以将其视作是一个<code>eface</code>类型。在 go 中，空接口就是使用这种方式来存储类型信息的，因为空接口没有任何方法，只需要进行类型转换和比较，因此只需要保留 Type 信息字段即可。另外注意到在 typ 字段后的字节（不同 struct 中字段名不同）都是一个指针类型，长度是四个字节，这个长度与<code>iface</code>中的 hash 字段是相互对应的。</p><p><img src="/images/iface-xxtype.png" alt="iface-xxtype"></p><p>用一张图像来表示更为直观，<code>iface</code>结构体的第二和第三个字段与 XXtype 中的第一个和第二个字段是对齐的，两个结构体的长度也是相同的；这也意味着 XXtype 与<code>eface</code>结构体的第一个字段是对齐的，二者的结构体也是相同的。三者之间可以通过一定的方式相互转换，这是接口赋值与反射的基础原理。</p><h2 id="struct-与-interface-的转换"><a href="#struct-与-interface-的转换" class="headerlink" title="struct 与 interface 的转换"></a>struct 与 interface 的转换</h2><p>读到这里，应该可以隐约明白 Relect 是如何实现的了，但是其中还有比较关键的一步，那就是<code>structtype</code>类型究竟是如何生成并且被存储到一个空接口或非空接口中的。许多博客文章起始都没有提到这一点，或者是对这一点介绍地较为简略。</p><p>在零成本抽样的 C++ 中以虚函数表的形式来实现了多态，然而这一功能并非 Zero Cost；同样地，在 go 中一个 struct 被赋值给一个它所实现的 interface，这个过程并不是零成本的。go 编译器隐藏了一些必要的工作：在编译时，编译器会增加一些代码来完成这些额外的工作。</p><p>在如下的代码片段中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B 是一个接口</span></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"><span class="comment">// A 是一个结构体</span></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b B</span><br><span class="line">    a := A&#123;&#125;</span><br><span class="line">    <span class="comment">// 编译器会做许多额外工作</span></span><br><span class="line">    b = a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 struct A 被赋值给 interface B 时，经过 go 编译器编译后的代码，实际上会实现如下的逻辑：</p><ul><li>若生成一个非空接口，将接口所需的<code>interfacetype</code>类型信息拷贝到栈上；</li><li>在符号表中寻找 A 类型及其实现的方法，以及 A 实例 data，将这些拷贝到栈上；</li><li>调用<code>convT2E64(t *_type, elem unsafe.Pointer) (e eface)</code>生成空接口，或调用<code>convT2I(tab *itab, elem unsafe.Pointer) (i iface)</code>生成非空接口。</li></ul><p>这个过程实际上是在搜寻所需要的类型信息，并将类型信息与类型实例中各字段的值打包在一起，<strong>生成一个 XXtype 类型实例</strong>，最终使用“向上转换”生成接口实例。<strong>这个过程中发生了值的拷贝</strong>，因为利用<code>unsafe.Pointer</code>实现“向上转换”的前提是数据是连续的。无法确定 A 实例中值在内存中的地址前有足够的空间来分配生成接口所需的字段，因为需要将 A 实例的值拷贝到内存中的其他区域。可以看到，struct 到 interface 的转换其实是一个代价较大的操作。</p><h2 id="Reflect-的实现"><a href="#Reflect-的实现" class="headerlink" title="Reflect 的实现"></a>Reflect 的实现</h2><p>既然已经知道，struct 赋值给 interface 之后会发生什么，那么理解 Reflect 的实现就是一个非常简单的事情。Reflect 主要实现了取值和取类型这两类的操作。</p><h3 id="取类型"><a href="#取类型" class="headerlink" title="取类型"></a>取类型</h3><p>首先分析一下取类型的源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i any)</span></span> Type &#123;</span><br><span class="line">    <span class="comment">// 这一步是为了取空接口中完整的数据类型</span></span><br><span class="line">    eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))<span class="comment">// emptyInterface 与 eface 是 alias 的关系</span></span><br><span class="line">    <span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型转换与封装</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toType</span><span class="params">(t *rtype)</span></span> Type &#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段源码虽然很短，但是理解起来还是稍微困难的。感觉这里理解困难的点主要在于 go 是自举，这里用了一些 go 语言编译中的一些特性，如果用 C 的眼光去看这段代码，其实会更好理解。这段代码其实主要做了以下工作：</p><ul><li>在传参阶段，将 struct 转换为 any 类型，这一步发生了上一节中所讲内容；</li><li>对 any 类型 i 进行原地转换，这一步是为了取接口中存储的原始值；</li><li>将原始值中的 type 字段传递给一个接口 Type，实现封装。</li></ul><p>可以注意到，这个过程中发生了<strong>两次接口的赋值</strong>，由于接口赋值需要拷贝数据，因此在反射中只取类型也是一个代价高昂的操作。最好不要重复获取一个对象的 Type。</p><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><p>对一个对象进行反射取值操作，最终会得到一个<code>Value</code>结构体，结构体的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ *rtype</span><br><span class="line">    ptr unsafe.Pointer<span class="comment">// data</span></span><br><span class="line">    flag<span class="comment">// 操作标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>Value</code>其实就是一个<code>eface</code>加上一个<code>flag</code>标识位，该标识位用于表示可以被采取什么样的操作。事实上，它就是由<code>eface</code>拼接得到的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i any)</span></span> Value &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止 GC，这里不需要关心</span></span><br><span class="line">    escapes(i)</span><br><span class="line">    <span class="comment">// 关键过程发生在这里</span></span><br><span class="line">    <span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i any)</span></span> Value &#123;</span><br><span class="line">    <span class="comment">// 取得空接口中的原始数据</span></span><br><span class="line">    e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> don&#x27;t read e.word until we know whether it is really a pointer or not.</span></span><br><span class="line">    t := e.typ</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成标志位</span></span><br><span class="line">    f := flag(t.Kind())</span><br><span class="line">    <span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">      f |= flagIndir</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将类型，数据，标志位进行拼接</span></span><br><span class="line">    <span class="keyword">return</span> Value&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程中仍然是发生了两次拷贝，一次是 struct 传入 any 接口，一次是创建 Value 结构体。注意到，Value 这里使用的是复制后的数据，因此如果想使用反射来修改原数据，一定要传入指针。</p><h3 id="取字段"><a href="#取字段" class="headerlink" title="取字段"></a>取字段</h3><p>反射中的取字段是将<code>Value</code>类型向下转换来实现的。在<code>Value.ptr</code>字段中存储了 XXtype 除类型头外的所有信息，在获取 Value 的基础上再使用“向下转换”可以获取类型具体，我们以获取 struct 中字段个数的方法为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> NumField() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 flag 字段检验类型</span></span><br><span class="line">    v.mustBe(Struct)</span><br><span class="line">    <span class="comment">// Value 向下转换，得到 structType</span></span><br><span class="line">    tt := (*structType)(unsafe.Pointer(v.typ))</span><br><span class="line">    <span class="comment">// 返回 structType 中的信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(tt.fields)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中比较关键的过程就是使用<code>unsafe.Pointer</code>来向下转换，这里向下转换能够成为是因为<code>Value</code>，<code>eface</code>，<code>XXtype</code>的同源性，这三者本身就是相同的。</p><p>在反射中需要如果使用字段的名称来获取字段，需要经过如下代码，该代码最终是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> FieldByName(name <span class="type">string</span>) Value &#123;</span><br><span class="line">    v.mustBe(Struct)</span><br><span class="line">    <span class="keyword">if</span> f, ok := v.typ.FieldByName(name); ok &#123;</span><br><span class="line">      <span class="keyword">return</span> v.FieldByIndex(f.Index)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该函数是调用链的最后一环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *structType)</span></span> FieldByName(name <span class="type">string</span>) (f StructField, present <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// Quick check for top-level name, or struct without embedded fields.</span></span><br><span class="line">    hasEmbeds := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      <span class="comment">// 核心：遍历并且比较各个字段的名称</span></span><br><span class="line">      <span class="keyword">for</span> i := <span class="keyword">range</span> t.fields &#123;</span><br><span class="line">        tf := &amp;t.fields[i]</span><br><span class="line">        <span class="keyword">if</span> tf.name.name() == name &#123;</span><br><span class="line">          <span class="keyword">return</span> t.Field(i), <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> tf.embedded() &#123;</span><br><span class="line">          hasEmbeds = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !hasEmbeds &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.FieldByNameFunc(<span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> s == name &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>FieldByName</code>函数其实是使用遍历加比较字符串的方式来确认字段是否匹配的，当结构体的字段数量较大，并且字段名较长时，性能就会比较差。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Reflect 的实现其实并不是很难，阻碍理解的地方主要在于 struct 与 interface 的转换、unsafe.Pointer 的使用这两点。由于 interface 和 Reflect 中需要全量拷贝值，因此使用引用类型是一个非常明智的抉择。但与之相对的，大量使用引用类型会导致 GC 问题。可以考虑将类型取指针后再赋值给接口。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ristretto 源码阅读笔记</title>
      <link href="/2023/02/25/Ristretto-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/25/Ristretto-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Ristretto 是一个基于 Go 语言的、可并发访问的、可设置内存存储上限的高性能进程内缓存库。Ristretto 的含义为“超浓缩咖啡”，该命名是因为该项目的目标是与知名 JAVA 缓存库 Caffeine 竞争。</p><p>相比其他 Go 语言的进程内缓存项目，Ristretto 的设计与实现上具有以下几个显著特点：</p><ul><li>基于<strong>近似</strong> LFU 算法实现缓存逐出；</li><li>支持多种 key 与 value 类型，能够在进程内缓存较为复杂的结构体；</li><li><strong>写入门限</strong>（DoorKeeper）设计，过滤写入键值对，提高缓存命中率；</li><li>Key Cost 设计，能够更好地描述一个键值对对缓存的负载量；</li><li>利用<code>sync.Pool</code>实现类似 thread_local 缓存，减少并发竞争。</li></ul><h2 id="Ristretto-软件框架"><a href="#Ristretto-软件框架" class="headerlink" title="Ristretto 软件框架"></a>Ristretto 软件框架</h2><p>Ristretto 的实现并不复杂，从功能上可以将 Ristretto 划分为几个模块：存储模块、操作缓冲模块、缓存控制模块、缓存计数模块，几个模块分别由不同的数据结构来负责。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 存储模块</span></span><br><span class="line">    store store</span><br><span class="line">    <span class="comment">// 缓存控制模块</span></span><br><span class="line">    policy policy</span><br><span class="line">    <span class="comment">// 读写操作缓冲</span></span><br><span class="line">    getBuf *ringBuffer</span><br><span class="line">    setBuf <span class="keyword">chan</span> *Item</span><br><span class="line">    <span class="comment">// 缓存计数</span></span><br><span class="line">    Metrics *Metrics</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作缓冲模块可以分为读操作缓冲与写操作缓冲，两者会采取不同的策略来减少对缓存控制模块的访问。缓存控制模块具有 tinyLFU 和 sampledLFU，分别负责缓存的准入和逐出。缓存计数模块则是用于读取 Ristretto 的缓存命中率等日志信息。</p><h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>存储模块使用了 Go 语言中非常经典的分片哈希表设计，目前的实践已经证明这是在 Go 中综合并发性能最好的并发哈希表设计，其他的一些同类型项目也都采用了类似的设计。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存 metadata</span></span><br><span class="line"><span class="keyword">type</span> storeItem <span class="keyword">struct</span> &#123;</span><br><span class="line">    key        <span class="type">uint64</span><span class="comment">// 键</span></span><br><span class="line">    conflict   <span class="type">uint64</span><span class="comment">// 用于解决哈希冲突</span></span><br><span class="line">    value      <span class="keyword">interface</span>&#123;&#125;<span class="comment">// 值</span></span><br><span class="line">    expiration time.Time<span class="comment">// 过期时间，0 代表无</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓存大表</span></span><br><span class="line"><span class="keyword">type</span> shardedMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    shards    []*lockedMap<span class="comment">// 分片表</span></span><br><span class="line">    expiryMap *expirationMap<span class="comment">// 过期时间表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓存分片表</span></span><br><span class="line"><span class="keyword">type</span> lockedMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    data <span class="keyword">map</span>[<span class="type">uint64</span>]storeItem</span><br><span class="line">    em   *expirationMap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Ristretto 中，哈希表的分片和存储都使用了同一个哈希值，为了解决哈希冲突的问题，每一个键值对都带有使用另一个哈希算法计算出的 conflict 值，避免冲突的策略是不允许覆盖。当键值对时为数字类型时，哈希值会使用转化后的 uint64 类型；当键值对为<code>string</code>或<code>[]byte</code>类型时会使用 Go runtime 中的<code>runtime.memhash</code>函数来计算哈希值。由于使用了汇编代码来实现哈希值计算，该哈希算法相比其他常见类型的哈希算法计算速度更快。</p><h2 id="getBuf"><a href="#getBuf" class="headerlink" title="getBuf"></a>getBuf</h2><p><code>getBuf</code>用于控制“用户读取缓存”这一行为传递到 tinyLFU 的速度和方式，具象化来说就是记录下每一次读取操作需要访问的键值对，在 Ristretto 中的实现中使用了键的哈希值。相比于 LRU 和近似 LRU 算法，实现一个 LFU 或近似 LFU 算法需要记录更多的数据。而进程内缓存这一应用场景，通常都要求较高的并发读写性能，会有较多的线程访问。一个进程内共享的缓存意味着记录 LFU 相关信息的数据结构同样会被高并发地访问，因此有必要降低 LFU 数据结构的竞争来提高缓存的整体性能。</p><p>降低并发度，常用的方法就是队列和分片这两种模式，Ristretto 中选择的是队列方式。其核心思想是将 stream 转化为 batch stream，具体做法是在每一个协程栈上使用一个thread local 数据结构来缓存该协程读取的键值对，当协程本地的数据聚合到一定规模时再批量写入缓存控制模块中。由于 Go 中并不存在<code>thread_local</code>关键字，Ristretto 利用了<code>sync.Pool</code>的特性来实现了一个近似的 thread local。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ringBuffer)</span></span> Push(item <span class="type">uint64</span>) &#123;</span><br><span class="line">    <span class="comment">// 从 Pool 中取出一个对象，将数据放入后归还</span></span><br><span class="line">    stripe := b.pool.Get().(*ringStripe)</span><br><span class="line">    stripe.Push(item)</span><br><span class="line">    <span class="comment">// 对象归还时，内部信息并不会清楚</span></span><br><span class="line">    b.pool.Put(stripe)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ringStripe)</span></span> Push(item <span class="type">uint64</span>) &#123;</span><br><span class="line">    <span class="comment">// 将读取的键值对放入切片中</span></span><br><span class="line">    s.data = <span class="built_in">append</span>(s.data, item)</span><br><span class="line">    <span class="comment">// 切片满了之后，通过 channel 无阻塞地发送</span></span><br><span class="line">    <span class="comment">// 若 channel 已满，丢弃消息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s.data) &gt;= s.capa &#123;</span><br><span class="line">        <span class="keyword">if</span> s.cons.Push(s.data) &#123;</span><br><span class="line">            s.data = <span class="built_in">make</span>([]<span class="type">uint64</span>, <span class="number">0</span>, s.capa)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.data = s.data[:<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个协程需要读取键值对时，会首先从<code>sync.Pool</code>中取出一个<code>ringStripe</code>对象，这里获取对象会优先考虑从 P 的本地栈来获取。<code>ringStripe</code>对象内具有一个切片，用来暂时存储该键值对，只有当切片存满之后，才会非阻塞地通过 channel 发送给缓存控制模块。在官方博客中提到，该 channel 的长度设置得比较小，并且当 channel 满时会选择丢弃<code>ringStripe</code>中的数据（使用 select实现）。由于缓存控制模块中收到的是 batch stream，因此在获取锁的过程中能够连续处理更多信息，降低了需要获取锁的次数，因此能够大大降低此处的并发冲突。另一点则是利用了<code>sync.Pool</code>的 thread local 特性，避免在聚合的过程中需要访问一个进程内全局可见的数据结构，这也是常用的优化手段。最后，经过聚合后的读取信息将会被<code>defaultPolicy</code>接收，用于调控缓存的准入门限。</p><p>当<code>sync.Pool</code>发生 GC、channel 满时，都会导致读取缓存的信息丢失，但是这对 LFU 算法的影响是比较小的。因为在理想情况下，用户在某一时刻对缓存的读取是均匀的，丢弃少部分读取信息相当于是一个抽样。这种处理有助于限制分析用户读取信息时的 CPU 利用率，虽然牺牲了一部分 LFU 的准确性，但是能使得软件整体性能提升。</p><p>这里的设计综合了 thread local 降低并发以及批处理降低并发的思想，之所以能够采取这种设计是因为缓存控制模块是允许有延迟的，只需要保持最终一致性即可。</p><h2 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf"></a>setbuf</h2><p><code>setbuf</code>用于调节用户的写入流，不同于<code>getbuf</code>，<code>setbuf</code>的设计出发点是提升缓存的写入性能，其核心思想通过保证最终一致性来减少写入链的长度，与数据库中的 WAL 思想有些类似。</p><p>Ristretto 的设计中对 UPDATE 操作和 WRITE、DELETE 操作进行了分流，UPDATE 的写入链比其余两个更短。可以使用以下伪代码来表示三个操作的写入链。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Operation</span><span class="params">(key,value any)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isUpdateOrWrite &#123;</span><br><span class="line">        CreateObjectToInsert()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> isUpdate &#123;</span><br><span class="line">        <span class="keyword">return</span> Update()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> setBuf &lt;- op:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Update 操作由于不涉及到键的变更，因此与缓存控制模块中的<strong>写入门限</strong>无关，可以直接在缓存表中更新。而 Write 操作因为涉及到了键的变更，需要额外检查是否满足缓存的写入门限，而检查是否满足写入门限又涉及到了并发访问的问题。考虑到写入操作还涉及到键值对的过期，具有较高的时限性，这里再使用 batch 优化就不太合适了。在比较典型的进程缓存场景下，其实写入的并发量是不高的，因此这里只简单地使用了 channel，channel 内部的锁较为特殊比<code>sync.Mutex</code>速度更快。</p><p>Delete 操作的设计与 Write 操作的设计是密切相关的。Write 操作由于 channel 缓冲的存在被串行执行，这是一个慢速通道，如果某一时刻中积压的 Write 操作过多，可能会导致用户同时发起的 Delete 操作先于 Write 操作完成。即并发中的快慢路径问题。删除操作对于进程内缓存是及其重要的，如果操作发生乱序，可能会导致用户读取到过期数据，这是不能容忍的——缓存中允许少数据但不能容许多数据，否则缓存就失去了存在的意义。因此在 Ristretto 的设计中， Delete 操作同样也使用 channel 来执行。</p><p>使用 channel 还有另外一点考虑。如果进程中某一时刻突然有较多的写入，缓存的压力将会骤增，Ristretto 中使用了非阻塞的 channel 来丢弃过多的写入操作，这将会有助于缓解缓存压力。要知道，并不是每一次缓存写入都是极其重要的，但是我们可以确认如果一次缓存及其重要，那么它将会在未来一段时间内再次被写入。因此，丢弃一部分写操作有助于让缓存的写入性能变得更加平滑。</p><p>经 channel 发送出的数据会被一个后台 goroutine 处理，该 goroutine 负责检查该操作能否最终应用到缓存中，若被缓存拒绝，则操作会被丢弃并且不会通知用户。该 goroutine 的核心逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有被延迟的操作都会在这里被处理</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> i := &lt;-c.setBuf:</span><br><span class="line">      <span class="comment">// 如果没有指定 cost，根据指定策略计算 cost</span></span><br><span class="line">      <span class="keyword">if</span> i.Cost == <span class="number">0</span> &amp;&amp; c.cost != <span class="literal">nil</span> &amp;&amp; i.flag != itemDelete &#123;</span><br><span class="line">         i.Cost = c.cost(i.Value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !c.ignoreInternalCost &#123;</span><br><span class="line">         i.Cost += itemSize</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据不同的操作类型采取不同操作</span></span><br><span class="line">      <span class="keyword">switch</span> i.flag &#123;</span><br><span class="line">      <span class="keyword">case</span> itemNew:</span><br><span class="line">         <span class="comment">// 根据策略判断能否写入</span></span><br><span class="line">         victims, added := c.policy.Add(i.Key, i.Cost)</span><br><span class="line">         <span class="keyword">if</span> added &#123;</span><br><span class="line">            c.store.Set(i)</span><br><span class="line">            c.Metrics.add(keyAdd, i.Key, <span class="number">1</span>)</span><br><span class="line">            trackAdmission(i.Key)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.onReject(i)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 驱逐失效的缓存</span></span><br><span class="line">         <span class="keyword">for</span> _, victim := <span class="keyword">range</span> victims &#123;</span><br><span class="line">            victim.Conflict, victim.Value = c.store.Del(victim.Key, <span class="number">0</span>)</span><br><span class="line">            onEvict(victim)</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> itemUpdate:</span><br><span class="line">         c.policy.Update(i.Key, i.Cost)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> itemDelete:</span><br><span class="line">         c.policy.Del(i.Key) <span class="comment">// Deals with metrics updates.</span></span><br><span class="line">         _, val := c.store.Del(i.Key, i.Conflict)</span><br><span class="line">         c.onExit(val)</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">// 清理和退出逻辑</span></span><br><span class="line">   <span class="keyword">case</span> &lt;-c.cleanupTicker.C:</span><br><span class="line">      c.store.Cleanup(c.policy, onEvict)</span><br><span class="line">   <span class="keyword">case</span> &lt;-c.stop:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码片段的逻辑非常简单，不过多描述。</p><h2 id="写入与逐出策略"><a href="#写入与逐出策略" class="headerlink" title="写入与逐出策略"></a>写入与逐出策略</h2><p>当 Ristretto 并没有达到缓存使用的内存上限时，所有的键值对都可以自由地写入缓存中；当缓存使用的内存达到上限时，则会根据写入门限和逐出策略来决定哪些键值对需要保留，哪些键值对需要被逐出。<code>defaultPolicy</code>结构体中包括了使用的写入门限实现与逐出策略实现，该结构体使用互斥锁进行保护，其中<code>admit</code>字段实现了写入控制策略，<code>evict</code>字段实现了逐出策略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> defaultPolicy <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    admit    *tinyLFU    <span class="comment">// 写入策略实现</span></span><br><span class="line">    evict    *sampledLFU <span class="comment">// 逐出策略实现</span></span><br><span class="line">    itemsCh  <span class="keyword">chan</span> []<span class="type">uint64</span></span><br><span class="line">    stop     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    isClosed <span class="type">bool</span></span><br><span class="line">    metrics  *Metrics</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当进程内缓存达到上限时，一个 key 能否写入取决于自身准入值和 Cost 以及缓存中存储的其余键的准入值和 Cost。一个键的准入值描述了它在<strong>当前的采样周期内</strong>被读取操作所需求的程度高低，在不同的采样周期内，一个键的准入值是不同的。这种定义方式不仅有助于更好地描述缓存使用者在最近一段时间内的需求，也有助于降低计算准入值所需要的数据量。在这种定义方式下，准入值是与时间相关的，每次获得准入值都需要计算，因此对 LFU 算法的效率有一定要求。</p><p>为了更好地衡量一个键值对带来的影响，Ristretto 还引入了 Cost 来描述键值对的体量。一个键值对的 Cost 越大，就意味着它需要逐出缓存中更多的键来满足空间需求。而 Ristretto 在一轮比较中只会逐出一个键值对。这代表了 Cost 较大的键值对在写入时会经历更多轮的比较，这意味着更多的键值对会被抽样和比较，如果 newKey 的准入值并不够高，那么它很有可能会在多轮比较中被淘汰。这种逐出算法有利于筛选出准入值和 Cost 都较为适中的键值对，保证缓存在<strong>有限的空间内</strong>保留更多更有价值的键值对。</p><p>当缓存已写满时，Ristretto 会使用 tinyLFU 算法计算出需要新写入的 newKey 的准入值，然后在缓存已有的键值对中随机抽样一组，并选出其中准入值最小的键 minKey。如果 minKey 的准入值大于 newKey，那么会拒绝写入 newKey；否则会将 minKey 从缓存中逐出，更新缓存中的剩余空间并判断是否有足够空间写入。如果空间仍不足够，会重复上述过程，直至 newKey 被拒绝或被接受。该过程在 Ristretto 中的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数会尝试将键插入缓存中，如果判别过程中发生了键的逐出，被逐出的键会被记录在返回值evicted中</span></span><br><span class="line"><span class="comment">// 返回值accepted代表键是否允许写入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *defaultPolicy)</span></span> Add(key <span class="type">uint64</span>, cost <span class="type">int64</span>) (evicted []*Item,accepted <span class="type">bool</span>) &#123;</span><br><span class="line">    p.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.Unlock()</span><br><span class="line">    <span class="comment">// Cannot add an item bigger than entire cache.</span></span><br><span class="line">    <span class="keyword">if</span> cost &gt; p.evict.getMaxCost() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Double Check，由于写操作的延迟，本应该是更新操作</span></span><br><span class="line">    <span class="keyword">if</span> has := p.evict.updateIfHas(key, cost); has &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算剩余空间</span></span><br><span class="line">    room := p.evict.roomLeft(cost) </span><br><span class="line">    <span class="comment">// 还有剩余空间就直接插入</span></span><br><span class="line">    <span class="keyword">if</span> room &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        p.evict.add(key, cost)</span><br><span class="line">        p.metrics.add(costAdd, key, <span class="type">uint64</span>(cost))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算将要插入键的准入值</span></span><br><span class="line">    incHits := p.admit.Estimate(key)</span><br><span class="line">    sample := <span class="built_in">make</span>([]*policyPair, <span class="number">0</span>, lfuSample)</span><br><span class="line">    victims := <span class="built_in">make</span>([]*Item, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 重复逐出键直至有足够空间</span></span><br><span class="line">    <span class="keyword">for</span> ; room &lt; <span class="number">0</span>; room = p.evict.roomLeft(cost) &#123;</span><br><span class="line">        <span class="comment">// 随机采样几个键，并计算其中的最小准入值</span></span><br><span class="line">        sample = p.evict.fillSample(sample)</span><br><span class="line">        minKey, minHits, minId, minCost := <span class="type">uint64</span>(<span class="number">0</span>), <span class="type">int64</span>(math.MaxInt64), <span class="number">0</span>, <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i, pair := <span class="keyword">range</span> sample &#123;</span><br><span class="line">            <span class="keyword">if</span> hits := p.admit.Estimate(pair.key); hits &lt; minHits &#123;</span><br><span class="line">                minKey, minHits, minId, minCost = pair.key, hits, i, pair.cost</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最小准入值大于要插入键的准入值，拒绝进入缓存</span></span><br><span class="line">        <span class="keyword">if</span> incHits &lt; minHits &#123;</span><br><span class="line">            p.metrics.add(rejectSets, key, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> victims, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逐出准入值最小的键</span></span><br><span class="line">        p.evict.del(minKey)</span><br><span class="line">        sample[minId] = sample[<span class="built_in">len</span>(sample)<span class="number">-1</span>]</span><br><span class="line">        sample = sample[:<span class="built_in">len</span>(sample)<span class="number">-1</span>]</span><br><span class="line">        victims = <span class="built_in">append</span>(victims, &amp;Item&#123;</span><br><span class="line">            Key:      minKey,</span><br><span class="line">            Conflict: <span class="number">0</span>,</span><br><span class="line">            Cost:     minCost,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    p.evict.add(key, cost)</span><br><span class="line">    p.metrics.add(costAdd, key, <span class="type">uint64</span>(cost))</span><br><span class="line">    <span class="keyword">return</span> victims, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当尝试插入一个 newKey 时，可能会出现 newKey 并没有写入，但是仍有一部分键被逐出的情况。</p><h2 id="tinyLFU-准入门限"><a href="#tinyLFU-准入门限" class="headerlink" title="tinyLFU 准入门限"></a>tinyLFU 准入门限</h2><p>写入策略主要实现在<code>tinyLFU</code>结构体中，该结构体及其算法实现了 tinyLFU 算法，它包含四个字段。其中，freq 字段是一个 Count-Min sketch（cmSketch is a Count-Min sketch implementation with 4-bit counters, heavily based on Damian Gryski’s <a href="https://github.com/dgryski/go-tinylfu/blob/master/cm4.go">CM4</a>），door 字段是一个布隆过滤器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tinyLFU <span class="keyword">struct</span> &#123;</span><br><span class="line">    freq    *cmSketch<span class="comment">// Count-Min sketch</span></span><br><span class="line">    door    *z.Bloom <span class="comment">// 布隆过滤器</span></span><br><span class="line">    incrs   <span class="type">int64</span><span class="comment">// 当前记录的键值对数量</span></span><br><span class="line">    resetAt <span class="type">int64</span><span class="comment">// 重置门限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 tinyLFU 算法中，一个 Key 的准入门限是由 freq 和 door 两者共同决定的，先简要介绍一下 Count-Min sketch 算法。</p><p>Count-Min sketch 是一个类似于 HyperLogLog 的计数算法，在数据量较大时通过牺牲一定的准确度来提升运算效率。但 HyperLogLog 算法目的是估算数据量的多少，而 Count-Min sketch 则为了估算一个数出现的频率。该算法内部包含了 n 个哈希算法和一个 n*m 大小的数组，当一个 key 需要被记录时，会使用不同的哈希算法计算出哈希值并对 m 取模后存入到数组对应位置。当需要统计时，使用同样的方法得到一个 n 大小的数组，被统计数的出现频率被视为该数组中的最小值。</p><p>Count-Min sketch 算法的准确率与数据规模是密切相关的，该算法需要设置一个阈值以初始化，当数据规模超出阈值后，估算频率的准确度会有较大的偏离。在 tinyLFU 中会只保留一定规模的键值对，当键值对超出规模时会被重置。这种设计不仅保证了 Count-Min sketch 算法的准确度维持在一个相对合理的范围内，还能保证只统计过去一段时间内的读取操作，实践证明不仅取得了较好的缓存命中率，还有助于限制需要记录的数据规模。</p><p>当需要评估一个键的准入值时，tinyLFU 主要考虑了两个维度的问题：该键被需要的频率、是否有相似的键值被需要。该键被需要的频率，即该键被读取的次数是需要考虑的主要因素，tinyLFU 中是使用Count-Min sketch 算法实现的。而另外一个因素，是否有相似的键值被需要，则体现了该键在未来一段时间内被读取的可能性。缓存中的键值对在大多数时间内都是具有关联性的，因为这些键很有可能是通过某些算法来实现的。一个键在过去一段时间内曾被读取就意味着一个与之相似的键很有可能在未来的一段时间内被读取，但这种因果关系并不是强因果关系，因此这一因素被作为次要因素来考虑。tinyLFU 中使用布隆过滤器来描述键的相似性问题，在布隆过滤器中相似的键更有可能被写入到相同的哈希槽中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *tinyLFU)</span></span> Estimate(key <span class="type">uint64</span>) <span class="type">int64</span> &#123;</span><br><span class="line">   <span class="comment">// 评估键在过去被读取的频率</span></span><br><span class="line">   hits := p.freq.Estimate(key)</span><br><span class="line">   <span class="comment">// 评估是否有相似键被读取</span></span><br><span class="line">   <span class="keyword">if</span> p.door.Has(key) &#123;</span><br><span class="line">      hits++</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> hits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一方面，布隆过滤器还会限制什么样的键能够进入到 Count-Min sketch。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *tinyLFU)</span></span> Increment(key <span class="type">uint64</span>) &#123;</span><br><span class="line">   <span class="comment">// 过滤布隆过滤器中不存在的key</span></span><br><span class="line">   <span class="keyword">if</span> added := p.door.AddIfNotHas(key); !added &#123;</span><br><span class="line">      p.freq.Increment(key)</span><br><span class="line">   &#125;</span><br><span class="line">   p.incrs++</span><br><span class="line">   <span class="comment">// 超过上限，重置</span></span><br><span class="line">   <span class="keyword">if</span> p.incrs &gt;= p.resetAt &#123;</span><br><span class="line">      p.reset()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据官方的说法，这是为了防止长尾键污染缓存。</p><blockquote><p>Before we place a new key in TinyLFU, <a href="https://github.com/dgraph-io/ristretto">Ristretto</a> uses a bloom filter to first check if the key has been seen before. Only if the key is already present in the bloom filter, is it inserted into the TinyLFU. This is to avoid <em>polluting</em> TinyLFU with a long tail of keys that are not seen more than once.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Ristretto 与其他缓存最大的不同之处是其使用了 LFU 算法。在高并发情景下，为了降低 LFU 计数器这一全局资源所带来的竞争，Ristretto 采用了<strong>本地缓存</strong>、<strong>批处理</strong>、<strong>采样</strong>的思想来改变访问 LFU 计数器的方式，取得了非常好的效果。在工程实现上，最值得学习的是采用<code>sync.Pool</code>搭配 ring_buffer 的模式，实现了一个近似的 thread local 缓存。在允许一定数据丢失的场景下，如采样，使用这种思路可以巧妙地将流处理转换为批处理模式，大大提升系统的吞吐量。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua 脚本如何运行</title>
      <link href="/2023/02/13/Lua-%E8%84%9A%E6%9C%AC%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C/"/>
      <url>/2023/02/13/Lua-%E8%84%9A%E6%9C%AC%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>本文结合了 Lua 源码浅析了 Lua 是如何运行并与 C 语言函数进行交互的，适合不理解 Lua 脚本运行机制、VM 运行机制的读者。</p><h2 id="Lua-指令码"><a href="#Lua-指令码" class="headerlink" title="Lua 指令码"></a>Lua 指令码</h2><p>Lua 虽然是脚本语言，但是在运行前需要进行代码编译；与 C/C++ 不同，Lua 脚本经过编译生成后的二进制 chunk 文件并不能够直接被物理机识别和运行，只能够在 Lua Virtual Machine ( LVM ) 中运行。Lua 编译后生成的二进制 chunk 文件是由 Lua 指令集构成的，仅能够被同版本的 Lua 虚拟机环境识别。</p><p><img src="/images/lua_compile_run.png" alt="/images/lua_compile_run.png"></p><p>在 chunk 文件中，主要负责与 LVM 进行交互的部分为 Lua 指令。在 Lua 的源码中，Lua 指令相关的代码主要集中在<code>lopcodes.h</code>文件中，该文件中也包含了对 Lua 指令的介绍：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment">  We assume that instructions are unsigned 32-bit integers.</span></span><br><span class="line"><span class="comment">  All instructions have an opcode in the first 7 bits.</span></span><br><span class="line"><span class="comment">  Instructions can have the following formats:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">        1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">iABC          C(8)     |      B(8)     |k|     A(8)      |   Op(7)     |</span></span><br><span class="line"><span class="comment">iABx                Bx(17)               |     A(8)      |   Op(7)     |</span></span><br><span class="line"><span class="comment">iAsBx              sBx (signed)(17)      |     A(8)      |   Op(7)     |</span></span><br><span class="line"><span class="comment">iAx                           Ax(25)                     |   Op(7)     |</span></span><br><span class="line"><span class="comment">isJ                           sJ(25)                     |   Op(7)     |</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  A signed argument is represented in excess K: the represented value is</span></span><br><span class="line"><span class="comment">  the written unsigned value minus K, where K is half the maximum for the</span></span><br><span class="line"><span class="comment">  corresponding unsigned argument.</span></span><br><span class="line"><span class="comment">===========================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OpMode</span> &#123;</span>iABC, iABx, iAsBx, iAx, isJ&#125;;  <span class="comment">/* basic instruction formats */</span></span><br></pre></td></tr></table></figure><p>一条 Lua 指令一共有 32 bit，即四个字节，可以分为 C、B、k、A、Op 五个部分。其中 A、B、C 都是 Lua 栈的标识位，用于表示当前指令需要操作的 Lua 栈；k 是一个特殊的标识位，作用在源码中已经详细说明。Op 代表了当前 Lua 指令的种类，用于指示 LVM 应当对栈采取何种操作。考虑到一些 Lua 指令并不需要三个操作数、某些情况需要的栈空间大于一个字节，Lua 指令被设计为 5 种不同的编码格式：iABC、iABx、iAsBx、iAx、isJ。后面四种格式编码的 Lua 指令会对 A、B、C、k 四个部分进行合并，以满足不同的需求。OpMode 并不会直接编码进入 chunk 文件中，一条 Lua 指令的编码格式是根据 Op 的种类来判断的。</p><h2 id="LVM-中指令的运行"><a href="#LVM-中指令的运行" class="headerlink" title="LVM 中指令的运行"></a>LVM 中指令的运行</h2><p>LVM 是 Lua 中最为核心的部分，它负责解释和运行 Lua 指令，并根据指令修改 Lua 栈上的值。Lua 源码中与 LVM 直接相关的代码集中在<code>lvm.h/lvm.c</code>中，其中函数<code>luaV_execute</code>负责接收 Lua 指令并执行。该函数的主要部分是一个巨型 switch-case 结构，用于区分不同的 Lua 指令，我们截取函数中的一小部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">luaV_execute</span> <span class="params">(lua_State *L, CallInfo *ci)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* main loop of interpreter */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Instruction i;  <span class="comment">/* instruction being executed */</span></span><br><span class="line">        <span class="built_in">vmfetch</span>();<span class="comment">/* fetch an instruction and prepare its execution */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">lua_assert</span>(base == ci-&gt;func.p + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">lua_assert</span>(base &lt;= L-&gt;top.p &amp;&amp; L-&gt;top.p &lt;= L-&gt;stack_last.p);</span><br><span class="line">        <span class="comment">/* invalidate top for instructions not expecting it */</span></span><br><span class="line">        <span class="built_in">lua_assert</span>(<span class="built_in">isIT</span>(i) || (<span class="built_in">cast_void</span>(L-&gt;top.p = base), <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vmdispatch</span> (<span class="built_in">GET_OPCODE</span>(i)) &#123;    <span class="comment">// i 是指令中 Op 的简写</span></span><br><span class="line">            <span class="comment">// MOVE 指令</span></span><br><span class="line">            <span class="built_in">vmcase</span>(OP_MOVE) &#123;</span><br><span class="line">            StkId ra = <span class="built_in">RA</span>(i);</span><br><span class="line">            <span class="built_in">setobjs2s</span>(L, ra, <span class="built_in">RB</span>(i));</span><br><span class="line">            vmbreak;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>截取的代码片段有一条 MOVE 指令的执行，在判断为 OP_MOVE 指令后，<code>luaV_execute</code>直接根据该指令的编码格式 iABC （虽然只有两个操作数，但是该指令仍为 iABC 格式），获取两个操作数 A 和 B。跟随<code>RA()</code>函数的调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 A 值大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RA(i)(base+GETARG_A(i))</span></span><br><span class="line"><span class="comment">// 获取 base 偏移量大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GETARG_A(i)getarg(i, POS_A, SIZE_A)</span></span><br><span class="line"><span class="comment">// 获取 base 偏移量大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> getarg(i,pos,size)(cast_int(((i)&gt;&gt;(pos)) &amp; MASK1(size,0)))</span></span><br></pre></td></tr></table></figure><p>上述代码中的 base 为<code>StkId</code>类型，它是<code>StackValue*</code>类型的 typedef，代表 Lua 栈值的位置：<code>RA()</code>和<code>RB()</code>函数实质上是获取两个 Lua 栈的位置 posA 和 posB，后续的<code>setobjs2s</code>函数的逻辑则是将 posB 的值拷贝给 posA。由于 posA 和 posB 都是根据偏移量计算得到的，因此通过修改 base 的值就可以模拟不同的栈环境进行指令运算。</p><p>通过分析不难发现，Lua 脚本的执行过程其实是完全处于 C 环境下的，各个指令的实现也完全是 C 实现的，与 C 环境之间没有任何的隔离。既然 LVM 中完全使用 C 函数来完全相关功能，那么自然也可以通过某种方法在 Lua 指令的运行过程中来使用其他的 C 函数。</p><h2 id="函数栈切换"><a href="#函数栈切换" class="headerlink" title="函数栈切换"></a>函数栈切换</h2><p>函数的运行是依赖于函数栈来进行环境隔离的，这一点在 Lua 中也不例外。在不指定函数的情况下，LVM 会运行在 main 函数中，并且使用该函数的栈。当调用其他函数时，LVM 将会切换函数栈，从而实现 local 值可见域的切换。</p><p>经过前面对指令寻址的分析，我们得出只需要修改 base 变量就能够实现栈空间的切换，这正是 Lua 源码中的实现方式。当需要调用或退出调用时，LVM 会收到指令<code>OP_CALL</code>和<code>OP_TAILCALL</code>，然后根据指令来进行栈空间的切换。首先分析 LVM 中<code>OP_CALL</code>分支的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">startfunc:</span><br><span class="line">...</span><br><span class="line">base = ci-&gt;func.p + <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">vmcase(OP_CALL) &#123;</span><br><span class="line">    StkId ra = RA(i);</span><br><span class="line">    CallInfo *newci;</span><br><span class="line">    <span class="type">int</span> b = GETARG_B(i);</span><br><span class="line">    <span class="type">int</span> nresults = GETARG_C(i) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="number">0</span>)  <span class="comment">/* fixed number of arguments? */</span></span><br><span class="line">      L-&gt;top.p = ra + b;  <span class="comment">/* top signals number of arguments */</span></span><br><span class="line">    <span class="comment">/* else previous instruction set top */</span></span><br><span class="line">    savepc(L);  <span class="comment">/* in case of errors */</span></span><br><span class="line">    <span class="keyword">if</span> ((newci = luaD_precall(L, ra, nresults)) == <span class="literal">NULL</span>)</span><br><span class="line">      updatetrap(ci);  <span class="comment">/* C call; nothing else to be done */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* Lua call: run function in this same C frame */</span></span><br><span class="line">      ci = newci;</span><br><span class="line">      <span class="keyword">goto</span> startfunc;</span><br><span class="line">    &#125;</span><br><span class="line">    vmbreak;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一分支的实现比较复杂，并且比较分散，这里解释一下主要的逻辑：当一个函数被调用时，LVM 将会更新当前运行的函数，并在 Lua 栈中选取一段合适的大小分配给该函数作为函数的运行栈。完成栈空间的分配后，LVM 会将函数的输入参数按照顺序拷贝到栈空间的起始位置，方便在函数中进行寻址操作。当完成上述这些操作后，LVM 判断需要调用的函数是否为 C 函数，若为 C 函数则运行后退出当前栈空间（C 函数在 LVM 退出逻辑不在这里）；否则将继续在当前栈空间下执行其他指令。</p><p>当函数完成执行后，将会使用<code>OP_TAILCALL</code>进行退出函数栈，该分支的实现为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vmcase(OP_TAILCALL) &#123;</span><br><span class="line">    StkId ra = RA(i);</span><br><span class="line">    <span class="type">int</span> b = GETARG_B(i);  <span class="comment">/* number of arguments + 1 (function) */</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">/* number of results when calling a C function */</span></span><br><span class="line">    <span class="type">int</span> nparams1 = GETARG_C(i);</span><br><span class="line">    <span class="comment">/* delta is virtual &#x27;func&#x27; - real &#x27;func&#x27; (vararg functions) */</span></span><br><span class="line">    <span class="type">int</span> delta = (nparams1) ? ci-&gt;u.l.nextraargs + nparams1 : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="number">0</span>)</span><br><span class="line">        L-&gt;top.p = ra + b;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">/* previous instruction set top */</span></span><br><span class="line">        b = cast_int(L-&gt;top.p - ra);</span><br><span class="line">    savepc(ci);  <span class="comment">/* several calls here can raise errors */</span></span><br><span class="line">    <span class="keyword">if</span> (TESTARG_k(i)) &#123;</span><br><span class="line">        luaF_closeupval(L, base);  <span class="comment">/* close upvalues from current call */</span></span><br><span class="line">        lua_assert(L-&gt;tbclist.p &lt; base);  <span class="comment">/* no pending tbc variables */</span></span><br><span class="line">        lua_assert(base == ci-&gt;func.p + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((n = luaD_pretailcall(L, ci, ra, b, delta)) &lt; <span class="number">0</span>)  <span class="comment">/* Lua function? */</span></span><br><span class="line">        <span class="keyword">goto</span> startfunc;  <span class="comment">/* execute the callee */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* C function? */</span></span><br><span class="line">        ci-&gt;func.p -= delta;  <span class="comment">/* restore &#x27;func&#x27; (if vararg) */</span></span><br><span class="line">        luaD_poscall(L, ci, n);  <span class="comment">/* finish caller */</span></span><br><span class="line">        updatetrap(ci);  <span class="comment">/* &#x27;luaD_poscall&#x27; can change hooks */</span></span><br><span class="line">        <span class="keyword">goto</span> ret;  <span class="comment">/* caller returns after the tail call */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>退出的逻辑更为复杂，因为在退出时还需要处理 upvalue、闭包的相关内容。这里只描述一下函数栈的变化：LVM 将会切换运行函数为上一个运行函数，并将切换前函数栈顶的元素（返回值）拷贝到切换后的栈顶，这样就复原了之前的调用状态。</p><h2 id="C-函数的调用"><a href="#C-函数的调用" class="headerlink" title="C 函数的调用"></a>C 函数的调用</h2><p>上一节中，已经分析得到 C 函数与 Lua 函数是以同样的入口调用的，但是调用 C 函数还需要解决一些额外的问题：C 函数不能直接使用 Lua 指令与 Lua 栈交互。这个问题是通过 Lua C API 解决的。在<code>lua.h</code>文件中，Lua 提供了一些 API 来帮助 C 函数完成与 Lua 栈的交互功能。这些函数能够完成 C 环境下的变量与 Lua 环境下的变量之间的相互转换。</p><p>由于 C 函数难以支持动态数量的函数参数以及返回值，Lua C API 在接口设计上并没有加入输入输出值的数量，只有一个<code>lua_state</code>类型的函数参数和一个<code>int</code>类型的函数返回值。因此 LVM 无法在调用时确定 C 函数所需要的函数栈，调用 C 函数时必须付出一些额外的代价。</p><h2 id="UpValue-和闭包"><a href="#UpValue-和闭包" class="headerlink" title="UpValue 和闭包"></a>UpValue 和闭包</h2><p>UpValue 是 Lua 脚本中一个比较特殊的概念，它代表函数中引用的以非函数形式传递的值。正如其命名，它代表调用函数之前就已经存在的值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(bar)<span class="comment">-- bar 是一个 UpValue</span></span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>在上述代码中，bar 就是一个 UpValue，同样，bar 也是一个全局变量。在 Lua 中，全局变量是一种比较特殊的 UpValue，它与普通的 UpValue 存储位置不同。我们使用 luac 工具输出上述 Lua 脚本的指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">luac -l hello.lua</span><br><span class="line"></span><br><span class="line">main &lt;hello.lua:0,0&gt; (6 instructions at 0x600000928080)</span><br><span class="line">0+ params, 2 slots, 1 upvalue, 0 locals, 1 constant, 1 function</span><br><span class="line">1[1]VARARGPREP0</span><br><span class="line">2[4]CLOSURE  0 0; 0x600000928100</span><br><span class="line">3[1]SETTABUP 0 0 0; _ENV &quot;foo&quot;</span><br><span class="line">4[5]GETTABUP 0 0 0; _ENV &quot;foo&quot;</span><br><span class="line">5[5]CALL     0 1 1; 0 in 0 out</span><br><span class="line">6[5]RETURN   0 1 1; 0 out</span><br><span class="line"></span><br><span class="line">function &lt;hello.lua:1,4&gt; (5 instructions at 0x600000928100)</span><br><span class="line">0 params, 2 slots, 1 upvalue, 0 locals, 2 constants, 0 functions</span><br><span class="line">1[2]GETTABUP 0 0 0; _ENV &quot;print&quot;</span><br><span class="line">2[2]GETTABUP 1 0 1; _ENV &quot;bar&quot;</span><br><span class="line">3[2]CALL     0 2 1; 1 in 0 out</span><br><span class="line">4[3]RETURN0  </span><br><span class="line">5[4]RETURN0  </span><br></pre></td></tr></table></figure><p>根据输出的指令集，脚本中的 foo 函数会被 SETTABUP 指令注册到表 _ENV 中，键名为 “foo”；bar 变量则会使用 GETTABUP 指令在 _ENV 表中查找键 “bar”。表 _ENV 是用来存储全局变量的，可以称之为上值表，表中的每一个全局变量都是一个上值，因为在 Lua 环境中的任何位置都可以通过查找上值表来代替参数方式对其引用。同样地，Lua 中的每一个函数都是一个闭包，因为它们至少可以引用全局变量这一特殊的上值。</p><p>在上述指令集中，函数的编译是以 CLOSURE 指令集进行的。该指令会根据语义分析阶段生成的<code>Proto</code>类型的函数定义来生成函数的调用入口，如果函数作用域是全局的，会将其放入 _ENV 表中；若函数作用域是局部的，则将其放入栈中。函数经过 CLOSURE 指令编译后，将会在内存中生成一段 chunk 文件，当需要调用该函数时，会通过 CALL 指令在内存中寻址，找到该 chunk 片段。除内存寻址外，还需要进行一些其他操作，在 LVM 的 OP_CALL 分支中，主要功能是通过<code>luaD_precall</code>来完成的，该函数有比较详细的注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Prepares the call to a function (C or Lua). For C functions, also do</span></span><br><span class="line"><span class="comment">** the call. The function to be called is at &#x27;*func&#x27;.  The arguments</span></span><br><span class="line"><span class="comment">** are on the stack, right after the function.  Returns the CallInfo</span></span><br><span class="line"><span class="comment">** to be executed, if it was a Lua function. Otherwise (a C function)</span></span><br><span class="line"><span class="comment">** returns NULL, with all the results on the stack, starting at the</span></span><br><span class="line"><span class="comment">** original function position.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CallInfo *<span class="title function_">luaD_precall</span> <span class="params">(lua_State *L, StkId func, <span class="type">int</span> nresults)</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释，该函数的主要功能是将函数的参数拷贝到当前栈顶，然后在 Lua 栈与上值表中查询需要的上值并绑定。不是全局变量的 UpValue 被称为 OpenUpValue，这些值是存储在 Lua 栈中的，如果函数中所需要的上值并不是全局变量，那么该函数需要在 Lua 栈中查找所需的 OpenUpValue。</p><h2 id="局部与全局变量"><a href="#局部与全局变量" class="headerlink" title="局部与全局变量"></a>局部与全局变量</h2><p>Lua 中局部全量与全局变量的存储位置不同，全局变量会存储在_ENV 表中，而局部变量则是直接存储在栈上的；由于存储位置不同，对二者的寻址方式也是不同的。以下述的脚本为例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> foo = <span class="number">1</span></span><br><span class="line">bar = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(foo + bar)</span><br></pre></td></tr></table></figure><p>使用 luac 工具输出上述 Lua 脚本的指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">luac -l hello.lua</span><br><span class="line"></span><br><span class="line">main &lt;hello.lua:0,0&gt; (9 instructions at 0x600003c30080)</span><br><span class="line">0+ params, 3 slots, 1 upvalue, 1 local, 3 constants, 0 functions</span><br><span class="line">1[1]VARARGPREP0</span><br><span class="line">2[1]LOADI    0 1</span><br><span class="line">3[2]SETTABUP 0 0 1k; _ENV &quot;bar&quot; 2</span><br><span class="line">4[3]GETTABUP 1 0 2; _ENV &quot;print&quot;</span><br><span class="line">5[3]GETTABUP 2 0 0; _ENV &quot;bar&quot;</span><br><span class="line">6[3]ADD      2 0 2</span><br><span class="line">7[3]MMBIN    0 2 6; __add</span><br><span class="line">8[3]CALL     1 2 1; 1 in 0 out</span><br><span class="line">9[3]RETURN   1 1 1; 0 out</span><br></pre></td></tr></table></figure><p>可以看到，foo 变量是直接使用 LOADI 指令存储在栈位置 0 上的；而 bar 则是存储在了 _ENV 表中。在取值阶段，局部变量会直接在栈中寻址，而全局变量则需要使用 GETTABUP 指令先将值拷贝到栈上才能够使用。</p><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p>最后以一张关系图作为结束，该图简单描述了 C 与 Lua 之间的关系。图中的虚线代表着逻辑调用，实现代表着实际调用的逻辑链，属于相同调用的关系用同一种颜色表达。</p><p><img src="/images/lua_c.png" alt="/images/lua_c.png"></p><p>以下为图中各个部分的解释：</p><ul><li>LVM：Lua Virtual Machine，以指令方式与 Lua 脚本交互；</li><li>cfuncs：注册到 LVM 中的 C 函数，可以被 Lua 脚本直接调用；</li><li>C Main：除 LVM 和 cfuncs 外的 C 代码，不能被 Lua 脚本直接调用；</li><li>Lua Stack：LVM 中的栈，以 LValue 类型的形式的各种值；</li><li>Lua Script：Lua 脚本，经过编译后的脚本以指令形式存储在 Lua 栈中；</li></ul><p>图中的各种颜色箭头分别代表：</p><ul><li>橙色：在 C 代码中调用 Lua 脚本中的方法；</li><li>蓝色：Lua 脚本访问 Lua Stack；</li><li>红色：在注册的 C 代码中调用 Lua 脚本中的方法；</li><li>黑色：代表编译后的脚本存储在栈中；</li><li>绿色：C 函数访问 Lua Stack中的值</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis中lua模块的设计与实现</title>
      <link href="/2023/02/10/redis%E4%B8%ADlua%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/02/10/redis%E4%B8%ADlua%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>在 Redis 的设计中，用户可以使用 Lua 脚本来完成拓展功能，实现一些 RESP 协议中不提供的操作，这些复杂功能往往需要操作多个键值对，并且操作具有上下文关系，如限流算法、简单事务等。</p><p>在 Redis 官方手册中的介绍中，使用 Lua 脚本具有如下优点：</p><ul><li>逻辑运行在服务端处而非客户端处，减少了 C/S 之间传输的网络延迟；</li><li>Lua 脚本独占服务器运行权，能够保证脚本执行的原子性；</li><li>能够组合使用 Redis 支持的现有操作以完成更加复杂的逻辑。</li></ul><p>在《Redis 设计与实现》一书中，作者详细地讲述了 Lua 脚本虚拟环境的搭建、Lua 脚本的运行流程；但是书中较少展示Redis 的源码，如果对 Lua 了解较少，可能会对该部分的具体实现过程较为困惑。本文将以 Redis 6.2.6 版本为例，介绍 Redis 中 Lua 脚本部分的实现。</p><h2 id="Lua-脚本简介"><a href="#Lua-脚本简介" class="headerlink" title="Lua 脚本简介"></a>Lua 脚本简介</h2><p>Lua 是一种脚本语言，它使用标准 C 语言编写，具有很强的嵌入能力，能够作为“胶水语言”来为应用程序提高扩展性。除了 Redis 以外，Nginx 也同样适用了 Lua 来支持拓展功能。</p><p>Lua 语言的一个重要特性是它支持 C/Lua 函数之间的相互调用，这种相互调用是依赖于 Lua 虚拟机的栈特性实现的。下面以一个 demo 来简述 Lua 虚拟机中的栈特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_Replace</span><span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read From Lua: %s\n&quot;</span>,luaL_checkstring(L,<span class="number">1</span>)); <span class="comment">// 从栈顶读取数据</span></span><br><span class="line">    lua_pushstring(L, <span class="string">&quot;replaced&quot;</span>);  <span class="comment">// 返回给lua的值压栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// 返回 1 代表运行成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_Origin</span><span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_Fail</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">    lua_pushstring(L,<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    lua_State *L = luaL_newstate();  <span class="comment">// 创建lua状态机</span></span><br><span class="line">    luaL_openlibs(L);   <span class="comment">// 打开Lua状态机中所有Lua标准库</span></span><br><span class="line">    lua_register(L, <span class="string">&quot;replace&quot;</span>, l_Replace);<span class="comment">//注册C函数到lua</span></span><br><span class="line">    lua_register(L, <span class="string">&quot;origin&quot;</span>, l_Origin);<span class="comment">//注册C函数到lua</span></span><br><span class="line">    lua_register(L, <span class="string">&quot;fail&quot;</span>, l_Fail);<span class="comment">//注册C函数到lua</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *testfunc = <span class="string">&quot;print(&#x27;lua output:&#x27;,replace(&#x27;original&#x27;))&quot;</span></span><br><span class="line">                           <span class="string">&quot;print(&#x27;lua output:&#x27;,origin(&#x27;original&#x27;))&quot;</span></span><br><span class="line">                           <span class="string">&quot;print(&#x27;lua output:&#x27;,fail(&#x27;original&#x27;))&quot;</span>; <span class="comment">//lua中调用c函数</span></span><br><span class="line">    <span class="keyword">if</span> (luaL_dostring(L, testfunc))    <span class="comment">// 执行Lua命令。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to invoke.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lua_close(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段函数的输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Read From Lua: original</span><br><span class="line">lua output:replaced</span><br><span class="line">lua output:original</span><br><span class="line">lua output:</span><br></pre></td></tr></table></figure><p>当 Lua 中需要调用 C/C++ 函数时，需要使用 Lua 标准库中的<code>lua_register</code>函数将相应的函数注册到 Lua 虚拟机中。与传统的函数调用方式不同，Lua 中并不是依赖于 C/C++ 函数的返回值来进行值传递，而是在调用过程中创建一个栈，需要 C/C++ 函数将需要返回的值压入栈中，当该函数运行结束后，再将栈中的值作为函数的返回值；而 C/C++ 的返回值则用于表示是否执行成功，如果 return 0，则代表值 nil。</p><p><img src="/images/lua_stack.png" alt="lua_stack"></p><p>这种设计解决了 Lua 这种动态类型语言与 C/C++ 这种强类型语言之间值传递的问题，并且屏蔽了彼此之间的内存差异。但是这种方式使得 C/C++ 代码中需要嵌套大量操作 Lua 虚拟机的代码，具有一定的编程难度，比较好的一种做法是设置专门的模块作为中间层与 Lua 虚拟机进行交互，避免其他模块代码直接与 Lua 虚拟机进行耦合。这一思想在 Redis 源码中也有所体现。</p><h2 id="Redis-中-Lua-虚拟环境的构建"><a href="#Redis-中-Lua-虚拟环境的构建" class="headerlink" title="Redis 中 Lua 虚拟环境的构建"></a>Redis 中 Lua 虚拟环境的构建</h2><h3 id="虚拟环境的构建流程"><a href="#虚拟环境的构建流程" class="headerlink" title="虚拟环境的构建流程"></a>虚拟环境的构建流程</h3><p>Redis 中 Lua 虚拟机环境的创建是在<code>scriptingInit</code>函数中完成的，函数比较简单，将代码简化后，可以分为以下几个阶段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scriptingInit</span><span class="params">(<span class="type">int</span> setup)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step1: 使用 liblua 来创建虚拟环境</span></span><br><span class="line">    lua_State *lua = lua_open();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup) &#123;</span><br><span class="line">        server.lua_client = <span class="literal">NULL</span>;<span class="comment">// 清理 server 参数</span></span><br><span class="line">        server.lua_caller = <span class="literal">NULL</span>;</span><br><span class="line">        server.lua_cur_script = <span class="literal">NULL</span>;</span><br><span class="line">        server.lua_timedout = <span class="number">0</span>;</span><br><span class="line">        ldbInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step2: 加载需要的库，并去除不需要的库</span></span><br><span class="line">    luaLoadLibraries(lua);</span><br><span class="line">    luaRemoveUnsupportedFunctions(lua);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step3: 创建字典，用于保存 Lua 脚本</span></span><br><span class="line">    server.lua_scripts = dictCreate(&amp;shaScriptObjectDictType,<span class="literal">NULL</span>);</span><br><span class="line">    server.lua_scripts_mem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step4: 注册函数到 redis 哈希表中</span></span><br><span class="line">    <span class="comment">// 创建哈希表</span></span><br><span class="line">    lua_newtable(lua);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 redis.call</span></span><br><span class="line">    lua_pushstring(lua,<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    lua_pushcfunction(lua,luaRedisCallCommand);</span><br><span class="line">    lua_settable(lua,<span class="number">-3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略了重复的注册过程</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将哈希表命名为 redis 并设置为全局变量</span></span><br><span class="line">    lua_setglobal(lua,<span class="string">&quot;redis&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step5: 更替 random 函数库</span></span><br><span class="line">    lua_getglobal(lua,<span class="string">&quot;math&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lua_pushstring(lua,<span class="string">&quot;random&quot;</span>);</span><br><span class="line">    lua_pushcfunction(lua,redis_math_random);</span><br><span class="line">    lua_settable(lua,<span class="number">-3</span>);</span><br><span class="line"></span><br><span class="line">    lua_pushstring(lua,<span class="string">&quot;randomseed&quot;</span>);</span><br><span class="line">    lua_pushcfunction(lua,redis_math_randomseed);</span><br><span class="line">    lua_settable(lua,<span class="number">-3</span>);</span><br><span class="line"></span><br><span class="line">    lua_setglobal(lua,<span class="string">&quot;math&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加帮助函数，过程省略</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// step6: 创建 fake 客户端</span></span><br><span class="line">    <span class="keyword">if</span> (server.lua_client == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        server.lua_client = createClient(<span class="literal">NULL</span>);</span><br><span class="line">        server.lua_client-&gt;flags |= CLIENT_LUA;</span><br><span class="line">        server.lua_client-&gt;flags |= CLIENT_DENY_BLOCKING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step7: 设置全局保护</span></span><br><span class="line">    scriptingEnableGlobalsProtection(lua);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step8: 保存 lua 环境</span></span><br><span class="line">    server.lua = lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化函数虽然较长，结构为线性结构，逻辑也比较简单，初始化函数中的几个阶段分别完成了如下工作：</p><ol><li>使用 liblua 库函数创建 lua 虚拟机环境；</li><li>加载 Lua 基础函数库与表格库，并移除<code>loadfile</code>和<code>dofile</code>函数，防止引发安全问题；</li><li>创建一个 dict 用于保存 sha-script；</li><li>在 Lua 中创建 redis 表，并将 C 函数注册到该表格中，从而实现<code>redis.call</code>接口；</li><li>更替 random 函数库，保证随机函数在不同主机上生成相同的序列；</li><li>创建一个 fake 客户端，用于交互 redis 数据库；</li><li>设置全局保护，禁止设置全局变量；</li><li>将已经完成设置的 Lua 环境保存到 server 结构体中。</li></ol><h3 id="全局变量保护的实现"><a href="#全局变量保护的实现" class="headerlink" title="全局变量保护的实现"></a>全局变量保护的实现</h3><p>全局变量保护是许多 Lua 虚拟环境中都会完成的工作，利用的原理也大都相似——通过修改 _ENV 表中 _G 表中 metatable 来实现。metatable 是 Lua 表中的一个特殊表，它的每个字段中都存储了控制当前表一些行为的函数，如 <code>__index</code>字段 控制索引操作、<code>__add</code>字段控制表的相加操作。当需要对一个表进行操作时，LVM 将会查询该表的 metatable 是否有相关控制字段，若有该控制字段，会按照字段中存储的函数来执行操作。</p><p>基于元表的这一原理，通过修改 _G 表中 metatable 的 <code>__newindex</code> 和 ``__index`字段，就可以实现对插入和读取全局变量的保护。Redis 中实现该行为所使用的 Lua 脚本为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> dbg=<span class="built_in">debug</span></span><br><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="comment">-- 将 mt 赋值给 _G 的 metatable</span></span><br><span class="line"><span class="built_in">setmetatable</span>(<span class="built_in">_G</span>, mt)</span><br><span class="line">mt.<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t, n, v)</span></span></span><br><span class="line">    <span class="keyword">if</span> dbg.<span class="built_in">getinfo</span>(<span class="number">2</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> w = dbg.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;S&quot;</span>).what</span><br><span class="line">        <span class="comment">-- 如果不在 main 或 C 函数中，将不允许设置环境变量</span></span><br><span class="line">        <span class="comment">-- Redis 环境中，用户脚本都是包裹在 f_sha 函数中运行的，不能创建全局变量</span></span><br><span class="line">        <span class="keyword">if</span> w ~= <span class="string">&quot;main&quot;</span> <span class="keyword">and</span> w ~= <span class="string">&quot;C&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">error</span>(<span class="string">&quot;Script attempted to create global variable &#x27;&quot;</span>..<span class="built_in">tostring</span>(n)..<span class="string">&quot;&#x27;&quot;</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 除上述条件外，允许设置全局变量</span></span><br><span class="line">    <span class="comment">-- 这是为了将用户脚本放入到全局变量中</span></span><br><span class="line">    <span class="built_in">rawset</span>(t, n, v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">mt.<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t, n)</span></span></span><br><span class="line">    <span class="comment">-- 如果不在 main 或 C 函数中，将不允许访问不存在的环境变量</span></span><br><span class="line">    <span class="keyword">if</span> dbg.<span class="built_in">getinfo</span>(<span class="number">2</span>) <span class="keyword">and</span> dbg.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;S&quot;</span>).what ~= <span class="string">&quot;C&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;Script attempted to access nonexistent global variable &#x27;&quot;</span>..<span class="built_in">tostring</span>(n)..<span class="string">&quot;&#x27;&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rawget</span>(t, n)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">debug</span> = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>由于 Redis 中所有的用户脚本都是被包裹在名为 f_sha 的函数中运行的，这里通过修改元表中的行为，不允许在非 main 以及非 C 条件下设置全局变量、访问不存在的全局变量；这样就实现了全局变量的保护。</p><h3 id="redis-call-的实现"><a href="#redis-call-的实现" class="headerlink" title="redis.call 的实现"></a>redis.call 的实现</h3><p>这里介绍一下<code>redis.call()</code>接口的实现。在 Lua 中，函数是一等公民，可以作为值被放入到哈希表中，然后从哈希表中取出并调用。<code>redis.call()</code>其实是一种 Lua 语法糖的写法，其原始的写法应该是<code>redis[&#39;call&#39;]()</code>，即从 redis 哈希表中取出键为 call 的函数值并调用。在环境初始化过程中，<code>redis.call</code>最终会绑定到<code>luaRedisGenericCommmand</code>函数上，该函数负责与 redis 数据库进行交互，Lua 环境下并不会直接与 C 环境下的 redis 数据库进行交互。</p><p><code>luaRedisGenericCommmand</code>函数总长度约为 300 行，大部分逻辑为类型检查、异常处理等。剔除这些部分，仅仅保留主执行逻辑，我们可以把该函数分为以下几个阶段。<strong>函数中所有的参数检查都已经被删除</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaRedisGenericCommand</span><span class="params">(lua_State *lua, <span class="type">int</span> raise_error)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step1: 参数绑定阶段</span></span><br><span class="line">    <span class="comment">// 从栈中获取传递的参数个数 argc ，并构建 argv </span></span><br><span class="line">    <span class="type">int</span> j, argc = lua_gettop(lua);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">    client *c = server.lua_client;</span><br><span class="line">    sds reply;</span><br><span class="line">    <span class="type">static</span> robj **argv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> argv_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv_size &lt; argc) &#123;</span><br><span class="line">        argv = zrealloc(argv,<span class="keyword">sizeof</span>(robj*)*argc);</span><br><span class="line">        argv_size = argc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建 agrv 数组</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        <span class="type">char</span> *obj_s;</span><br><span class="line">        <span class="type">size_t</span> obj_len;</span><br><span class="line">        <span class="type">char</span> dbuf[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次解析栈中的参数，要求参数为 number 或 string 类型</span></span><br><span class="line">        <span class="keyword">if</span> (lua_type(lua,j+<span class="number">1</span>) == LUA_TNUMBER) &#123;</span><br><span class="line">            lua_Number num = lua_tonumber(lua,j+<span class="number">1</span>);</span><br><span class="line">            obj_len = <span class="built_in">snprintf</span>(dbuf,<span class="keyword">sizeof</span>(dbuf),<span class="string">&quot;%.17g&quot;</span>,(<span class="type">double</span>)num);</span><br><span class="line">            obj_s = dbuf;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj_s = (<span class="type">char</span>*)lua_tolstring(lua,j+<span class="number">1</span>,&amp;obj_len);</span><br><span class="line">            <span class="keyword">if</span> (obj_s == <span class="literal">NULL</span>) <span class="keyword">break</span>; <span class="comment">/* Not a string. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup our fake client for command execution */</span></span><br><span class="line">    c-&gt;argv = argv;</span><br><span class="line">    c-&gt;argc = argc;</span><br><span class="line">    c-&gt;user = server.lua_caller-&gt;user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process module hooks */</span></span><br><span class="line">    moduleCallCommandFilters(c);</span><br><span class="line">    argv = c-&gt;argv;</span><br><span class="line">    argc = c-&gt;argc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step2: 获取 command，检查是否允许运行</span></span><br><span class="line">    cmd = lookupCommand(argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// command 检查，主要可以分为以下几个步骤：</span></span><br><span class="line">    <span class="comment">// 1.是否存在</span></span><br><span class="line">    <span class="comment">// 2.command 是否允许运行</span></span><br><span class="line">    <span class="comment">// 3.当前内存是否达到上限</span></span><br><span class="line">    <span class="comment">// 4.检查随机函数与写函数</span></span><br><span class="line">    <span class="comment">// 5.检查 ACL 与 Cluster 选项</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// step3: 命令运行阶段</span></span><br><span class="line">    <span class="comment">// 更新 server 状态</span></span><br><span class="line">    <span class="type">int</span> call_flags = CMD_CALL_SLOWLOG | CMD_CALL_STATS;</span><br><span class="line">    <span class="keyword">if</span> (server.lua_replicate_commands) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.lua_repl &amp; PROPAGATE_AOF)</span><br><span class="line">            call_flags |= CMD_CALL_PROPAGATE_AOF;</span><br><span class="line">        <span class="keyword">if</span> (server.lua_repl &amp; PROPAGATE_REPL)</span><br><span class="line">            call_flags |= CMD_CALL_PROPAGATE_REPL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// core : 调用 redis 中的命令表</span></span><br><span class="line">    call(c,call_flags);</span><br><span class="line">    serverAssert((c-&gt;flags &amp; CLIENT_BLOCKED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step4: 命令结束阶段</span></span><br><span class="line">    <span class="comment">// 将客户端收到的 RESP 格式结果转换为 Lua 格式结果，并送入 Lua 栈中。</span></span><br><span class="line">    redisProtocolToLuaType(lua,reply);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step5: 清理阶段</span></span><br><span class="line">cleanup:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理 argc/argv 并尝试缓存。</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理，将 err 字段压入哈希表中</span></span><br><span class="line">    <span class="keyword">if</span> (raise_error) &#123;</span><br><span class="line">        <span class="comment">/* If we are here we should have an error in the stack, in the</span></span><br><span class="line"><span class="comment">         * form of a table with an &quot;err&quot; field. Extract the string to</span></span><br><span class="line"><span class="comment">         * return the plain error. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> luaRaiseError(lua);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体来说，该函数的逻辑也较为简单：从 Lua 栈中取出参数——调用 redis 命令表——将结果压入 Lua 栈中。函数中使用了一个 fake 客户端与数据库部分进行交互，因此<code>luaRedisGenericCommand</code>函数中必须要在 Lua 类型与 RESP 类型之间进行两次类型转换，但是这样的设计却有更多的优点：</p><ul><li>避免重写数据库操作函数，降低了工程量；</li><li>共用操作函数，保障了 Lua 脚本与其他命令执行结果的一致性；</li><li>加入了中间层，降低了 Lua 环境与 C 环境的耦合度；</li></ul><p>由于 Lua 语言本身是不含错误处理的，因此 Redis 额外设置了 pcall 用于包裹命令的执行，通过操作 Lua 栈的形式来进行错误的传递。当 Lua 脚本中使用<code>redis.pcall</code>时，<code>luaRedisGenericCommand</code>函数中的参数<code>raise_error</code>会被设置为 1，如果在命令执行过程中发生了错误，那么将会在最终的清理阶段通过<code>luaRaiseError</code>函数主动将错误信息压入到 Lua 栈中，以此来达到错误传递的目的。</p><h2 id="eval-族函数的一些实现"><a href="#eval-族函数的一些实现" class="headerlink" title="eval 族函数的一些实现"></a>eval 族函数的一些实现</h2><p>Redis 中 eval 族命令最终都会调用<code>evalGenericCommand</code>，该函数的细节部分较多，这里将函数分为几个部分来讲述，以下代码片段在非标明前提下均来自于<code>evalGenericCommand</code>函数。</p><h3 id="脚本的存储与编译"><a href="#脚本的存储与编译" class="headerlink" title="脚本的存储与编译"></a>脚本的存储与编译</h3><p>Redis 服务器提供了 Lua 脚本的复用功能，所有的脚本都会以 f_sha 的形式命名并存储在字典以及 Lua 环境中，其中 sha 是脚本经过 sha1hex 算法后计算得到的 40 位字符串。在调用脚本时，Redis 会直接尝试在 Lua 环境中使用 f_sha 来查找函数，若未找到，才会进行脚本的初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">funcname[<span class="number">0</span>] = <span class="string">&#x27;f&#x27;</span>; funcname[<span class="number">1</span>] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!evalsha) &#123;</span><br><span class="line"><span class="comment">// 计算 sha 值</span></span><br><span class="line">    sha1hex(funcname+<span class="number">2</span>,c-&gt;argv[<span class="number">1</span>]-&gt;ptr,sdslen(c-&gt;argv[<span class="number">1</span>]-&gt;ptr));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> j; <span class="type">char</span> *sha = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">40</span>; j++)</span><br><span class="line">        funcname[j+<span class="number">2</span>] = (sha[j] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; sha[j] &lt;= <span class="string">&#x27;Z&#x27;</span>) ? sha[j]+(<span class="string">&#x27;a&#x27;</span>-<span class="string">&#x27;A&#x27;</span>) : sha[j];</span><br><span class="line">    funcname[<span class="number">42</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Push the pcall error handler function on the stack. */</span></span><br><span class="line">lua_getglobal(lua, <span class="string">&quot;__redis__err__handler&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Lua 环境中查找脚本</span></span><br><span class="line">lua_getglobal(lua, funcname);</span><br><span class="line"><span class="keyword">if</span> (lua_isnil(lua,<span class="number">-1</span>)) &#123;</span><br><span class="line">    lua_pop(lua,<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">if</span> (evalsha) &#123;</span><br><span class="line">        lua_pop(lua,<span class="number">1</span>); </span><br><span class="line">        addReplyErrorObject(c, shared.noscripterr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行脚本的初始化</span></span><br><span class="line">    <span class="keyword">if</span> (luaCreateFunction(c,lua,c-&gt;argv[<span class="number">1</span>]) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lua_pop(lua,<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 重新获取脚本函数</span></span><br><span class="line">    lua_getglobal(lua, funcname);</span><br><span class="line">    serverAssert(!lua_isnil(lua,<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>luaCreateFunction</code>函数中，用户发送的脚本会被处理，并写入到 Lua 环境中的全局表中。假设用户所发送的 Lua 脚本内容为 function_body，那么最终将会被拼接为如下的形式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f_</span>&lt;<span class="title">sha</span>&gt;<span class="params">()</span></span> function_body</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果对 Redis 手册较为熟悉，那么可以了解到所有的 Lua 脚本在服务器重启后都会失效，需要重新加载。这一特性从函数<code>luaCreateFunction</code>中可以了解到缘由。Lua 脚本在被创建时，会被注册到<code>lua_scripts</code>哈希表中，而这一哈希表对于 redis 来说是一个“二等公民”，它并不享有数据持久化的功能，在每一次重启时，redis 并不会自动导入之前已经载入的脚本。Lua 脚本相关的持久化功能只会被用于主从复制等场景。</p><h3 id="脚本运行"><a href="#脚本运行" class="headerlink" title="脚本运行"></a>脚本运行</h3><p>Lua 脚本的运行在 C 代码中的体现比较少，在经过脚本的存储与编译后，只使用了如下代码来运行脚本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 KEYS 和 ARGV 作为全局变量放入 Lua 环境</span></span><br><span class="line">luaSetGlobalArray(lua,<span class="string">&quot;KEYS&quot;</span>,c-&gt;argv+<span class="number">3</span>,numkeys);</span><br><span class="line">luaSetGlobalArray(lua,<span class="string">&quot;ARGV&quot;</span>,c-&gt;argv+<span class="number">3</span>+numkeys,c-&gt;argc<span class="number">-3</span>-numkeys);</span><br><span class="line"></span><br><span class="line">prepareLuaClient();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* At this point whether this script was never seen before or if it was</span></span><br><span class="line"><span class="comment">  already defined, we can call it. We have zero arguments and expect</span></span><br><span class="line"><span class="comment">  a single return value. */</span></span><br><span class="line">err = lua_pcall(lua,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">resetLuaClient();</span><br></pre></td></tr></table></figure><p>由于脚本内容和输入参数已经被送入到了 Lua 虚拟机的栈中，这里直接使用了<code>lua_pcall</code>执行脚本，运行中需要访问数据库的操作将会使用已经注册到 Lua 环境中的 redis 族函数。若脚本在运行中发生错误，那么 Lua 栈顶部将会存储错误信息，在清理阶段将会收集信息并返回客户端。</p><h3 id="超时检测"><a href="#超时检测" class="headerlink" title="超时检测"></a>超时检测</h3><p>Redis 中所有用户命令的执行都是单线程串行的，为了防止单个 Lua 脚本运行时间过长阻塞服务端，Lua 模块中提供了脚本运行超时功能，当脚本运行超时后，用户可以使用 script kill 命令来强行结束脚本。这一功能是通过 Lua hook 来实现的，在<code>evalGenericCommand</code>函数中使用<code>lua_sethook(lua,luaMaskCountHook,LUA_MASKCOUNT,100000);</code>代码将函数<code>luaMaskCountHook</code>作为 hook 注册到 Lua 环境中，每执行 100000 条语句，Lua 将强制执行一次该函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaMaskCountHook</span><span class="params">(lua_State *lua, lua_Debug *ar)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算脚本运行的事件</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> elapsed = elapsedMs(server.lua_time_start);</span><br><span class="line">    UNUSED(ar);</span><br><span class="line">    UNUSED(lua);</span><br><span class="line">    <span class="comment">// 如果脚本运行超时</span></span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt;= server.lua_time_limit &amp;&amp; server.lua_timedout == <span class="number">0</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Lua slow script detected: still in execution after %lld milliseconds. &quot;</span></span><br><span class="line">            <span class="string">&quot;You can try killing the script using the SCRIPT KILL command. &quot;</span></span><br><span class="line">            <span class="string">&quot;Script SHA1 is: %s&quot;</span>,</span><br><span class="line">            elapsed, server.lua_cur_script);</span><br><span class="line">        server.lua_timedout = <span class="number">1</span>;</span><br><span class="line">        blockingOperationStarts();</span><br><span class="line">        <span class="comment">// 防止其他部分代码关闭脚本调用客户端</span></span><br><span class="line">        protectClient(server.lua_caller);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.lua_timedout) processEventsWhileBlocked();</span><br><span class="line">    <span class="keyword">if</span> (server.lua_kill) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Lua script killed by user with SCRIPT KILL.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lua_sethook(lua, luaMaskCountHook, LUA_MASKLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 在 Lua 环境下退出运行</span></span><br><span class="line">        lua_pushstring(lua,<span class="string">&quot;Script killed by user with SCRIPT KILL...&quot;</span>);</span><br><span class="line">        lua_error(lua);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脚本的运行时间是由该函数进行计算的，当脚本运行超时时函数将会输出一条日志，并且允许其他客户端强行中断脚本。中断一个正在运行的脚本是有条件的，必须确保当前执行的脚本没有进行过写操作，否则可能会严重影响数据库的安全性，甚至让数据库处于中间状态。Redis 中是通过记录脚本运行状态来判断脚本是否执行过写操作的，即标识位<code>server.lua_write_dirty</code>。在 Lua 脚本准备执行写操作时，会将该标识位置为 1，此时将不会允许脚本被中断。</p><p>Redis 同样会在该 hook 函数中来执行中断脚本的逻辑。当脚本发生超时后，每次执行 hook 函数，都会调用一次特殊的事件处理函数<code>processEventsWhileBlocked</code>：</p><p>Redis 的事务执行是单线程的，那么当 eventLoop 正在执行脚本时，为什么 Redis 还可以处理其余命令。Redis 并没有为 Lua 脚本单独开辟线程来运行，而是利用 Lua 环境中注册的 hook 函数来执行的。在 hook 函数中调用了<code>processEventsWhileBlocked</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">processEventsWhileBlocked</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> iterations = <span class="number">4</span>; <span class="comment">// 限制处理事务的时间</span></span><br><span class="line"></span><br><span class="line">    updateCachedTime(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ProcessingEventsWhileBlocked = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (iterations--) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> startval = server.events_processed_while_blocked;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ae_events = aeProcessEvents(server.el,</span><br><span class="line">            AE_FILE_EVENTS|AE_DONT_WAIT|</span><br><span class="line">            AE_CALL_BEFORE_SLEEP|AE_CALL_AFTER_SLEEP);</span><br><span class="line"></span><br><span class="line">        server.events_processed_while_blocked += ae_events;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> events = server.events_processed_while_blocked - startval;</span><br><span class="line">        <span class="keyword">if</span> (!events) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    whileBlockedCron();</span><br><span class="line">    ProcessingEventsWhileBlocked = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>processEventsWhileBlocked</code>每一次被调用时都会最多处理四个已经解析完毕的客户端命令。在阻塞状态下，Redis 服务器将会只允许一部分命令执行，这些命令不影响数据库的状态或者用于关闭正在运行的脚本，其余命令将会被拒绝执行。允许被执行的命令如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">processCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">...  </span><br><span class="line"><span class="keyword">if</span> (server.lua_timedout &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != authCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != helloCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != replconfCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != multiCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != watchCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != unwatchCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != resetCommand &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;proc == shutdownCommand &amp;&amp;</span><br><span class="line">          c-&gt;argc == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">tolower</span>(((<span class="type">char</span>*)c-&gt;argv[<span class="number">1</span>]-&gt;ptr)[<span class="number">0</span>]) == <span class="string">&#x27;n&#x27;</span>) &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;proc == scriptCommand &amp;&amp;</span><br><span class="line">          c-&gt;argc == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">tolower</span>(((<span class="type">char</span>*)c-&gt;argv[<span class="number">1</span>]-&gt;ptr)[<span class="number">0</span>]) == <span class="string">&#x27;k&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.slowscripterr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在允许被执行的命令中，auth, hello, replconf, multi, discard, watch, unwatch, reset 都不会对数据库产生任何影响，其余的两个命令则是用于关闭脚本运行。</p><h3 id="随机命令检测"><a href="#随机命令检测" class="headerlink" title="随机命令检测"></a>随机命令检测</h3><p>Redis 对 Lua 脚本环境下的随机命令有所限制，根据官方手册：Redis 不允许在 Lua 脚本中随机命令发生在写命令前，单独的随机命令不受影响；这是为了防止同一份 Lua 脚本在不同实例中的执行结果不同。例如，一个脚本的执行逻辑是随机获取 100 个键，并将其中键值最小的 10 个键删除；由于每个实例中随机获取的键不同，最终可能会导致不同 Redis 实例的状态不同。但是先写入，后随机读取的情况则是允许的，例如先更新一个键，然后随机读取 10 个键；这不会造成 Redis 实例状态不同。</p><p>这一功能的实现原理同脚本中断，也是使用标识位来实现的。这一功能的实现位于<code>luaRedisGenericCommmand</code>函数中，处于获取命令后的检查阶段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaRedisGenericCommand</span><span class="params">(lua_State *lua, <span class="type">int</span> raise_error)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;flags &amp; CMD_WRITE) &#123;</span><br><span class="line">        <span class="type">int</span> deny_write_type = writeCommandsDeniedByDiskError();</span><br><span class="line">        <span class="keyword">if</span> (server.lua_random_dirty &amp;&amp; !server.lua_replicate_commands) &#123;</span><br><span class="line">            luaPushError(lua,</span><br><span class="line">                <span class="string">&quot;Write commands not allowed after non deterministic commands. Call redis.replicate_commands() at the start of your script in order to switch to single commands replication mode.&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 其他检查</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果命令是写操作或随机操作，修改标识位</span></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;flags &amp; CMD_RANDOM) server.lua_random_dirty = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;flags &amp; CMD_WRITE) server.lua_write_dirty = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这一段函数的逻辑是在写操作中检查<code>if(server.lua_random_dirty == 1)</code>，因此先执行写操作，后执行随机操作是被允许的。但是，Redis 中实现的这一冲突检查并没有判断写操作是否是依赖于随机操作的，哪怕写操作与随机操作之间毫无关系，同样也会被报错；例如先随机读取 100 个键，然后删除掉特定的键，这样的逻辑是不被允许的。</p><p>另外，值得注意的是，这段逻辑中只检查了 Lua 脚本中的 redis 命令是否为随机命令，并不会检查 Lua 脚本中是否使用了随机函数。这是因为在 Lua 环境初始化阶段将<code>math.rand</code>函数已经被更替为 redis 的实现；redis 的随机函数实现中，只要保证使用相同的随机数种子，就能够在不同的主机环境下生成相同的随机数序。因此能够确保 Lua 脚本中的随机函数在不同主机下运行结果相同，不需要进行检测。</p><p>Redis 这里的实现是非常巧妙的，除了 Redis 选择的这种方法外，还有其他的方式可以完成随机函数的检测。其一是直接通过扫描脚本内容来实现随机函数的检测，这种方法能够在脚本运行前完成推断，但是需要依赖于语义分析，不仅实现困难，而且运行性能比较差。其二是通过覆盖 Lua 环境中的随机函数，在调用随机函数时更改<code>server.lua_random_dirty</code>标识位，这种方法的性能损耗比较小，但是也有一个比较隐秘的缺点——相比 Redis 实现，当用户只使用 Lua 随机函数时，需要中断脚本的运行。Redis 的实现方法基本上是无副作用的，并且 Lua 环境中并没有使用与数据库相同的随机种子，这也在一定程度上保护了数据库的安全性，防止通过脚本来推断出 Redis 数据库使用的随机种子。</p><h2 id="多机环境下的-Lua-脚本"><a href="#多机环境下的-Lua-脚本" class="headerlink" title="多机环境下的 Lua 脚本"></a>多机环境下的 Lua 脚本</h2><p>在单机环境下，Redis 对 Lua 模块的限制较小，但是在多机环境下，为了保障数据库的安全性，Redis 对 Lua 模块加入了一些限制条件。</p><h3 id="Replica-环境下的限制条件"><a href="#Replica-环境下的限制条件" class="headerlink" title="Replica 环境下的限制条件"></a>Replica 环境下的限制条件</h3><p>Replica 环境下的限制条件主要有以下几点：</p><ul><li>随机命令与写命令的顺序问题：随机命令不能发生在写命令之前，即使写命令不依赖随机命令；</li><li>脚本的加载时机与 evalsha 命令的传播问题；</li></ul><p>考虑这样一种情况：在构建复制集之前，Master 节点已经载入了一个 Lua 脚本。由于 Lua 脚本是一个“二等公民”，脚本本身并不会被 AOF/RDB 持久化记录；因此在构建出的复制集中，Slave 节点是不存在 Lua 脚本的源文件的。如果此时客户端直接使用 evalsha 命令来调用 Lua 脚本，Slave 节点中将无法执行该脚本，因为脚本并未在 Slave 节点中完成初始化。这有可能会导致主从节点的状态不一致。</p><p>为了解决这一冲突，在主从复制模式下，evalsha 会被转义为 eval 命令在主从节点之间传递，即传递全部 Lua 脚本。如果脚本过大，可能会影响网络带宽。</p><h3 id="Cluster-环境下的限制条件"><a href="#Cluster-环境下的限制条件" class="headerlink" title="Cluster 环境下的限制条件"></a>Cluster 环境下的限制条件</h3><h4 id="禁止访问不同分片"><a href="#禁止访问不同分片" class="headerlink" title="禁止访问不同分片"></a>禁止访问不同分片</h4><p>Cluster 环境下的限制更为苛刻：脚本只允许同时被访问当前实例所负责的分片。一方面是由于 Redis Cluster 设计，避免脚本重放，另一方面则是为了规避分布式事务的复杂性。</p><p>在 Redis Cluster 中允许一个分片中存在一主多从来实现故障恢复，保证高可用。考虑如下一种情况，分片 A 目前存活一主一从，而分片 B 目前存活一主；如果 Lua 脚本被允许访问不同分片上的数据，那么当分片 A 的主节点执行完毕后，分片 B 的从节点也需要执行一次脚本，这就需要付出一些额外的检查措施来保证分片 B 中的数据只会访问一次。这将会大大增加系统的复杂度，很难保证这一功能在加入之后会 0 bug。</p><p>另一方面，Lua 脚本中是允许使用 MULTI 事务的，如果支持访问多个分片的数据就必然会引入分布式事务的问题。Redis 本身定位是一个弱事务的内存数据库，必然不可能支持这一特性。</p><p>Redis 是在脚本运行中检查键是否存在于当前分片的，检查发生在<code>luaRedisGenericCommand</code>函数中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaRedisGenericCommand</span><span class="params">(lua_State *lua, <span class="type">int</span> raise_error)</span> &#123;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* If this is a Redis Cluster node, we need to make sure Lua is not</span></span><br><span class="line"><span class="comment">     * trying to access non-local keys, with the exception of commands</span></span><br><span class="line"><span class="comment">     * received from our master or when loading the AOF back in memory. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled &amp;&amp; !server.loading &amp;&amp;</span><br><span class="line">        !(server.lua_caller-&gt;flags &amp; CLIENT_MASTER))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> error_code;</span><br><span class="line">        <span class="comment">/* Duplicate relevant flags in the lua client. */</span></span><br><span class="line">        c-&gt;flags &amp;= ~(CLIENT_READONLY|CLIENT_ASKING);</span><br><span class="line">        c-&gt;flags |= server.lua_caller-&gt;flags &amp; (CLIENT_READONLY|CLIENT_ASKING);</span><br><span class="line">        <span class="comment">// 检查的具体逻辑发生在 getNodeByQuery 函数中</span></span><br><span class="line">        <span class="keyword">if</span> (getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,<span class="literal">NULL</span>,&amp;error_code) !=</span><br><span class="line">                           server.cluster-&gt;myself)&#123;</span><br><span class="line">            <span class="comment">// 自身分片不可用</span></span><br><span class="line">            <span class="keyword">if</span> (error_code == CLUSTER_REDIR_DOWN_RO_STATE) &#123;</span><br><span class="line">                luaPushError(lua,</span><br><span class="line">                    <span class="string">&quot;Lua script attempted to execute a write command while the &quot;</span></span><br><span class="line">                    <span class="string">&quot;cluster is down and readonly&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error_code == CLUSTER_REDIR_DOWN_STATE) &#123;</span><br><span class="line">                luaPushError(lua,</span><br><span class="line">                    <span class="string">&quot;Lua script attempted to execute a command while the &quot;</span></span><br><span class="line">                    <span class="string">&quot;cluster is down&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 试图访问其他分片</span></span><br><span class="line">                luaPushError(lua,</span><br><span class="line">                    <span class="string">&quot;Lua script attempted to access a non local key in a &quot;</span></span><br><span class="line">                    <span class="string">&quot;cluster node&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 并不会在脚本运行前对所有需要访问的键进行检查，而是在运行中进行检查。因此，贸然访问不同分片上的值可能会让 Lua 脚本在运行中被中断，无法保证脚本逻辑的完整性。在分片模式下使用 Lua 脚本必须首先确保访问的所有键值对都处于同一分片，最好不要同时访问多个键。</p><p>在确定分片时，如果 key 值中存在<code>&#123;&#125;</code>，那么会使用第一个<code>&#123;&#125;</code>中的值计算哈希槽；当集群模式下需要用 Lua 脚本来访问多个键时，可以将键值对以相同的开头命名，确保所有键值对都被分配到同一个哈希槽内。</p><h4 id="禁止使用发布订阅"><a href="#禁止使用发布订阅" class="headerlink" title="禁止使用发布订阅"></a>禁止使用发布订阅</h4><p>在 Lua 脚本中使用发布订阅同样也会因为脚本重放而引发一系列问题。由于 Cluster 模式中全局共享发布订阅频道，当脚本在主从节点之间传递时，会导致发布订阅命令被多次执行。</p><h2 id="Redis-Function"><a href="#Redis-Function" class="headerlink" title="Redis Function"></a>Redis Function</h2><p>Redis Function 是 Redis 7.0 版本推出的全新功能，该功能是在原有 Lua 模块上的扩展与完善。Redis Function 将会被作为“一等公民”存储在数据库中，支持完整的持久化功能，这解决了 Lua 模块中的一些痛点。在使用 Redis 7.0 时，可以使用 Redis Function 来代替 Lua 模块。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>boltdb源码通读笔记</title>
      <link href="/2023/01/29/boltdb%E6%BA%90%E7%A0%81%E9%80%9A%E8%AF%BB/"/>
      <url>/2023/01/29/boltdb%E6%BA%90%E7%A0%81%E9%80%9A%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>Bolt 是一个完全由 go 写成的基于硬盘的 K/V 存储引擎，为了表示区分一般被称为 boltdb。对于一款存储引擎而言，boltdb 的源码非常短小精悍，包含测试代码仅有 17000 行左右。正是因为其体量比较小，boltdb 并不具备较为复杂的功能；在实现上，boltdb 主要借鉴了其他语言中的做法并将其改进，使之更加符合 go 语言的基础架构。</p><p>通读 boltdb 的代码，主要是为了学习作者是如何利用 go 语言的特性来实现数据库的，这是本文的重点内容。而 boltdb 的用法以及其中的基本概念，可以参考<a href="https://www.bookstack.cn/books/jaydenwen123-boltdb_book">《自底向上分析 BoltDB 源码》</a>。</p><h2 id="各模块实现方式"><a href="#各模块实现方式" class="headerlink" title="各模块实现方式"></a>各模块实现方式</h2><p>首先介绍一下 boltdb 中各个模块的实现方式：</p><ul><li>数据库文件落盘：使用 mmap 读取数据库文件，使用 write 接口写回脏页；</li><li>空闲页面管理：使用链表/哈希表进行管理，按需取出，不够时重新 mmap 映射；</li><li>数据库文件 compact：使用写缓冲，重写数据库文件；</li><li>内存硬盘之间页面大小保持一致，直接映射；</li><li>无日志，事务提交时直接落盘，使用读写锁控制并发。</li></ul><p>可以看到 boltdb 中的各个模块实现都是比较简单的，这也在一定程度上保障了其稳定性。boltdb 无日志的设计使得写写之间是禁止并发的，因此 boltdb 可以很轻松地实现可串行级别的事务隔离。同时这也导致 boltdb 的写入性能非常差，只适合多读少写的场景。另外，boltdb 直接使用了 mmap 来映射数据库文件，这在一方面避免了 go 中的 GC 保证了数据库的性能，但另一方面当数据库大小超过内存时，可能会导致内存页面频繁被置换从而影响性能。但在 go 语言中大量使用指针可能会导致 GC 问题，使用 mmap 映射相当于避免了内存 B+ 树页面的 GC 扫描，这在 go 语言限制下应该是一种比较好的设计。</p><h2 id="mmap-映射"><a href="#mmap-映射" class="headerlink" title="mmap 映射"></a>mmap 映射</h2><h3 id="mmap-映射实现"><a href="#mmap-映射实现" class="headerlink" title="mmap 映射实现"></a>mmap 映射实现</h3><p>boltdb 使用 mmap 系统调用的源码片段如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mmap</span><span class="params">(db *DB, sz <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// Map the data file to memory.</span></span><br><span class="line">b, err := unix.Mmap(<span class="type">int</span>(db.file.Fd()), <span class="number">0</span>, sz, syscall.PROT_READ, syscall.MAP_SHARED|db.MmapFlags)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Advise the kernel that the mmap is accessed randomly.</span></span><br><span class="line">err = unix.Madvise(b, syscall.MADV_RANDOM)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != syscall.ENOSYS &#123;</span><br><span class="line"><span class="comment">// Ignore not implemented error in kernel because it still works.</span></span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;madvise: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save the original byte slice and convert to a byte array pointer.</span></span><br><span class="line">db.dataref = b</span><br><span class="line">db.data = (*[maxMapSize]<span class="type">byte</span>)(unsafe.Pointer(&amp;b[<span class="number">0</span>]))</span><br><span class="line">db.datasz = sz</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分内容很简单，将 mmap 映射获得的内存设置为只读，并且允许进程间共享；调用 madvise 将内存片段设置为随机读取模式，防止操作系统按照顺序读的方式来置换出内存页面。 最后，boltdb 将 mmap 获得的内存片段转换为了一个长度为<code>maxMapSize</code>的切片指针，这一个步骤主要是为了方便进行<code>page</code>、<code>meta</code>等数据结构的映射。设置切片长度为<code>maxMapSize</code>是为了能够方便地完成 Golang 中的 unsafe 转换，保证转换长度足够。</p><p>如果成功获得内存映射片段，boltdb 还会调用<code>mlock</code>尝试禁止页面置换，从而提升数据库读性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> mmap(minsz <span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> db.Mlock &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allow swapping of data file</span></span><br><span class="line">        <span class="keyword">if</span> err := db.mlock(fileSize); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然<code>mlock</code>调用会抛出 error，但是并不会影响数据库的正常处理流程。</p><p> boltdb 并没有使用 mmap 接口直接进行文件写入的操作，因为 mmap 的写入时机较为特殊，它不会立刻进行刷盘，而是等待内存页面被置换出时再进行刷盘，或者进程主动使用 madvise + msnyc 进行刷盘。这是因为操作系统并不确定进程是否会在未来的一段时间内再次对内存片段进行更新，因此采取惰性处理策略会更好。boltdb 中选择使用了<code>writeAt</code>接口进行文件写入。当一个写事务被提交时，它会将当前数据库文件中的所有脏页写回到硬盘中。</p><h3 id="mmap-映射策略"><a href="#mmap-映射策略" class="headerlink" title="mmap 映射策略"></a>mmap 映射策略</h3><p>随着数据库文件大小的增长，boltdb 从操作系统中获得的 mmap 内存大小可能会小于数据库文件的长度。这种情况发生时，boltdb 将会再次使用 mmap 来增加映射内存的长度。boltdb 每次进行内存映射时，映射的内存大小并不等于数据库文件的大小，而是根据一定策略来选择内存大小。选择映射内存大小的逻辑出现在 db.go 的<code>mmapSize</code>函数中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> mmapSize(size <span class="type">int</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// Double the size from 32KB until 1GB.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="type">uint</span>(<span class="number">15</span>); i &lt;= <span class="number">30</span>; i++ &#123;<span class="comment">// 数据库文件小于1GB时，每次映射的大小翻倍</span></span><br><span class="line"><span class="keyword">if</span> size &lt;= <span class="number">1</span>&lt;&lt;i &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> &lt;&lt; i, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Verify the requested size is not above the maximum allowed.</span></span><br><span class="line">    <span class="comment">// maxMapSize == 0xFFFFFFFFFFFF</span></span><br><span class="line"><span class="keyword">if</span> size &gt; maxMapSize &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;mmap too large&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If larger than 1GB then grow by 1GB at a time.</span></span><br><span class="line">sz := <span class="type">int64</span>(size)</span><br><span class="line">    <span class="comment">// maxMmapStep == 1 &lt;&lt; 30</span></span><br><span class="line"><span class="keyword">if</span> remainder := sz % <span class="type">int64</span>(maxMmapStep); remainder &gt; <span class="number">0</span> &#123;</span><br><span class="line">sz += <span class="type">int64</span>(maxMmapStep) - remainder</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Ensure that the mmap size is a multiple of the page size.</span></span><br><span class="line"><span class="comment">// This should always be true since we&#x27;re incrementing in MBs.</span></span><br><span class="line">pageSize := <span class="type">int64</span>(db.pageSize)</span><br><span class="line"><span class="keyword">if</span> (sz % pageSize) != <span class="number">0</span> &#123;</span><br><span class="line">sz = ((sz / pageSize) + <span class="number">1</span>) * pageSize</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If we&#x27;ve exceeded the max size then only grow up to the max size.</span></span><br><span class="line"><span class="keyword">if</span> sz &gt; maxMapSize &#123;</span><br><span class="line">sz = maxMapSize</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">int</span>(sz), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码，我们可以得到 boltdb 中内存映射的策略具有两个阶段，即快速增长期与慢速增长期。当数据库文件小于 1GB 时，boltdb 的内存分配处于快速增长期，进行内存映射时会直接按照数据库文件大小向上取整为 2 的幂。当数据库文件大于 1GB 时，每一次进行内存映射时的内存大小较上一次增长 1GB。由于在慢速增长期，内存映射策略是步进的，可能会出现步进后的内存大小并不是页面大小(4 KB)的整数倍，这种情况下使用最后一个页面将会导致程序越界访问内存，导致程序崩溃；因此需要向上取整为页面的大小。</p><h2 id="struct-零成本重建"><a href="#struct-零成本重建" class="headerlink" title="struct 零成本重建"></a>struct 零成本重建</h2><p>boltdb 使用了直接映射的方式来完成一些数据结构的写入和重建，该方式并不会拷贝内存而是重新解释 unsafe pointer 来完成对象的重建，这些操作使用了 unsafe.go 中的接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unsafeAdd</span><span class="params">(base unsafe.Pointer, offset <span class="type">uintptr</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(<span class="type">uintptr</span>(base) + offset)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unsafeIndex</span><span class="params">(base unsafe.Pointer, offset <span class="type">uintptr</span>, elemsz <span class="type">uintptr</span>, n <span class="type">int</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(<span class="type">uintptr</span>(base) + offset + <span class="type">uintptr</span>(n)*elemsz)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unsafeByteSlice</span><span class="params">(base unsafe.Pointer, offset <span class="type">uintptr</span>, i, j <span class="type">int</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (*[maxAllocSize]<span class="type">byte</span>)(unsafeAdd(base, offset))[i:j:j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unsafeSlice modifies the data, len, and cap of a slice variable pointed to by</span></span><br><span class="line"><span class="comment">// the slice parameter.  This helper should be used over other direct</span></span><br><span class="line"><span class="comment">// manipulation of reflect.SliceHeader to prevent misuse, namely, converting</span></span><br><span class="line"><span class="comment">// from reflect.SliceHeader to a Go slice type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unsafeSlice</span><span class="params">(slice, data unsafe.Pointer, <span class="built_in">len</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s := (*reflect.SliceHeader)(slice)</span><br><span class="line">    s.Data = <span class="type">uintptr</span>(data)</span><br><span class="line">    s.Cap = <span class="built_in">len</span></span><br><span class="line">    s.Len = <span class="built_in">len</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可以用来进行简单对象的转换，相当于进行了一次对象的引用，重建后的对象地址会发生改变，但对象内容中的各个子对象地址都不会发生改变；下面使用一个 demo 来演示该方法是如何工作的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">content1 <span class="type">int32</span></span><br><span class="line">content2 <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Foo)</span></span> unsafeByteSlice() []<span class="type">byte</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (*[unsafe.Sizeof(*d)]<span class="type">byte</span>)(unsafe.Pointer(d))[<span class="number">0</span>:unsafe.Sizeof(*d)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseFromByteSlice</span><span class="params">(serialized []<span class="type">byte</span>)</span></span> *Foo &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (*Foo)(unsafe.Pointer(&amp;serialized[<span class="number">0</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ObjectSerializedTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := Foo&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">now := time.Now()</span><br><span class="line"></span><br><span class="line">slice := d.unsafeByteSlice()</span><br><span class="line">d.content2 = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">dd := parseFromByteSlice(slice)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;time cost:&quot;</span>, time.Since(now).Nanoseconds(), <span class="string">&quot;ns&quot;</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dd.content1:&quot;</span>, dd.content1)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dd.content2:&quot;</span>, dd.content2)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;d address:&quot;</span>, &amp;d)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dd address:&quot;</span>, &amp;dd)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;d content1 address:&quot;</span>, &amp;d.content1)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dd content2 address:&quot;</span>, &amp;dd.content1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo 先获取对象 d 的内存片段，然后修改对象 dd 的值，再使用该内存片段重建对象，程序输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">time cost: <span class="number">162</span> ns</span><br><span class="line">dd.content1: <span class="number">1</span></span><br><span class="line">dd.content2: <span class="number">3</span></span><br><span class="line">d address: <span class="number">0xc000062f38</span></span><br><span class="line">dd address: <span class="number">0xc000062f50</span></span><br><span class="line">d content1 address: <span class="number">0xc000062f38</span></span><br><span class="line">dd content2 address: <span class="number">0xc000062f38</span></span><br></pre></td></tr></table></figure><p>可以看到，dd 与 d 两个对象的地址是不同的，但是 dd.content1 与 d.content1 地址是相同的；因此即使在进行映射后更改 d 中的值，也会造成 dd 的改变。运用此方法进行 struct -&gt; slice -&gt; struct 耗时仅为 162ns，主要耗时集中在类型转换上。</p><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>由于 boltdb 内部使用了读写锁，为了对读写事务加以区分，并给予用户较高的自由度，boltdb 设计了如下接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只读事务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> View(fn <span class="function"><span class="keyword">func</span><span class="params">(*Tx)</span></span> <span class="type">error</span>) <span class="type">error</span></span><br><span class="line"><span class="comment">// 写事务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Update(fn <span class="function"><span class="keyword">func</span><span class="params">(*Tx)</span></span> <span class="type">error</span>) <span class="type">error</span></span><br><span class="line"><span class="comment">// 批处理事务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Batch(fn <span class="function"><span class="keyword">func</span><span class="params">(*Tx)</span></span> <span class="type">error</span>) <span class="type">error</span></span><br><span class="line"><span class="comment">// 原始事务接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Begin(writable <span class="type">bool</span>) (*Tx, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>在事务的开启阶段，就可以简单地对事务进行区分，更好地处理读写并行关系。</p><h2 id="空闲页索引"><a href="#空闲页索引" class="headerlink" title="空闲页索引"></a>空闲页索引</h2><p>boltdb 的设计中，并不会直接在 B+树上进行修改，而是会先分配出一块缓冲区，写入缓冲区后再 merge 到 B+树上，即 COW。这种策略能够实现多读一些的并行。写事务的内存分配是由如下代码片段来实现的，该代码主要具有两个部分的功能，一部分是尝试用内存池中获取或者直接分配出一块缓冲区用于写入，另一部分则是在 B+树中找出合适的写入位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> allocate(txid txid, count <span class="type">int</span>) (*page, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 分配用于 COW 的内存</span></span><br><span class="line">    <span class="keyword">var</span> buf []<span class="type">byte</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">1</span> &#123;</span><br><span class="line">      buf = db.pagePool.Get().([]<span class="type">byte</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buf = <span class="built_in">make</span>([]<span class="type">byte</span>, count*db.pageSize)</span><br><span class="line">    &#125;</span><br><span class="line">    p := (*page)(unsafe.Pointer(&amp;buf[<span class="number">0</span>]))</span><br><span class="line">    p.overflow = <span class="type">uint32</span>(count - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 试图从当前 mmap 内存中找到可用的页</span></span><br><span class="line">    <span class="keyword">if</span> p.id = db.freelist.allocate(txid, count); p.id != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未找到，说明数据库过大，需要调整 mmap 大小</span></span><br><span class="line">    p.id = db.rwtx.meta.pgid</span><br><span class="line">    <span class="keyword">var</span> minsz = <span class="type">int</span>((p.id+pgid(count))+<span class="number">1</span>) * db.pageSize</span><br><span class="line">    <span class="keyword">if</span> minsz &gt;= db.datasz &#123;</span><br><span class="line">      <span class="keyword">if</span> err := db.mmap(minsz); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;mmap allocate error: %s&quot;</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将之前的最后一页分配给事务（mmap 分配出的新页在该页之后）</span></span><br><span class="line">    db.rwtx.meta.pgid += pgid(count)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>freelist</code>的功能只是为了调控当前事务需要再 B+树中写入的位置，而不直接管理内存。当事务需要写入时，必须分配一次内存，这样做的好处是不需要做内存池的管理了。当无法从<code>freelist</code>中获取可写的页时，代表当前 B+树已经无可用位置给事务写入，这并不代表当前 B+树已经写满了，可能是由于当前事务需要写入的数据量过大。具体如何去界定，是由不同的分配策略来决定的。</p><p>在 boltdb 中，使用<code>freelist</code>结构体来统一管理 mmap 获得的内存在当前时刻下的视图。该结构体只使用 pageid 来管理当前时刻的状态，但并不直接管理页面的内存，因为 boltdb 中使用的是 COW 机制，所有的写入操作并不会直接在 mmap 的内存上写入，而是先写入到其他内存上，等待写入完毕后再 merge 到 B+ 树中。这样是为了避免 mmap 的低效写入问题，并且更加具有安全性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> freelist <span class="keyword">struct</span> &#123;</span><br><span class="line">    freelistType   FreelistType                <span class="comment">// freelist type</span></span><br><span class="line">    ids            []pgid                      <span class="comment">// all free and available free page ids.</span></span><br><span class="line">    allocs         <span class="keyword">map</span>[pgid]txid               <span class="comment">// mapping of txid that allocated a pgid.</span></span><br><span class="line">    pending        <span class="keyword">map</span>[txid]*txPending         <span class="comment">// mapping of soon-to-be free page ids by tx.</span></span><br><span class="line">    cache          <span class="keyword">map</span>[pgid]<span class="keyword">struct</span>&#123;&#125;           <span class="comment">// fast lookup of all free and pending page ids.</span></span><br><span class="line">    freemaps       <span class="keyword">map</span>[<span class="type">uint64</span>]pidSet           <span class="comment">// key is the size of continuous pages(span), value is a set which contains the starting pgids of same size</span></span><br><span class="line">    forwardMap     <span class="keyword">map</span>[pgid]<span class="type">uint64</span>             <span class="comment">// key is start pgid, value is its span size</span></span><br><span class="line">    backwardMap    <span class="keyword">map</span>[pgid]<span class="type">uint64</span>             <span class="comment">// key is end pgid, value is its span size</span></span><br><span class="line">    allocate       <span class="function"><span class="keyword">func</span><span class="params">(txid txid, n <span class="type">int</span>)</span></span> pgid <span class="comment">// the freelist allocate func</span></span><br><span class="line">    free_count     <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>                  <span class="comment">// the function which gives you free page number</span></span><br><span class="line">    mergeSpans     <span class="function"><span class="keyword">func</span><span class="params">(ids pgids)</span></span>             <span class="comment">// the mergeSpan func</span></span><br><span class="line">    getFreePageIDs <span class="function"><span class="keyword">func</span><span class="params">()</span></span> []pgid               <span class="comment">// get free pgids func</span></span><br><span class="line">    readIDs        <span class="function"><span class="keyword">func</span><span class="params">(pgids []pgid)</span></span>          <span class="comment">// readIDs func reads list of pages and init the freelist</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>freelist</code>以不同的视角来记录每一个页面上的可用范围，并根据写事务所需要的范围来分配具体的页面。在 boltdb 的实现中，<code>freelist</code>具有 FreelistArrayType 和 FreelistMapType 两种分配策略，前者会使用线性查找的方式来查询一块可用的内存页，而后者则使用索引的方式来查找可用的内存范围。FreelistMapType 分配策略的性能要远好于 FreelistArrayType。其具体做法是在归还的过程中将邻接页中可用的内存区域进行“合并”，并且这一块区域的整体大小注册到 freemaps 数据结构中。这样在查询可用区域的时候就不需要进行遍历，而是采用哈希表的方式进行查询。具体的细节可以参考该设计的<a href="https://www.cncf.io/blog/2019/05/09/performance-optimization-of-etcd-in-web-scale-data-scenario/">博客文章</a>。</p><h2 id="写入性能"><a href="#写入性能" class="headerlink" title="写入性能"></a>写入性能</h2><p>归根结底，一个基于硬盘的数据库系统的性能瓶颈是硬盘的 IO 速度，在其他的数据库设计中，面对写入，都是先使用低成本的操作记录写入日志，然后再将写入内容搬运到具体的位置上，才能够获得较高的写入性能。而 boltdb 的设计中，并没有对写入操作进行任何的缓冲机制，而是直接将写入内容放入到硬盘中，这是其写入性能较低的根本原因。但是这种设计能够很简单地实现事务的串行，任何设计都有取舍，写入性能就是 boltdb 舍弃掉的东西。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 数据库 </category>
          
          <category> etcd </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以freecache和bigcache为例看go进程内缓存</title>
      <link href="/2023/01/27/%E4%BB%A5freecachebigcache%E4%B8%BA%E4%BE%8B%E7%9C%8Bgo%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98/"/>
      <url>/2023/01/27/%E4%BB%A5freecachebigcache%E4%B8%BA%E4%BE%8B%E7%9C%8Bgo%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>应用缓存具有两种形式：缓存服务和进程内缓存。在大部分情景下，缓存服务已经可以解决应用缓存问题；但由于缓存服务需要经过网络通信，其性能一般是不如进程内缓存的。当性能要求较高时，就需要考虑采取进程内缓存的方案。并且，进程内缓存可以直接寻址，因此不仅可以缓存字符串，还可以缓存更加复杂的数据结构。不过同样地，进程内缓存也具有其缺点，诸如维护较为困难、缓存难以共享、影响进程内其他模块性能等。</p><p>一般而言，设计进程内缓存主要需要考虑以下几个方面的问题：</p><ol><li>应用于高并发、高性能场景，需要较高的并发性能；</li><li>内存管理策略，如缓存淘汰机制，防止占用过多资源；</li><li>CPU 占用低，不影响进程内其他模块的性能；</li><li>存储灵活多变的数据结构，如会话 token 等。</li></ol><p>freecache 和 bigcache 是两个比较出色的使用 go 语言的进程内缓存的开源项目；另外 bigcache 还有一个衍生类项目 fastcache。下文将从进程内缓存需要考虑的几个问题出发，对比着几个项目的异同点。</p><h2 id="实现高并发"><a href="#实现高并发" class="headerlink" title="实现高并发"></a>实现高并发</h2><p>freecache 和 bigcache 中实现高并发的策略是相同的：哈希表分片来减小锁的粒度。</p><p><img src="/images/map-slice.png" alt="map-slice.png"></p><p>由于哈希表的时间复杂为 O(1)，因此进程内缓存应当首选哈希表为数据结构；但由于哈希表并不是一个线程安全的数据结构，必须加锁来保护，并发的线程数量较多时，直接对哈希表进行加锁性能会非常差。哈希表分片是通过哈希值的方式将大哈希表拆分为多个小哈希表，这样只需要对每一个小哈希表进行加锁保护即可，这种方式降低了锁粒度，可以大幅度提升并发性能。这种处理比较常见。</p><h2 id="CPU-占用-GC"><a href="#CPU-占用-GC" class="headerlink" title="CPU 占用(GC)"></a>CPU 占用(GC)</h2><p>由于 go 是一种 GC 语言，进程内缓存就不得不考虑垃圾回收对性能的影响。在 go 中，使用指针、哈希表等非内存连续的结构会导致 GC 的时间大幅度增加，freecache 和 bigcache 中的设计都考虑到了这两点。虽然工程实现上有所区别，但是两者的核心思想都是相同的：使用线性数据结构来存储键值对，利用哈希表来存储地址偏移量，从而避免 GC 耗时。使用简单的代码就可以描述其原理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">origin := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span>)</span><br><span class="line"><span class="comment">// 写入方式</span></span><br><span class="line">value := origin[<span class="string">&quot;key&quot;</span>]</span><br><span class="line"></span><br><span class="line">better := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">slice := <span class="built_in">make</span>([][]<span class="type">byte</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment">// 写入方式</span></span><br><span class="line">value := slice[better[hash(<span class="string">&quot;key&quot;</span>)]]</span><br></pre></td></tr></table></figure><p>freecache 中并没有使用 go 自建的哈希表作为索引，而是使用哈希函数加 slice 的形式自行搭建了一个哈希表；bigcache 中则是直接使用了 go 自建的哈希表作为索引。不考虑哈希函数优劣的前提下，freecache 这里的设计更好，因为只需要计算一次哈希值即可，而 bigcache 中则需要计算两次哈希值。</p><p>在线性存储结构方面的区别主要在于，bigcache 是支持自动扩容的（使用拷贝的方法）。</p><h2 id="数据结构的支持"><a href="#数据结构的支持" class="headerlink" title="数据结构的支持"></a>数据结构的支持</h2><p>C++ 实现的进程内缓存通常都支持存储多种数据结构，不仅可以存储字符串、还可以存储更为复杂的数据结构；在网络服务器中，就可以使用本地缓存来存储 tcp 连接的描述符。而 go 实现的进程内缓存一般只支持存储字符串，复杂的数据结构只能够经过序列化后存储在缓冲中，这一方面是因为 go 在 1.18 版本前并不支持泛型，另一方面是因为 go GC 机制的存在。</p><p>理论上，不使用泛型，只使用<code>interface&#123;&#125;</code>也是可以实现存储不同的数据类型的，并且不会给 GC 带来额外的压力；但是问题在于，如果存储的数据结构比较复杂的话（比如数据结构中存在指针），也会大幅度影响 GC 的性能。使用以下实验分别测试在 1000W 数据量情况下，go GC 的时间；以下几组测试分别在不同的进程中完成，不存在相互的影响：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单数据类型，不含指针</span></span><br><span class="line"><span class="keyword">type</span> simple <span class="keyword">struct</span>&#123;</span><br><span class="line">a <span class="type">int</span></span><br><span class="line">b <span class="type">int</span> </span><br><span class="line">c <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 复杂数据类型，含有指针</span></span><br><span class="line"><span class="keyword">type</span> <span class="built_in">complex</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">s1 *simple</span><br><span class="line">s2 *simple</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1000W int 数据类型</span></span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10000000</span>);</span><br><span class="line"><span class="comment">// 1000W 简单数据结构，接口存储</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]any,<span class="number">10000000</span>);</span><br><span class="line"><span class="comment">// 1000W 简单数据结构，指针存储</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]*simple,<span class="number">10000000</span>);</span><br><span class="line"><span class="comment">// 1000W 复杂数据结构，接口存储</span></span><br><span class="line">s4 := <span class="built_in">make</span>([]any,<span class="number">10000000</span>);</span><br></pre></td></tr></table></figure><p>四组的 GC 时间在 go 1.19 版本经过测试后，分别如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 GC time: 328 us</span><br><span class="line">s2 GC time: 336 us</span><br><span class="line">s3 GC time: 5228 us</span><br><span class="line">s4 GC time: 19552 us</span><br></pre></td></tr></table></figure><p>对比 s2 和 s4 可以看到，当数据量比较大时，内部含有指针的数据结构所需要耗费的 GC 时间甚至达到了约 20ms，相比于简单数据结构增长了 58 倍左右；这是一个比较可观的延迟。另外，对比 s1、s2 和 s3 三组实验，在切片中使用指针同样会导致全量的 GC 扫描，否则会导致 GC 时间大幅度增加。</p><p>由以上的实验，我们可以得出两个结论，go 实现的进程内缓存，如果要存储复杂数据结构，就必须使用非指针形式存储，并且要求数据结构内部尽量不存在过多指针，否则会导致性能大幅度降低。但这会带来一个问题：复杂的数据结构本身占用的内存可能会较大，每次写入和读出缓存时都会涉及到一次全量复制，这是非常耗时的一个过程。</p><p>针对这一点，我觉得可以结合<code>sync.Pool</code>的思路来实现零拷贝写入：在进程内缓存内部设置一个 hook 函数，用户可以通过设置 hook 来控制缓存所存储的数据类型，当用户需要时，直接将对象构造在缓存的内部，然后返回用户指针，这样就可以节约写入时的拷贝。并且，缓存内部失效的数据结构也可以被复用，可以节约对象构造的时间。</p><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>根据 bigcache README 中的 <a href="https://github.com/allegro/bigcache">benchmark</a> 测试结果，freecache 在性能上会比 bigcache 略低，这里贴出 v3.1.0 版本，bigcache 主页的测试结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br><span class="line">go version go1.13 linux/amd64</span><br><span class="line"></span><br><span class="line">go test -bench=. -benchmem -benchtime=4s ./... -timeout 30m</span><br><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/allegro/bigcache/v3/caches_bench</span><br><span class="line">BenchmarkMapSet-8                     12999889       376 ns/op     199 B/op       3 allocs/op</span><br><span class="line">BenchmarkConcurrentMapSet-8            4355726      1275 ns/op     337 B/op       8 allocs/op</span><br><span class="line">BenchmarkFreeCacheSet-8               11068976       703 ns/op     328 B/op       2 allocs/op</span><br><span class="line">BenchmarkBigCacheSet-8                10183717       478 ns/op     304 B/op       2 allocs/op</span><br><span class="line">BenchmarkMapGet-8                     16536015       324 ns/op      23 B/op       1 allocs/op</span><br><span class="line">BenchmarkConcurrentMapGet-8           13165708       401 ns/op      24 B/op       2 allocs/op</span><br><span class="line">BenchmarkFreeCacheGet-8               10137682       690 ns/op     136 B/op       2 allocs/op</span><br><span class="line">BenchmarkBigCacheGet-8                11423854       450 ns/op     152 B/op       4 allocs/op</span><br><span class="line">BenchmarkBigCacheSetParallel-8        34233472       148 ns/op     317 B/op       3 allocs/op</span><br><span class="line">BenchmarkFreeCacheSetParallel-8       34222654       268 ns/op     350 B/op       3 allocs/op</span><br><span class="line">BenchmarkConcurrentMapSetParallel-8   19635688       240 ns/op     200 B/op       6 allocs/op</span><br><span class="line">BenchmarkBigCacheGetParallel-8        60547064        86.1 ns/op     152 B/op       4 allocs/op</span><br><span class="line">BenchmarkFreeCacheGetParallel-8       50701280       147 ns/op     136 B/op       3 allocs/op</span><br><span class="line">BenchmarkConcurrentMapGetParallel-8   27353288       175 ns/op      24 B/op       2 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  github.com/allegro/bigcache/v3/caches_bench256.257s</span><br></pre></td></tr></table></figure><p>两者的代码结构其实比较类似，差别之处主要在于过期键的清理、哈希表的实现方面；肉眼是无法观察出两者的优劣的，使用 pprof 工具来分析 benchmark 时 freecache 的 CPUProfile，得到以下的结果。</p><p><img src="/images/QQ20230127-195003.png" alt="QQ20230127-195003.png"></p><p>根据火焰图，可以看出 freecache 的写入流程中，函数<code>segment.lookup()</code>和<code>Timer.Now()</code>两个函数的耗时时间是比较长的。其中<code>segment.loopup()</code>函数的主要功能是处理哈希冲突，火焰图中大规模出现该函数证明了 freecache 中的哈希函数是略微欠缺打磨的，并且解决哈希冲突时，freecache 需要比较 slice 值，这也是一个性能比较差的地方，即火焰图中的 函数<code>freecache.(*RingBuf).EqualAt</code>。</p><p>另一点，则是<code>Timer.Now()</code>函数的耗时，我们看一下 freecache 中的 Timer 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper function that returns Unix time in seconds</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUnixTime</span><span class="params">()</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">uint32</span>(time.Now().Unix())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default timer reads Unix time always when requested</span></span><br><span class="line"><span class="keyword">type</span> defaultTimer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(timer defaultTimer)</span></span> Now() <span class="type">uint32</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getUnixTime()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每一次 Write 都会使用一次时间戳，所以使用<code>defaultTimer</code>会带来非常严重的性能问题；经过查看源码，作者这里提供了另外一个 <code>cachedTimer</code>，它会缓存一个时间戳，并使用一个 goroutine 维护，每秒钟更新一次；但是并没有将该定时器作为 benchmark 代码中的默认定时器。将定时器修改后，该部分耗时可以忽略不计，这里不再放测试结果。</p><h2 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h2><p>freecache 提供了几个较高性能的用户接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询后将值作为输入调用函数 fn</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *Cache)</span></span> GetFn(key []<span class="type">byte</span>, fn <span class="function"><span class="keyword">func</span><span class="params">([]<span class="type">byte</span>)</span></span> <span class="type">error</span>) (err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不进行拷贝，返回切片在 cache 中的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *Cache)</span></span> GetWithBuf(key, buf []<span class="type">byte</span>) (value []<span class="type">byte</span>, err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gnet 中的一些设计</title>
      <link href="/2023/01/20/gnet-%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/01/20/gnet-%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>gnet 是一个基于 Reactor 模式的高性能 go 网络库，工作原理类似 netty 和 libuv，直接使用 epoll 或 kqueue 系统调用来构建网络应用，这使其有着非常好的性能表现。本文章着重讲在阅读 gnet v2.2.3源码中注意到的一些问题。</p><h2 id="主从-Reactor-通信方式"><a href="#主从-Reactor-通信方式" class="headerlink" title="主从 Reactor 通信方式"></a>主从 Reactor 通信方式</h2><p>主从 Reactor 模式中，主 Reactor 与从 Reactor 模式之间需要通信机制来实现任务的调度。由于主从 Reactor 运行在不同的 goroutine 上，所以很轻松地可以想到使用 channel 进行通信。但是考虑到主 Reactor 与从 Reactor 直接的通信是一读一写的模式，gnet 中使用的是无锁队列的通信机制。这种一读一写的方式是比较经典的无锁队列使用场景了。gnet 中的无锁队列是一个非常经典的实现。</p><p>在学习 gnet 框架的时候，恰好我所写的一个玩具项目中也有类似的场景；因为我尝试模仿 gnet 的做法，将 channel 替换为无锁队列。但是在做出这样的修改后，我发现软件的性能竟然比修改之前要下降了。这让我比较疑惑，于是我测试了 gnet 中无锁队列的性能以及 channel 的性能。测试环境为 Macos Ventura, 双核四线程 CPU，8GB 内存，go 1.19 版本；测试的方法一共有两种，一种是测试写入侧完成写入的耗时，第二种是测试读取侧完成读取的耗时。测试结果如下，其中 channel 的缓冲区选取 1000：</p><table><thead><tr><th align="center">测试编号</th><th align="center">数据量10W</th><th align="center">数据量100W</th><th align="center">数据量500W</th><th align="center">数据量1000W</th></tr></thead><tbody><tr><td align="center">queue 完成写入</td><td align="center">8 ms</td><td align="center">89 ms</td><td align="center">647 ms</td><td align="center">1228 ms</td></tr><tr><td align="center">channel 完成写入</td><td align="center">6 ms</td><td align="center">64 ms</td><td align="center">528 ms</td><td align="center">961ms</td></tr><tr><td align="center">queue 完成读取</td><td align="center">14 ms</td><td align="center">159 ms</td><td align="center">703 ms</td><td align="center">1854 ms</td></tr><tr><td align="center">channel 完成读取</td><td align="center">11 ms</td><td align="center">142 ms</td><td align="center">558 ms</td><td align="center">1414 ms</td></tr></tbody></table><p>根据测试结果，无锁队列的性能确实会比 channel 的性能要低，相同数据量下，使用无锁队列的耗时是使用 channel 耗时的约<strong>1.2倍</strong>左右。</p><p>在得到测试结果后，我以为是我的测试用例有问题，于是花费了很多时间去搜寻资料无果。后来，我尝试替换其他的无锁队列进行测试，于是我选择了<code>github.com/yireyun/go-queue</code>项目进行测试，但测试结果与 gent 中的无锁队列相似，仍然是比 channel 要慢的。于是我开始疑惑，为什么 gnet 中要选择无锁队列来作为消息传递的方式。</p><p>在思考无果后，我又开始查询资料，最终找到了可能的答案。这是 go-queue 项目中的一个 <a href="https://github.com/yireyun/go-queue/issues/13">issue</a>，它指出 go-queue 会比官方的 channel 速度要慢约10%左右，在其中的一个回复中有如下内容：</p><blockquote><h3 id="yireyun-commented-on-Jul-25-2022"><a href="#yireyun-commented-on-Jul-25-2022" class="headerlink" title="yireyun commented on Jul 25, 2022"></a><strong><a href="https://github.com/yireyun">yireyun</a></strong> commented <a href="https://github.com/yireyun/go-queue/issues/13#issuecomment-1193690662">on Jul 25, 2022</a></h3><p>已经在 MacPro M1 基于go1.17.12 上确认了”<strong>Chan 比 Queue 快</strong>”；并没有用之前机器和go版本回归测试，初步结论是 chan 比以前快多了； go1.8.3 的 chan 在高并发情况下，性能会急速下降，但在 go1.17.14 上发现高并发，chan性能下降缓慢。</p></blockquote><p>go-queue 确实是一个四年前的项目，其测试环境为 go1.8.3，这让我回想起在知乎曾经看到的一篇文章，“<a href="https://zhuanlan.zhihu.com/p/21514693">Golang号称高并发，但高并发时性能不高</a>”，里面有这样一段内容：</p><blockquote><p>管道chan吞吐极限10,000,000，单次Put,Get耗时大约100ns/op，无论是采用单Go程，还是多Go程并发(并发数:100, 10000, 100000)，耗时均没有变化，Go内核这对chan进行优化。</p></blockquote><p>而 gnet v2 是基于 go 1.11 开发的，因此我<strong>猜测</strong> gnet 这里的设计可能是因为 channel 在低版本 go 中性能表现较差。而在高版本 go 中，数据量 10W 左右的级别无锁队列与 channel 并没有表现出较大的性能差异，因此这里并没有对其进行修改。毕竟主从 Reactor 之间更多地只会传递 *conn 指针，很难会出现 10W 以上这种级别的新连接同时到达的情况。</p><h2 id="连接管理优化"><a href="#连接管理优化" class="headerlink" title="连接管理优化"></a>连接管理优化</h2><p>这个问题在 gnet 的 <a href="https://github.com/panjf2000/gnet/issues/334">issue</a> 中有提到，目前解决方案还没有加入到正式版本中。gnet 中，每一个从 Reactor 都需要管理分配到的所有连接，为了区分这些连接，gent 目前采用的是哈希表的方式，将每一个连接的 [file descriptor,*conn] 注册到哈希表中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eventloop <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    connCount    <span class="type">int32</span>           <span class="comment">// number of active connections in event-loop</span></span><br><span class="line">    udpSockets   <span class="keyword">map</span>[<span class="type">int</span>]*conn   <span class="comment">// client-side UDP socket map: fd -&gt; conn</span></span><br><span class="line">    connections  <span class="keyword">map</span>[<span class="type">int</span>]*conn   <span class="comment">// TCP connection map: fd -&gt; conn</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种设计在非 GC 语言中可能没有问题，但是在 GC 语言中可能会带来性能问题。GC 扫描对于连续的数据结构是非常快的，但是对于哈希表这种非连续存储的数据结构就会相对较慢。如果使用值存储的形式，哈希表会为键值对分配出一块的连续的内存，而使用指针存储时，值会逃逸到堆上，这样在扫描时就无法采取连续扫描的方式。如果在此基础上，再使用指针来存储比较大的对象，可能会导致扫描哈希表的耗时大大增加。</p><p>由于 gnet 主要面对的是类似 redis 和 HaProxy 的场景，这种场景下应用层的处理时间很短，网络库的性能对软件的整体性能影响非常大。而恰好这种情景都是作为后端的基础架构来使用的，客户端数量可能会非常多。当服务端需要处理的连接数较大时，直接使用哈希表来存储指针可能会造成 GC 耗时增加，从而造成比较严重的性能劣化。</p><p>gnet 后期可能会依据 bigcache 的模式做出优化，将哈希表更改为二级索引的数据结构，从而实现 GC 的线性扫描。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原方案</span></span><br><span class="line"><span class="keyword">map</span>[<span class="type">int</span>]*conn</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化思路，fd 作为索引在哈希表中存储slice下标</span></span><br><span class="line"><span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">// 在 slice 中存储 *conn 指针</span></span><br><span class="line">slice[]*conn</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 计算机网络 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析 CloudWeGo-Netpoll</title>
      <link href="/2023/01/19/%E6%B5%85%E6%9E%90-CloudWeGOnetpoll/"/>
      <url>/2023/01/19/%E6%B5%85%E6%9E%90-CloudWeGOnetpoll/</url>
      
        <content type="html"><![CDATA[<p>CloudWeGo-Netpoll ，以下简称为 Netpoll，是由字节跳动开发的一款<strong>专注于 RPC 场景</strong>的高性能 NIO 网络库。大大多基于多路复用的网络库，基本框架都比较类似。但不同的网络库会针对不同的应用场景对基本框架进行修改，从而使其在固定场景下发挥出更好的性能。本文着重分析 Netpoll 与其他网络库不同的设计，以及这些设计是如何满足 RPC 场景的。</p><h2 id="Netpoll-场景"><a href="#Netpoll-场景" class="headerlink" title="Netpoll 场景"></a>Netpoll 场景</h2><p>RPC 场景，在我的理解中，主要可以由以下几个特点来概括：</p><ul><li>较重的处理逻辑，事务处理中可能会有较长时间的阻塞；</li><li>通常采用短连接或者长连接池的形式；</li><li>具有超时机制，可能会产生较多的失效连接。</li></ul><p>在这种场景下，使用 go 标准网络库开发服务端比较方便，但无法达到较高的性能，这主要来源于 goroutine 的调度开销上。在微服务场景下，服务器之间的交互非常频繁，服务器 A 到服务器 B 之间可能会需要多条 rpc 逻辑连接，如果为这些逻辑连接全部开辟出一条物理连接，会对服务端和客户端都造成比较大的压力。通常，rpc 框架会选择使用多路复用的方式，避免开辟过多的物理连接。但又因为 rpc 依赖链路这种情景，串行处理 rpc 是性能非常低下的。当使用标准网络库时，虽然 rpc 的解析在阻塞 IO 下也可以实现多路复用，但是 rpc 的处理逻辑必须要开辟一个新的 goroutine 来防止队首阻塞。这是因为 rpc 可能是具有依赖链路的。通过分析，我们可以发现，使用 go 标准网络库进行开发，虽然可以避免开辟过多 goroutine 用于解析，但是仍然需要为每一条业务逻辑开辟出一个 goroutine。当 goroutine 过多时，调度器的压力会比较大，造成较大的延迟。</p><p>而 go 语言的一些其他网络库如 gnet，底层会使用 ring_buffer 作为缓冲区（新版本中也可以作为 linked_list 作为缓冲区）来获取更高的性能。由于 ring_buffer 中内存地址是会被复用的，并且生命周期难以被管理，如果应用层的业务逻辑没有阻塞的情况下，可以直接在读事件中的 callback 中完成事件处理（如 redis 的 500us 左右的纯内存操作，HAProxy 的转发操作），那么这种网络框架性能是非常高的，<strong>核心点就是不需要分配内存</strong>。但是在 rpc 场景下，业务的处理逻辑非常重，仍然需要分配内存进行拷贝，防止 ring_buffer 被覆盖，这种框架的优势就没有那么明显了。（当然，可以在业务层自行实现内存池来解决这一问题，不过这相当于把问题抛给了用户）</p><p>综上所述，Netpoll 所要做的，核心有两点：</p><ul><li>实现非阻塞读写，避免开辟过多 goroutine；</li><li>实现生命周期可调控的内存复用，避免分配内存。</li></ul><h2 id="高性能网络库“三板斧”"><a href="#高性能网络库“三板斧”" class="headerlink" title="高性能网络库“三板斧”"></a>高性能网络库“三板斧”</h2><p>各种实现的 Reactor 模式，其高性能主要来自于避免了各种耗时操作，如内存分配、线程开辟、互斥量竞争，几乎所有的高性能网络库都做了以下几点优化：</p><ul><li>Multi-Reactors/Master-Workers 模型，避免 epoll 惊群效应；</li><li>EventLoop 模型的高效运行机制；</li><li>高效的内存管理机制，尽量避免内存分配；</li><li>高性能线程/goroutine池，避免用户手动开辟处理异步逻辑。</li></ul><p>这几点在 Netpoll 中都有涉及，其中内存管理是借助 sync.Pool 和 link_buffer 实现的；高性能协程池则是使用了自家的 <a href="https://github.com/bytedance/gopkg/tree/develop/util/gopool">gopool</a>。</p><h2 id="Reactor-模式实现"><a href="#Reactor-模式实现" class="headerlink" title="Reactor 模式实现"></a>Reactor 模式实现</h2><p>Netpoll 中使用的是主从 Reactor 模式，能够有效地避免 epoll 惊群效应。主从 Reactor 模式实现上的一个细节问题是如何进行 fd 的传递，即系统调用 accept 获得的 fd 如何注册到 Worker Reactor 的 epoll 上。在 muduo 和 gnet 的实现中，都是以队列的形式进行传递；而在 Netpoll 实现中，则是直接在 Master Reactor 线程使用 epoll 系统调用将新到达连接的 fd 注册到 Worker Reactor 上。 </p><p>Netpoll 中处理新连接到达的代码比较分散，这里简述一下调用链：<code>server.OnRead -&gt; connection.init -&gt; connection.onPrepare -&gt; connection.register -&gt; FDOperator.Control -&gt; poll.Control</code></p><p>上述调用链是发生在 Master Reactor 线程中的，这是利用了 epoll 线程安全的特性，当使用 epoll 相关系统调用时会使用自旋锁来保证红黑树结构的线程安全。<code>poll.Control</code>函数会根据输入参数使用不同的系统调用来维护 epoll 的注册表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Control implements Poll.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *defaultPoll)</span></span> Control(operator *FDOperator, event PollEvent) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">var</span> op <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> evt epollevent</span><br><span class="line">*(**FDOperator)(unsafe.Pointer(&amp;evt.data)) = operator</span><br><span class="line"><span class="keyword">switch</span> event &#123;</span><br><span class="line"><span class="keyword">case</span> PollReadable: <span class="comment">// server accept a new connection and wait read</span></span><br><span class="line">operator.inuse()</span><br><span class="line">op, evt.events = syscall.EPOLL_CTL_ADD, syscall.EPOLLIN|syscall.EPOLLRDHUP|syscall.EPOLLERR</span><br><span class="line"><span class="keyword">case</span> PollWritable: <span class="comment">// client create a new connection and wait connect finished</span></span><br><span class="line">operator.inuse()</span><br><span class="line">op, evt.events = syscall.EPOLL_CTL_ADD, EPOLLET|syscall.EPOLLOUT|syscall.EPOLLRDHUP|syscall.EPOLLERR</span><br><span class="line"><span class="keyword">case</span> PollModReadable: <span class="comment">// client wait read/write</span></span><br><span class="line">op, evt.events = syscall.EPOLL_CTL_MOD, syscall.EPOLLIN|syscall.EPOLLRDHUP|syscall.EPOLLERR</span><br><span class="line"><span class="keyword">case</span> PollDetach: <span class="comment">// deregister</span></span><br><span class="line">op, evt.events = syscall.EPOLL_CTL_DEL, syscall.EPOLLIN|syscall.EPOLLOUT|syscall.EPOLLRDHUP|syscall.EPOLLERR</span><br><span class="line"><span class="keyword">case</span> PollR2RW: <span class="comment">// connection wait read/write</span></span><br><span class="line">op, evt.events = syscall.EPOLL_CTL_MOD, syscall.EPOLLIN|syscall.EPOLLOUT|syscall.EPOLLRDHUP|syscall.EPOLLERR</span><br><span class="line"><span class="keyword">case</span> PollRW2R: <span class="comment">// connection wait read</span></span><br><span class="line">op, evt.events = syscall.EPOLL_CTL_MOD, syscall.EPOLLIN|syscall.EPOLLRDHUP|syscall.EPOLLERR</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> EpollCtl(p.fd, op, operator.FD, &amp;evt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当新连接到达时，<code>FDOperator.event == PollReadable</code> 或者 <code>FDOperator.event == PollModReadable</code>，因此该函数会将新到达的 fd 注册到对应的 poll 结构体上。</p><h2 id="Nocopy-Buffer"><a href="#Nocopy-Buffer" class="headerlink" title="Nocopy Buffer"></a>Nocopy Buffer</h2><p>Nocopy Buffer 是 Netpoll 设计的核心内容，连接多路复用、ZeroCopy 优化都是基于 Nocopy Buffer 结构的。</p><h3 id="linkBuffer-数据结构"><a href="#linkBuffer-数据结构" class="headerlink" title="linkBuffer 数据结构"></a>linkBuffer 数据结构</h3><p>Nocopy Buffer 本质上是一个基于链表的无锁读写结构，链表的节点是<code>linkBufferNode</code>数据结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> linkBufferNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    buf      []<span class="type">byte</span>          <span class="comment">// buffer</span></span><br><span class="line">    off      <span class="type">int</span>             <span class="comment">// read-offset</span></span><br><span class="line">    malloc   <span class="type">int</span>             <span class="comment">// write-offset</span></span><br><span class="line">    refer    <span class="type">int32</span>           <span class="comment">// reference count</span></span><br><span class="line">    readonly <span class="type">bool</span>            <span class="comment">// read-only node</span></span><br><span class="line">    origin   *linkBufferNode <span class="comment">// the root node of the extends</span></span><br><span class="line">    next     *linkBufferNode <span class="comment">// the next node of the linked buffer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>linkBufferNode</code>本质上是一个可引用、具有读写标识位的缓冲区，由于单独对读标识位和写标识位操作是可以并发的，所以其是一个单读写可并发的无锁结构。</p><p><code>linkBuffer</code>则是<code>linkBufferNode</code>组成的链表，其数据结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LinkBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    length     <span class="type">int64</span><span class="comment">// 可读长度</span></span><br><span class="line">    mallocSize <span class="type">int</span><span class="comment">// 可写长度</span></span><br><span class="line"></span><br><span class="line">    head  *linkBufferNode <span class="comment">// 链表头部</span></span><br><span class="line">    read  *linkBufferNode <span class="comment">// 读取位置</span></span><br><span class="line">    flush *linkBufferNode <span class="comment">// 写入提交位置</span></span><br><span class="line">    write *linkBufferNode <span class="comment">// 链表尾部</span></span><br><span class="line"></span><br><span class="line">    caches [][]<span class="type">byte</span> <span class="comment">// 从内存池中获取的内存，用于跨 node 读取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>linkBuffer</code>中使用四个标识位来描述当前的读写状态。head 指向链表的头部，head 与 read 节点之间是可以被释放的节点，read 至 flush 节点是当前可读的区域，flush 至 write 节点是当前可以写入的区域。</p><p><img src="/images/link_buffer.png" alt="/images/link_buffer.png"></p><p>flush 节点指向的 node 是渐变的，代表其中一部分区域是可读的，一部分区域是不可读的。因为同一个节点可能会被同时写入和读取。虽然图中未指出，但是 head 与 read 节点也可能重合，可以被安全释放的范围是 [head,read) 。</p><h3 id="Nocopy-体现在哪"><a href="#Nocopy-体现在哪" class="headerlink" title="Nocopy 体现在哪"></a>Nocopy 体现在哪</h3><p>linkBuffer 具有 nocopy 特性，但并非所有的接口都是 nocopy 的。</p><p>linkBuffer 的所有读接口的处理逻辑都是类似的，这些读取操作是否为 nocopy 取决于读取的位置。以 <code>linkBuffer.Next</code>函数为例，分析什么情况读取是不需要拷贝的，代码只保留了用于分析的部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *LinkBuffer)</span></span> Next(n <span class="type">int</span>) (p []<span class="type">byte</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查长度并移动更新 length</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取长度小于一个节点</span></span><br><span class="line">    <span class="keyword">if</span> b.isSingleNode(n) &#123;</span><br><span class="line">        <span class="keyword">return</span> b.read.Next(n), <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于 1k 的内存块进行内存池管理，避免分配大内存</span></span><br><span class="line">    <span class="keyword">if</span> block1k &lt; n &amp;&amp; n &lt;= mallocMax &#123;</span><br><span class="line">        p = malloc(n, n)</span><br><span class="line">        b.caches = <span class="built_in">append</span>(b.caches, p)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pIdx,l <span class="type">int</span></span><br><span class="line">    <span class="comment">// 循环读取不同节点，直到满足需求</span></span><br><span class="line">    <span class="keyword">for</span> ack := n; ack &gt; <span class="number">0</span>; ack = ack - l &#123;</span><br><span class="line">        l = b.read.Len()</span><br><span class="line">        <span class="keyword">if</span> l &gt;= ack &#123;</span><br><span class="line">            pIdx += <span class="built_in">copy</span>(p[pIdx:], b.read.Next(ack))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> l &gt; <span class="number">0</span> &#123;</span><br><span class="line">            pIdx += <span class="built_in">copy</span>(p[pIdx:], b.read.Next(l))</span><br><span class="line">        &#125;</span><br><span class="line">        b.read = b.read.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _ = pIdx</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>linkBuffer.Next</code>函数中的读取一共具有两种情况。第一种情况是读取的长度小于 read node 的剩余可读取长度，在这种情况下并没有使用 copy 操作，而是复制了地址，这种情况下是 nocopy 的；另外一种情况是读取的长度大于 read node 的剩余可读取长度，这时候需要将分散在各个节点的数据拷贝到一起，如果要求的数据过长，甚至可能会发生多次拷贝。为了避免出现多次拷贝的情况，应该设置<code>linkBufferNode.buf</code>的长度大于用户需要读取数据的平均长度。</p><p>另外值得注意的是，函数中还会根据用户要求的长度来决定不同的内存分配策略。当用户需要的长度过大时，会考虑从内存池中获取一块内存，并将这块内存保存在 caches 数组中，再选择合适的时机将内存归还内存池。</p><p>linkBuffer 的写接口只有一部分是 nocopy 的，即<code>linkBuffer.Malloc</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *LinkBuffer)</span></span> Malloc(n <span class="type">int</span>) (buf []<span class="type">byte</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    b.mallocSize += n</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找写入位置，若无位置，则创建新节点</span></span><br><span class="line">    b.growth(n)</span><br><span class="line">    <span class="comment">// 更新标志位</span></span><br><span class="line">    <span class="keyword">return</span> b.write.Malloc(n), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的逻辑也非常简单，就是在链表中找到一个连续的内存区域，然后将该内存区域返回给用户。如果所有的内存区域都不足以写入，那么将分配一个新的节点，该节点大小正好为用户要求的区域。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *LinkBuffer)</span></span> growth(n <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳过只读节点，并且要求剩余可写入空间充足</span></span><br><span class="line">    <span class="keyword">for</span> b.write.readonly || <span class="built_in">cap</span>(b.write.buf)-b.write.malloc &lt; n &#123;</span><br><span class="line">        <span class="comment">// 寻找至最后一个节点后，分配新节点</span></span><br><span class="line">        <span class="keyword">if</span> b.write.next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 新节点的大小正好为用户需求大小</span></span><br><span class="line">            b.write.next = newLinkBufferNode(n)</span><br><span class="line">            b.write = b.write.next</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        b.write = b.write.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>linkBuffer.growth</code>函数很好地封装了分配新节点和寻找内存区域的功能，这个函数还是比较好的。注意到，函数中有一段逻辑是跳过了所有的只读节点，那么什么情况下会出现只读节点呢？linkBuffer 中只读节点只来源于用户的接口函数<code>linkBuffer.WriteDirect</code>。该函数可能会导致用户方的乱序写入，因此可能会出现下图中的情况。</p><p><img src="/images/link_buffer_read_only_area.png" alt="/images/link_buffer_read_only_area"></p><p>用户在获取内存后，首先写入了 node2 中的部分，而 node1 中虽然仍有空白内存，但该内存已经被用户 hold。此时，如果用户又调用了一次写入操作，必须将数据写入到“未写入部分”，因为“待写入部分”后续会被其他写操作覆盖。linkBuffer 实现中的做法是直接将 node1 设置未 readonly 状态，这里的 readonly 并不是完全禁止写入，而是禁止再从该节点上获取位置进行写入，已经获取位置的区域仍然是可以写入的。</p><h3 id="为什么是无锁的"><a href="#为什么是无锁的" class="headerlink" title="为什么是无锁的"></a>为什么是无锁的</h3><p>linkBuffer 可以用作读缓冲或写缓冲，由于每一个 connection 都会被分配到一个 poller 上，在读缓冲区时，poller 底层只会对 poller 进行写入（接收数据），在写缓冲时，只会对 poller 进行读取（发送数据）。所以无论哪种情况下，Netpoller 都保证框架对缓冲区的读写是单线程的，由于读与写操作使用了不同的标志位，因此只要用户可以保证也使用单线程进行读写，就能够保证 linkBuffer 的无锁并发访问。</p><h2 id="连接多路复用"><a href="#连接多路复用" class="headerlink" title="连接多路复用"></a>连接多路复用</h2><p>连接多路复用这个概念是存在于客户端的，服务端中不需要连接多路复用。Netpoll 在客户端实现连接多路复用的基础是非阻塞 IO，而 linkBuffer 则是实现高性能的多路复用手段。同时，由于连接多路复用是协议依赖的，NetPoll 只是提供了多路复用的支持，并在官方 blog 中给出了可行的方案。</p><p><img src="/images/netpoll_multiplexing.png" alt="/images/link_buffer_read_only_area"></p><p>连接多路复用方案包含以下几个要素：</p><ul><li>Virtual Connection：建立在真实连接之上的虚拟连接，具有一个 uuid 用于区分；</li><li>Shared Map：根据 uuid-virtual conn 的方式来存储虚拟连接；</li><li>Dispatcher：用于读取并解析数据包，根据数据包中的 id 选择对应的 Virtual Connection；</li><li>Rpc Protocol：一个支持多路复用的通信协议。</li></ul><p>方案中，一个真实连接能够承载多个虚拟连接。这些虚拟连接都通过一个分发器来间接与读写缓冲区交互，虽然多个虚拟连接可能运行在不同的 goroutine 中，但是读写操作最终只能够由 Dispatcher 来处理，因此 linkBuffer 之上依然是一读或一写，能够保持无锁并发的特性。Dispatcher 在读取数据后，可以不拷贝数据，而是直接返回对应的切片位置，不同虚拟客户端之间操作不同的切片位置，仍然能够保证无锁并发。</p><h2 id="ZeroCopy"><a href="#ZeroCopy" class="headerlink" title="ZeroCopy"></a>ZeroCopy</h2><p>Netpoll 目前并不提供 zero copy 的支持。如果要使用 zero copy 的系统调用，就必须要保证需要发送的数据在被内核拷贝掉网卡没有被释放掉。这对于 Netpoll 的框架来说会比较麻烦，因为 linkBuffer 每一次在进行写入时，会根据写入的字节长度来对内存区域进行释放。被释放的内存会进入可 GC 状态或进入内存池，这两种状态下都不能够保证内存的存活周期。如果想要在解决这个问题，可能需要大幅度修改代码框架。</p><p>NetPoll 的官方博客中有这样一段介绍，我不太能够理解：</p><blockquote><p>于是，字节跳动框架组和字节跳动内核组合作，由内核组提供了同步的接口：当调用 sendmsg 的时候，内核会监听并拦截内核原先给业务的回调，并且在回调完成后才会让 sendmsg 返回。 这使得我们无需更改原有模型，可以很方便地接入 ZeroCopy send。同时，字节跳动内核组还实现了基于 unix domain socket 的 ZeroCopy，可以使得业务进程与 Mesh sidecar 之间的通信也达到零拷贝。</p></blockquote><p>这样是让 <code>sendmsg</code>阻塞直到将内核将内存写入，如果在写入速度比较频繁的情况下，这样会不会导致写入操作被阻塞过长时间。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 计算机网络 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux网络协议栈框架</title>
      <link href="/2023/01/16/linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/01/16/linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>之前学习了很多与计算机网络相关的内容，虽然建立起了比较系统的概念，但是这些概念仅仅停留在模型上；而操作系统中究竟是如何对各种协议进行处理的仍然不是特别清楚。本文主要梳理 linux 内核网络模型的概念，并在此基础上探究一些常用的网络工具是如何实现的，实现在 linux 协议栈的哪个位置。</p><h2 id="linux-内核网络模型"><a href="#linux-内核网络模型" class="headerlink" title="linux 内核网络模型"></a>linux 内核网络模型</h2><p>从功能上，linux 内核可以划分为五个部分，分别是：</p><ul><li>进程管理：主要负责 CPU 的访问，进行 CPU 调度；</li><li>内存管理：主要负责控制内存的访问；</li><li>文件系统：主要负责组织文件系统，实现文件操作；</li><li>设备管理：主要负责控制外部设备；</li><li>网络：主要负责管理网络设备，实现网络协议栈。</li></ul><p>linux 内核的网络部分主要具备两个功能：管理网络设备、实现网络协议栈。管理网络设备对应五层协议中的物理层和数据链路层；实现网络协议栈对应五层协议中的网络层和运输层。在 linux 的网络实现体系中，linux 为了抽象与实现相分离，将内核中的网络部分划分为五个层次：</p><ul><li>系统调用接口：用户空间的访问接口，提供网络功能的统一封装。</li><li>协议无关接口：使用 socket 来实现对网络通信的抽象化，实现 TCP 和 UDP 的统一封装。</li><li>网络协议栈：linux 中各种网络协议的具体实现，处理各种网络协议的逻辑。</li><li>设备无关接口：为网络协议栈提供操作物理设备的统一封装。</li><li>设备驱动程序：负责管理物理网络设备的驱动程序。</li></ul><p><img src="/images/linux-network.png" alt="/images/linux-network.png"></p><p>其中，网络协议栈部分包括数据链路层、网络层、传输层。除南北通信外，linux 内核还提供了东西向通信。在协议栈的数据链路层，linux 提供了 bridge hook，用户可以将同一主机上的不同网卡相互桥接，实现在数据链路层的消息转发。在协议栈的网络层，linux 提供了 route 接口，用于实现 ip 包在不同 host ip 之间的传递。</p><p><img src="/images/linux-stack.png" alt="/images/linux-stack.png"></p><p>虽然一台物理主机上可能会有多个网络设备，但是这些网络设备会共用同一个协议。如果想要使主机上的部分进程不与其他进程共享协议栈，那么就必须借助虚拟化技术来实现网络隔离，如虚拟机技术，虚拟容器技术。这些虚拟技术通常是使用虚拟网卡来实现的。</p><h2 id="重要数据结构"><a href="#重要数据结构" class="headerlink" title="重要数据结构"></a>重要数据结构</h2><p>linux 网络部分中最为重要的数据结构有两个抽象<code>net_device</code>、<code>socket</code>和一个缓冲<code>sk_buff</code>。</p><h3 id="net-device"><a href="#net-device" class="headerlink" title="net_device"></a>net_device</h3><p><code>net_device</code>是所有网络设备的抽象描述，为上层协议栈提供统一的接口，主要两个方面的内容：</p><ul><li>网络设备硬件属性：端口地址、驱动函数、中断函数等；</li><li>网络设备配置信息：ip 地址、子网掩码等。</li></ul><p>这一抽象数据结构实现了协议栈和网络设备的隔离，从而使得虚拟网络设备的实现成为可能。</p><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p><code>socket</code> 是对所有传输层协议的抽象，统一了网络 IO 与文件 IO 操作，它主要实现了应用层与系统协议栈的接口统一、网络与文件访问方式的统一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">socket_statestate;</span><br><span class="line"></span><br><span class="line">kmemcheck_bitfield_begin(type);</span><br><span class="line"><span class="type">short</span>type;</span><br><span class="line">kmemcheck_bitfield_end(type);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span> __<span class="title">rcu</span>*<span class="title">wq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>*<span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span>*<span class="title">sk</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span>*<span class="title">ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建 <code>struct socket</code> 的函数 <code>socket(3)</code>不仅仅可以创建常规的 TCP、UDP 套接字，还可以通过控制协议族来创建 ICMP、甚至 ARP 套接字。经过 socket 的统一封装，这些位于不同层次的协议使用相同的接口被用户调用，向用户隐藏了底层系统的复杂度。<code>struct socket</code>的读写同样是使用了统一的接口来封装收发数据，不同的协议会使用不同的函数写入，也就是每一种 <code>struct socket</code> 最终调用的读写函数是不一样的，如 ICMP 协议在写入时使用的是<code>icmp_send</code>，因此不会经过传输层，而是直接从网络层向下进行网络通信流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 IMCP 套接字，SOCK_RAW 表明为原始网络协议</span></span><br><span class="line"><span class="type">int</span> icmp_fd = ::socket(AF_INET,SOCK_RAW,IPPROTO_ICMP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 ARP 套接字，SOCK_PACKET 表明为链路层协议</span></span><br><span class="line"><span class="type">int</span> arp_df = :: socket(AF_PACKET,SOCK_PACKET,htons(ETH_P_ARP));</span><br></pre></td></tr></table></figure><h3 id="sk-buff"><a href="#sk-buff" class="headerlink" title="sk_buff"></a>sk_buff</h3><p><code>sk_buff</code>结构体作用域整个数据包的处理，它承载着网络包的内容。<code>sk_buff</code>结构体的定义比较长，<a href="https://elixir.bootlin.com/linux/v4.4/source/include/linux/skbuff.h#L476">源码</a>不贴出。主要包括以下几个方面的内容：</p><ul><li>用于实现 <code>sk_buff</code>的双向链表的结构；</li><li>数据的各种指针：head、tail、data、end、user_data；</li><li>长度标识：len、head room、tail room；</li><li>协议报头：各网络协议层的报头；</li><li><code>sock*</code>和<code>dev*</code>：指向对应的 sock 结构体，对应的网络设备；</li><li>控制缓存 <code>char cb[40]</code>：避免每层协议都分配内存，用于每一层临时存储信息；</li></ul><p>linux 中，无论是写入还是读取网络包，都需要借助 <code>sk_buff</code>。在初始化阶段，数据并不会写入缓冲区的首部，而是会预留出一段空间，用于报文头的写入。在解析/生成报文的过程中，<code>sk_buff</code>中的 data 会不断移动，指向下一层级报文的开始位置。为了避免每一个层级额外分配内存，每一个<code>sk_buff</code>内部都预留了 40 字节大小的控制缓存，存储临时信息。这种设计能够在报文的解析和生成过程中避免频繁分配内存，大大降低了内存拷贝的需要。</p><p>更加详细的内容可以参考<a href="https://www.cnblogs.com/tzh36/p/5424564.html">博客文章</a>。</p><h2 id="网络包的读取流程"><a href="#网络包的读取流程" class="headerlink" title="网络包的读取流程"></a>网络包的读取流程</h2><p>本章会从读取网络包的视角来分析 linux 网络部分的各个层级的主要工作，以及操作系统预留的一些 hook 可以用于实现的技术。</p><h3 id="网络设备硬中断"><a href="#网络设备硬中断" class="headerlink" title="网络设备硬中断"></a>网络设备硬中断</h3><p>数据帧被网卡接收前，会先检查数据的完整性，对错误数据包直接丢弃。</p><p>网卡内部具有一段内存区域，该内存区域是以 FIFO 形式来访问的，是网卡和驱动程序的共享内存。但是网卡内部是采用直接寻址的方式，并没有使用虚拟内存映射的方法来访问。当网卡中有数据帧到达时，网卡设备会将数据帧内容拷贝到该内存区域，然后向 CPU 发起一个硬中断，通知 CPU 有数据到达。</p><p>CPU 收到硬中断后，会在 skb 缓冲区分配一个 skb 数据结构，然后从网卡中将数据拷贝到 skb 中（因为网卡中的内存区域很小，很容易被占满），更新网卡状态；从数据帧中提出协议等信息，写入 skb 结构体中，然后向操作系统发出一个软中断。<strong>如果网卡的 FIFO 缓冲区或者 OS 中为网卡开辟的缓冲区被占满，那么数据包就会被直接丢弃，这是丢包的原因之一。</strong></p><h3 id="软中断处理入口"><a href="#软中断处理入口" class="headerlink" title="软中断处理入口"></a>软中断处理入口</h3><p>相较于网络设备硬中断，软中断处理是一个很长的流程，它会负责处理 OS 内存中已经到达的网络数据，并最终将其送入到对应的协议栈位置。</p><p>软中断处理会被调度到硬中断发生的 CPU 上，处理逻辑的入口函数是 <code>net_rx_action</code>。该函数的主要逻辑是遍历系统中的网卡设备，执行被网卡驱动注册的 poll 函数。为了限制单次软中断的运行时间，<code>net_rx_action</code>每次运行时都会被设置一个配额和一个截止时间，当完成配额数量或者超时后，即使没有完成所有的事件，函数也会退出，并等待被下一次中断唤醒。</p><p>另一个比较重要的函数是 <code>netif_receive_skb</code>，该函数是 skb 结构体的分发器，负责根据 skb 结构体的信息将其分发到对应的协议栈上，进行不同的处理。值得一提的是，虽然网络层协议目前很少，但为了考虑拓展性，函数中并没有使用分支的方式判断，而是使用了哈希表来进行查询的。<code>netif_receive_skb</code>同样也是<strong>抓包程序、数据链路层桥接等功能的入口。</strong>在提交至上层协议栈前，会首先根据抓包程序设置的过滤器，将符合条件的数据包复制。如 wireshark 中的 capture filter，就直接对应这一过程，如果不对其进行设置，可能会导致系统的性能下降。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pcap逻辑，这里会将数据送入抓包点。</span></span><br><span class="line">list_for_each_entry_rcu(ptype, &amp;ptype_all, <span class="built_in">list</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pt_prev)</span><br><span class="line">      ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">    pt_prev = ptype;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据链路层桥则是虚拟网卡 TAP 的基础，可以在数据链路层将数据包转发给其他虚拟网卡设备，该技术是基于 hook 函数 <code>netif_receive_skb</code> 的。该函数会调用 rx_handler 来实现不同的功能，每一块宿主网卡都只能注册一个 rx_handler，但是网卡和网卡可以使用链路的方式来注册，从而实现一个宿主网卡上挂载多个虚拟网卡。</p><p>linux tc 是在此阶段被处理的，其中<code>__netif_receive_skb_core</code>处理 tc ingress，<code>dev_xmit</code>处理 tc egress。</p><h3 id="网络层处理"><a href="#网络层处理" class="headerlink" title="网络层处理"></a>网络层处理</h3><p>网络层处理主要会对各种协议进行解析和处理，这一阶段的输入是经过解析后的网络层包。不同协议的包入口函数名为 prococolname_rcv，结束函数为 prococolname_rcv_finish。这一层主要进行路由、NAT、防火墙等操作。</p><h4 id="ip-协议"><a href="#ip-协议" class="headerlink" title="ip 协议"></a>ip 协议</h4><p>ip 网络层的入口为<code>ip_rcv</code>，在这一函数中会对包进行检查，如果该 ip 包经过了分割，会首先将多个分片组装。在完成这些预处理工作后，ip 包会经过路由和 netfilter 的处理流程。可见，netfilter 这种内核防火墙并不会对数据包产生复制，利用其来做网络转发性能会远高于 nginx 等应用层代理。具体的处理流程如下图所示：</p><p><img src="/images/697113-20160228211438679-329472687.jpg" alt="img"></p><p>不难看到，ip 协议的处理流程和 iptables 的四链处理流程是一致的。</p><p>在 linux 的netfilter实现中，使用了<code>ip_conntrack</code>结构体来记录每一个连接的状态，该状态是一个协议无关的状态，主要记录连接src 和 dst 的 ip 以及端口号、连接创建时间、发送字节等信息。ip 层协议栈维护了一个 ip_conntrack 的哈希表，用于记录当前活跃的所有<strong>被追踪</strong>连接。</p><h4 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h4><p>除了 IP 协议，网络层处理还有 ARP 协议、ICMP 协议等，如果这些协议到达网络层后没有更高层次的协议，那么处理就会结束。以 ICMP 协议为例，数据包在到达网络层后会直接在内核态中被处理，不会再进行传递。linux 内核中处理 ICMP 应答的函数是 <code>icmp_rcv()</code>，<a href="https://elixir.bootlin.com/linux/v4.4/source/net/ipv4/icmp.c#L975">源码</a>有 100 行左右，但核心功能比较简单，其主要步骤用文字表述后如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">icmp_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 检验 ICMP 包有效性</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 ICMP 报文类型</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 ICMP 报文消息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 ICMP 报文类型，选择处理函数，应答处理均在内核态运行</span></span><br><span class="line">  success = icmp_pointers[icmph-&gt;type].handler(skb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 结束本次网络包读取</span></span><br><span class="line">  <span class="keyword">if</span> (success)  &#123;</span><br><span class="line">    consume_skb(skb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，函数中会根据报文类型来选择合适的处理函数，处理函数会根据当前系统协议栈的状态来处理 ICMP 请求。即ICMP 的应答报文会在内核态生成，因此 ICMP 报文的读取在网络层就会结束。</p><h3 id="传输层处理"><a href="#传输层处理" class="headerlink" title="传输层处理"></a>传输层处理</h3><p>接收数据包时，传输层处理的主要流程为：解析报文包——( 报文包进入接收队列 )——处理应答。当数据包为用户进程所需时，需要将其加入接收队列，<strong>如果接收队列已满，同样也会导致数据包被丢弃</strong>。</p><h4 id="TCP-部分"><a href="#TCP-部分" class="headerlink" title="TCP 部分"></a>TCP 部分</h4><p>为了控制和管理每个连接，linux 内核中有使用了 TCP_SKB_CB 数据结构来描述 TCP control block，简称 TCB，用于存储单个 tcp 连接的状态。所有的 TCB 以表的形式组织起来，方便查询和修改。TCB 结构只会在 TCP 发送/写入数据、建立/关闭连接时被修改。TCB 主要记录以下部分的内容，<a href="https://elixir.bootlin.com/linux/v4.4/source/include/net/tcp.h#L738">源码</a>较长，这里不贴出：</p><ul><li>连接四元组：TCP 双方 ip、port；</li><li>TCP 状态：SEQ，ACK，连接状态，SACK/FACK 重传等信息；</li><li>进程号：开启 tcp 连接的进程。</li></ul><p>TCP 的所有收发操作都会依据 TCB 的状态来进行调节，而孤儿 socket、RST 包等一些功能也都是基于 TCB 来完成的。如果 ip 层解析后的 tcp 包能够匹配具体的 process，那么就会处理该消息并将内容封装为 tcp_data ，放入 tcp_data 队列中，然后通过 <code>tcp_read</code> 接口来注册 poll、epoll 事件，通知被阻塞的进程。具体的处理流程如下图：</p><p><img src="/images/697113-20160228211142163-1933891846.jpg" alt="697113-20160228211142163-1933891846"></p><p>TCP 中接受消息的处理路径有两条： fast path和 slow path。slow path 是当前 tcp 连接出现异常状况的处理策略，相比 fast path，它需要额外处理紧急指针、乱序数据。tcp 协议栈会使用预测标志的方法来决定使用哪种策略，当满足以下条件时，会使用 fast path：</p><ul><li>无乱序数据和紧急数据</li><li>接收窗口不为 0</li><li>接收缓冲区未耗尽</li></ul><p>当<code>connect</code>系统调用结束、收到第三次握手中 ACK时，tcp 会立刻使用 fast path；当 tcp 从异常中恢复、更新窗口后、可接收缓冲区大小变化时，都会尝试开启 fast path。</p><p>如果不存在相应的 TCB 或 TCB 中对应的进程已经退出，那么协议栈将会进行异常处理，给对端发送 RST 包。当一个进程退出时，会隐式地关闭所有 socket，但是此时连接还没有被正常关闭，因此会出现 TCB 存在，但是对应进程已经不存活的状态。</p><h4 id="UDP-部分"><a href="#UDP-部分" class="headerlink" title="UDP 部分"></a>UDP 部分</h4><p>由于 UDP 是一个无状态协议，相比于 TCP 协议的处理流程，UDP 协议的处理更加简单。linux 协议栈不需要为 UDP 维护状态机模型，只需要解析包后通知用户进程即可。</p><h2 id="网络包的写入流程"><a href="#网络包的写入流程" class="headerlink" title="网络包的写入流程"></a>网络包的写入流程</h2><p>上一章已经讲述了 linux 网络部分的各个模块内容，本章主要讲述的是写入流程中比较特殊的部分。具体的 write flow 则不再阐述。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>TCP 包发送时必须考虑到丢包的情况，因此需要设立重传机制。linux 内核中为每一个 tcp 连接设置了一个以双向链表形式组织的重传队列，在收到对方的 ACK 前，tcp 包都会被保存在队列中，等待触发重传机制时进行调用。</p><p>TCP 重传可以分别超时重传和快速重传（SACK、DACK）两种，其中快速重传是在 TCP 包的接收中处理的，而超时重传则是由内核内部的定时器触发的。每一次 TCP 协议栈进行发包时，会设置一个超时重传定时器，触发时间为 2*RTT；若在定时器超时前收到 ACK，会撤销定时器，否则会在定时器触发时重传 TCP 报文。超时重传中有许多处理细节，可以参考<a href="https://blog.csdn.net/wangquan1992/article/details/109088299">博客</a>。</p><p>除超时重传定时器外，linux 内核的 TCP 协议栈为每一个 TCP 连接维护了一个定时器队列<code>timer_list</code>，存储在<code>sock struct</code> 中。定时器一共具有九种，分别是：超时重传定时器、SYNACK 定时器、Delayed ACK 定时器、Keepalive 定时器、零窗口探测定时器、FIN_WAIT2 定时器、TIME_WAIT 定时器、ER 定时器、尾部丢失探测器；这些定时器是随 sock 结构体一进行初始化的。这些定时器的触发和执行是由内核函数 <code>update_process_times</code>负责的，TCP 协议栈并不会单独开辟内核线程来处理这些定时器，而是采用系统软中断的方式来处理定时器。</p><p>其中 FIN_WAIT2 定时器是用于处理孤儿 socket 的相关动作的。当进程使用系统调用后<code>close</code>，进程不会继续持有 socket ，但是此时 TCP 协议栈尚未能够完成 TCP 的四次握手，这时 socket 会转换为 孤儿 socket，由协议栈负责完成握手；该定时器则是用于记录孤儿 socket 的存活时间的，若该定时器被触发，协议栈将会释放 socket 相关信息。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层中的写入流程有一个点比较特殊，那就是 IP 包在进行封装时需要使用 ARP 协议来获取 MAC 地址。由于这一步骤需要使用目标 IP 作为输入，破坏了下层协议不依赖上层协议数据的原则，所以才会产生 ARP 协议层次的争议。在 OSI 模型中，将 ARP 定义为数据链路层协议；而在 TCP/IP 模型中则将其定义为网络层协议。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>所有的网络包在数据链路层都会通过<code>dev_queue_xmit</code>进入等待队列，操作系统会定期调用<code>xmit_one</code>函数来发送一个或多个数据包至网络设备，每一个网络设备都具有一个等待队列。该等待队列也是一个 hook，可以由用户进行调控。linux 中系统命令 tc(traffic control) 就是利用该 hook 来实现的。默认情况下，该等待队列是一个 FIFO 队列，用户也可以通过配置来实现更加复杂的功能。</p><p><img src="/images/dev_queue.png" alt="/images/dev_quue.png"></p><p>linux 内核在进行入队和出队操作时，使用了两个函数指针，实现了队列的抽象化。在 linux tc 实现中，允许一个抽象队列以树状组织，形成一个队列树。队列树的根节点和非叶子结点是抽象队列基类，不具备任何队列功能，但是具有两个过滤器，用于入队和出队的选择与过滤功能。每一个叶子结点都会维护一个队列实例，可以是 FIFO 队列、随机队列、优先级队列等中的一种。当链路层包需要入队时，会从根节点以入队过滤器指定的策略对链路层包进行分流，最终经过策略选择入队到某一个叶子结点的队列中。当需要出队时，则会根据过滤选择器中设置的优先级选择一个或多个链路层出队。</p><p>默认情况下， 抽象队列中根节点过滤器不设置任何规则，等待队列只设置了一个 FIFO 队列，即不实现任何功能。tc 命令中的队列规程，类别，过滤器其实就分别对应了等待队列实例，等待队列实例的类别，过滤器规则。</p><h2 id="虚拟网络设备"><a href="#虚拟网络设备" class="headerlink" title="虚拟网络设备"></a>虚拟网络设备</h2><p>linux 中许多种类的虚拟网络设备，常见的有 IFB、TUN/TAP、VETH 等，他们都是通过统一的 <code>netif_receive_skb</code> hook 函数来实现的。所有的虚拟网络设备都工作在数据链路层，可以选择与主机共享协议栈，或者选择使用虚拟技术实现新的协议栈。</p><h3 id="Loopback-Interface"><a href="#Loopback-Interface" class="headerlink" title="Loopback Interface"></a>Loopback Interface</h3><p>Loopback Interface 是一个特殊的虚拟网卡，一般作为 lo 网卡挂载在 ip 127.0.0.1上。Loopback Interface 同样工作在数据链路层，发送到虚拟网卡的数据需要先经过传输层和网络层。网卡的 ip 输出函数会直接串联到 ip 输入函数中，中间没有任何缓存。</p><h3 id="IFB"><a href="#IFB" class="headerlink" title="IFB"></a>IFB</h3><p>IFB（中介功能块设备）是IMQ（中介队列设备）的继任者，也是最简单的虚拟网卡，它以 bridge 的形式与其他网卡连接在一起，它不改变数据包的流向。IFB 网卡的设计初衷是为了拓展 linux tc 的功能。</p><p>使用方法可以参考<a href="https://blog.csdn.net/dog250/article/details/40680765">博客</a>。</p><h3 id="TUN-TAP"><a href="#TUN-TAP" class="headerlink" title="TUN/TAP"></a>TUN/TAP</h3><p>TAP/TUN是Linux内核实现的一对虚拟网络设备，TAP工作在二层，TUN工作在三层，Linux内核通过TAP/TUN设备向绑定该设备的用户空间程序发送数据，反之，用户空间程序也可以像操作硬件网络设备那样，通过TAP/TUN设备发送数据。</p><h3 id="VETH"><a href="#VETH" class="headerlink" title="VETH"></a>VETH</h3><p>VETH 网卡是成对出现的，一对 VETH 网卡可以使用两套不同的协议栈，通常用于网络协议栈的隔离。VETH 网卡可以与物理网卡或其他虚拟网卡进行桥接，通过路由规则就可以实现网路的隔离。</p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>NAT 可以分为 DNAT 和 SNAT 两种，由于进行 NAT 操作的主机必须记录转换前与转换后的对应关系，必须要建表来对 NAT 状态进行记录和追踪。但由于 linux 中已经具有链路追踪的功能，为了减少内存占用，linux 中的 nat 实现是依赖于 ip_conntrack 的。在前面的介绍中，提到过位于传输层协议栈，具有一个 ip_conntrack 哈希表，该哈希表就是 linux 中 nat 的实现基础。</p><p>考虑如下的一次 SNAT，源地址为 ip1:port1，目的地址为 ip2:port2，需要转换的地址为 ip3:port3。首先在正向连接中，会创建 origin tuple 和 reply tuple，插入到连接对应的 ip_contrack 结构中，随后修改 reply tuple 中的信息；将修改完成后的两个 tuple 计算哈希值，插入到连接追踪表中。</p><p><img src="/images/linux_nat.png" alt="linux_nat"></p><p>这样，在反向连接中，就可以通过查询连接追踪表来判断是否需要进行 de-SNAT 操作。如本次连接中，可以通过 hash_value2 来查询到对应的 tuple 信息，发现该 tuple 在所属的 ip_conntrack 为 reply tuple，然后根据 origin tuple 中的信息就可以知道如何进行 de-NAT 操作。</p><h2 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h2><p>lvs(linux virtual server)是工作在网络层的一个虚拟服务器，工作在内核态。lvs 是利用 netfilter 的 hook 来实现的，它能够截获指定条件的 ip 包，并将其根据一定的策略转发到其他 linux 主机上，实现服务器的负载均衡。lvs 的工作位置比较特殊，它位于网络层与传输层之间。</p><p><img src="/images/lvs_pos.png" alt="/images/lvs_pos.png"></p><p>在经过网络层的处理之后，数据包会先被 lvs 截获，如果满足 lvs 的匹配条件，那么将会由 lvs 进行处理；若果不满足 lvs 的匹配条件，数据包才会被递交给传输层。由于 lvs 的特殊位置，在下层协议栈以及其他主机的视角中，它是作为一个传输层/应用层设备工作的，所以它被称作是一个“服务器”。但是，由于 lvs 并不真实处理应用层的请求，只是将数据包转发给其他的真实服务器，所以称其是“虚拟的”。lvs 更像是一个虚拟的应用层网关。</p><p>lvs 具有一个虚拟的端口号和虚拟的网络地址，主机外可以像访问应用层服务一样访问 lvs。lvs 使用的网络地址称为 VIP(virtual ip)。由于 lvs 的位置比真实应用层更低，如果 lvs 与真实应用层使用相同的 host:ip，lvs 会截获全部的网络包。</p><p>ipvs 是 lvs 的一种实现，它利用哈希表来实现网络地址的匹配与转发，相比使用网络层的链路处理模式更加高效。ipvs 一共具有三种工作模式：</p><ul><li>NAT 模式：通过 DNAT 实现转发。性能最差，但最灵活，允许 lvs 与 real server 端口号不同；</li><li>DR 模式：通过 MAC 地址实现转发。性能最好，只支持无 ARP 网络，要求相同的 virtual ip。</li><li>IPIP 模式：通过网络隧道实现转发。性能中等，灵活度中等，要求设备支持网络隧道技术，且不保证客户端一定能够收到回包。</li></ul><p>NAT 模式的模型比较简单，不过多介绍。NAT 模式的性能较差主要源自于正向和反向网络包都需要经过 lvs 所在主机的协议栈，但也是因为经过协议栈的原因，可以使用软件来进行各种处理，有最好的灵活性。另外，NAT 模式也是最成熟，风险最小，最常用的模式，k8s 中 ipvs 代理的搭建就是使用的 NAT 模式。</p><p>DR 模式是利用数据链路层的原理来实现转发的。DR 模式要求每一个 RS 都配置一个与 LVS 相同的 VIP，并隐藏该 VIP（外部无法访问），这是为了防止被 ARP 寻址。DR 模式中的 LVS 会将收到的 ip 包中的 MAC 地址根据一定策略修改为 RS 的 MAC 地址。当数据包到达 RS 时，由于 VIP 能够匹配到 RS 中的 VIP，RS 协议栈将会接收该数据包然后处理。DR 需要回包时，由于来包中的 MAC 地址是属于数据包真实发送者的，回包并不会经过 LVS。在具体配置过程中，DR 模式非常复杂并且对网络的拓扑要求会比较高。</p><p>IPIP 模式则是在 LVS 与 RS 之间使用网络隧道进行传输，原始数据包会被包裹一层数据包，相当于原始数据包并没有经过 RS 的协议栈（原始数据包是作为包裹数据包的内容传递的）。所以 RS 的应用层看到的 SRC IP 是真实发送者的，但是网络隧道的存在，在发送回包时其实发送者与 RS 之间并没有建立起数据链路层的通道。如果网络情况比较特殊，即发送者能够与 lvs 通信，但不能与 rs 通信，就会导致返回链路无法成功建立，IPIP 模式失效。</p><p>可以参考该<a href="https://blog.crazytaxii.com/posts/ipvs_the_linux_load_balancer/">博客</a>，其方法已经实验证实有效。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 编译相关内容的记录</title>
      <link href="/2023/01/14/go-%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/01/14/go-%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>本文记录学习到的一些与 go 语言编译相关的内容。</p><h2 id="编译速度"><a href="#编译速度" class="headerlink" title="编译速度"></a>编译速度</h2><p>go 是编译速度比较快的语言之一，主要有以下几个原因，<a href="https://qastack.cn/programming/2976630/how-does-go-compile-so-quickly">参考链接</a>：</p><ul><li>语法较为简单，不允许重载，不需要复杂的语义分析</li><li>使用包管理，而非头文件形式，避免了解析头文件</li><li>不使用虚拟机，编译时不需要加载 VM</li><li>大部分包都使用静态链接的方式</li><li>优化器更为简单，编译期优化较少，同时导致性能一定程度上下降，<a href="https://zhuanlan.zhihu.com/p/550270332">参考链接</a></li></ul><h2 id="编译缓存"><a href="#编译缓存" class="headerlink" title="编译缓存"></a>编译缓存</h2><p>在 C/C++ 中，大型项目的构建往往需要依赖 make 和 CMake 工具来提供编译缓存，以实现增量编译的功能。在 golang 中，从 1.10  版本后编译器支持了编译缓存的功能，可以进行增量构建。编译过程中的缓存文件将会被存放在环境路径 GOCACHE 下。此外，go test 也支持在特定条件下缓存 test 结果，从而加快执行测试的速度。</p><h3 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h3><p><strong>go 语言的增量编译是以 package 为单位的</strong>，一个 package 内任意一个文件的变更都会导致整个 package 以及依赖该 package 的所有 package重新编译 。但是，golang 的文件修改判别依据相比 C/C++ 体系更加合理。在 qt5 中，使用 qmake 进行增量编译时，依赖于文件的修改时间戳，如果只是对文件进行了格式调整，也会导致项目重新编译。而在 golang 中，文件修改的判别依据是文件内容是否改变，<strong>只修改文件的行数、增加注释、删除后恢复内容都不会导致package 重新编译</strong>。</p><p>在 GOCACHE 路径下，执行 tree 命令，可以得到如下输出（截取部分）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go-build % tree</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">├── 00</span><br><span class="line">│   ├── 000d954e953e73d70b0fa00ceaf3c68f3adbb5164e5381754493a4e592ad714f-a</span><br><span class="line">│   └── 0068e9620015a00b938707781ad8b56fdd86fe4a09eeb7802d874bd041f5ad79-a</span><br><span class="line">├── 01</span><br><span class="line">│   ├── 0107518e42b66ffb35a353ffd437cb2a6f448b07ad8fceba401e7bc1692c17e3-d</span><br><span class="line">│   ├── 01126d3106b1aee39e975dcd10a2ac64f170d28ca14b37c8c5e7cec7817e60fd-a</span><br><span class="line">...</span><br><span class="line">└── trim.txt</span><br></pre></td></tr></table></figure><p>可以看到，golang 中使用了内容摘要算法来组织存储，每一个目录下存储的文件名前两位字符都对应着文件夹名称。在编译过程中，go 编译器会将编译后 package 的 .a 文件求取 64 位摘要值，并将其名称命名为”摘要值-a” 的形式，并存储在摘要值前两位对应的文件夹下。</p><h3 id="go-test-缓存"><a href="#go-test-缓存" class="headerlink" title="go test 缓存"></a>go test 缓存</h3><p>在go 1.10中，go test 同样可以被缓存介入，不过需要满足一定的条件，go release note 中给出了缓存介入条件：</p><ul><li>本次测试的执行程序以及命令行（及参数）与之前的一次test运行匹配；</li><li>上次测试执行时的文件和环境变量在本次没有发生变化；</li><li>测试结果是成功的；</li><li>以package list mode运行测试；</li><li>go test的命令行参数使用”-cpu, -list, -parallel, -run, -short和 -v”的一个子集时。</li></ul><p>其中 package list mode 是指运行某个 package 的测试程序，而不是以当前目录为参数。</p><h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>go build 工具链是支持交叉编译的，在不直接调用 C 代码的情况下，可以直接使用 go build 命令来完成交叉编译。在使用交叉编译时，需要通过变更 GO ENV 来控制编译输出。常用的环境变量如下：</p><ul><li>CGO_ENABLE：关闭 CGO 选项，需要关闭，因为交叉编译不支持 CGO；</li><li>GOOS：编译的目标操作系统，如 linux、darwin、windows；</li><li>GOARCH：编译的架构，如 386、amd64、arm。</li></ul><p>交叉编译示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">x86_64 linux</span></span><br><span class="line">CGO_ENABLED=0 </span><br><span class="line">GOOS=linux </span><br><span class="line">GOARCH=amd64 </span><br><span class="line">go build main.go</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">x86_64 Windows</span></span><br><span class="line">CGO_ENABLED=0</span><br><span class="line">GOOS=windows </span><br><span class="line">GOARCH=amd64 </span><br><span class="line">go build main.go</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arm Macos</span></span><br><span class="line">CGO_ENABLED=0 </span><br><span class="line">GOOS=darwin </span><br><span class="line">GOARCH=arm </span><br><span class="line">go build main.go</span><br></pre></td></tr></table></figure><p>如果在项目中依赖了 C 代码，则不能够使用 go build 工具来实现交叉编译，需要要借助第三方工具 xgo。</p><h2 id="编译期赋值"><a href="#编译期赋值" class="headerlink" title="编译期赋值"></a>编译期赋值</h2><p>go 语言可以实现在编译时对变量赋值，以完成在代码中增加版本等信息。该功能需要借助 -ldflags 选项。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">  <span class="keyword">var</span> version = <span class="string">&quot;v0.0.0&quot;</span></span><br><span class="line">  buildTime <span class="type">string</span></span><br><span class="line">  buildVersion <span class="type">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>直接使用 -ldflags 选项即可，不需要再借助 flag parse。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go build -ldflags \ </span><br><span class="line">&quot;-X main.version=v0.0.1 -X main.dateTime=`date +%Y-%m-%d,%H:%M:%S` -X main.gitTag=`git tag`&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出值</span></span><br><span class="line">version is: v0.0.1</span><br><span class="line">dateTime is: 2023-01-14,22:18:54</span><br><span class="line">gitTag is: v0.0.0-beta</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是通过将值写入符号表来完成的，符号表用来存储程序中的标识符（即常量和变量的类型、值等相关数据）。go 语言编译期过程可以简化理解为：在编译期将部分的变量的值修改，相当于改变了变量的默认值。</p><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>go 语言中不支持 define，但是可以依赖<code>build tags</code>或文件后缀的方式来实现不同平台的条件编译。</p><h3 id="build-tags"><a href="#build-tags" class="headerlink" title="build tags"></a>build tags</h3><p>build tags 是一种特殊的注释，它必须位于 package 声明的上方，并且后跟一个空行。当一个包被编译时，编译器会根据构建标签的内容来判断该包是否需要编译。</p><p>build tags 可以指定以下内容：</p><ul><li>操作系统，环境变量中<code>GOOS</code>的值；</li><li>操作系统的架构，环境变量中<code>GOARCH</code>的值；</li><li>使用的编译器，<code>gc</code>或者<code>gccgo</code>；</li><li>是否开启CGO，<code>cgo</code>；</li><li>golang版本号， 如<code>go1.1</code>；</li><li>其它自定义标签，通过<code>go build -tags</code>指定的值。</li></ul><p>以下为 build tags 的一个例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build linux darwin</span></span><br><span class="line"><span class="comment">// +build x86</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> os</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>build tags 需要遵循以下原则：</p><ul><li>每一行注释以<code>+build</code>开始；</li><li>每个选项由数字和字母组成，如果开头为<code>!</code>代表反义；</li><li>选项之间相隔<code>&#39; &#39;</code>代表或关系，选项之间相隔<code>,</code>代表与关系；</li><li>不同行注释代表与关系</li></ul><p>上面示例中代表在 linux 或 darwin 平台且架构为 x86 的情况下才会编译。</p><h3 id="文件名后缀"><a href="#文件名后缀" class="headerlink" title="文件名后缀"></a>文件名后缀</h3><p>类似测试文件的 <code>_test</code>后缀，go 语言中也可以通过添加后缀的方式来实现条件编译。文件名后缀的命名方式为：<code>filename(_$GOOS)(_$GOARCH).go</code>。其中 GOOS 如果出现，必须排列在 GOARCH 前面。</p><p>文件名后缀只能够实现在特定条件下进行编译，而不能实现在特定条件下取消编译。</p><h2 id="Go-Plugin"><a href="#Go-Plugin" class="headerlink" title="Go Plugin"></a>Go Plugin</h2><p>参考<a href="https://www.easemob.com/news/6987">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kfifo 优雅的无锁队列实现</title>
      <link href="/2023/01/13/kfifo-%E4%BC%98%E9%9B%85%E7%9A%84%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/01/13/kfifo-%E4%BC%98%E9%9B%85%E7%9A%84%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>kfifo 是 linux kernel 中一个简介优雅的无锁 ring_buffer 实现，能够保证在单线程写入和读线程读取场景下的线程安全。kfifo 的实现中使用了许多比较特殊的操作，值得进行学习。</p><h2 id="kfifo-数据结构"><a href="#kfifo-数据结构" class="headerlink" title="kfifo 数据结构"></a>kfifo 数据结构</h2><p>kfifo 的数据结构非常简单，只有缓冲区指针及大小、读取写入偏移量，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> &#123;</span></span><br><span class="line">  <span class="comment">// 写入 offeset</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>in;</span><br><span class="line">  <span class="comment">// 读取 offset</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>out;</span><br><span class="line">  <span class="comment">// 缓冲区大小</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>size;</span><br><span class="line">  <span class="comment">// 缓冲区指针</span></span><br><span class="line">  <span class="type">void</span>*buffer;</span><br><span class="line">  <span class="comment">// 自旋锁，新版本已经移出</span></span><br><span class="line">  <span class="type">spinlock_t</span> *lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>kfifo 实现巧妙之处主要有三点：</p><ul><li>通过位运算判断 2 的幂以及向上取整为 2 的幂；</li><li>不进行模运算，而是利用溢出来实现读写偏移量计算；</li><li>使用内存屏障来保障单消费者、单生产者的无锁并发访问。</li></ul><h2 id="位运算部分"><a href="#位运算部分" class="headerlink" title="位运算部分"></a>位运算部分</h2><p>kfifo struct 中，要求缓冲区大小必须为 2 的幂，这是为了更加高效地判断计算出当前偏移量对应的内存位置。在 kfifo 初始化阶段，通过两个巧妙的位运算解决了判断 2 的幂以及向上取整为 2 的幂两个问题。</p><h3 id="判断一个数是否为-2-的幂"><a href="#判断一个数是否为-2-的幂" class="headerlink" title="判断一个数是否为 2 的幂"></a>判断一个数是否为 2 的幂</h3><p>在二进制存储中，如果一个数 n 是 2 的幂，那么这个数可以表示为 100···，除最高位外全部为 0。同样地，n-1 就可以表示为 0111…，除最高位外全部为 1。可以观察到 n 和 n-1 在二进制中，每一位都是相反的，因此 <code>n &amp; (n - 1) == 1</code>。可以根据这种操作来利用位运算更快地判断一个数是否为 2 的幂。linux kernel 中的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">is_power_of_2</span><span class="params">(<span class="type">uint32_t</span> n)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (n != <span class="number">0</span> &amp;&amp; ((n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将一个数取整为-2-的幂"><a href="#将一个数取整为-2-的幂" class="headerlink" title="将一个数取整为 2 的幂"></a>将一个数取整为 2 的幂</h3><p>linux kernel 中的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求大于一个数的 2 的幂次数</span></span><br><span class="line"><span class="type">static</span> __inline__ <span class="type">int</span> <span class="title function_">generic_fls</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">  <span class="type">int</span> r = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 x 是否为 0</span></span><br><span class="line">  <span class="keyword">if</span> (!x)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 判断最高八位是否有 1</span></span><br><span class="line">  <span class="keyword">if</span> (!(x &amp; <span class="number">0xffff0000</span>u)) &#123; </span><br><span class="line">    <span class="comment">// 如果没有 1，则左移</span></span><br><span class="line">    x &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">    r -= <span class="number">16</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 若上一次有 1，由于没有左移，因此是判断最高四位是否有 1</span></span><br><span class="line">  <span class="comment">// 若上一次没有 1，判断的则是后八位中的前四位</span></span><br><span class="line">  <span class="keyword">if</span> (!(x &amp; <span class="number">0xff000000</span>u)) &#123;</span><br><span class="line">    x &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">    r -= <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(x &amp; <span class="number">0xf0000000</span>u)) &#123;</span><br><span class="line">    x &lt;&lt;= <span class="number">4</span>;</span><br><span class="line">    r -= <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(x &amp; <span class="number">0xc0000000</span>u)) &#123;</span><br><span class="line">    x &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">    r -= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(x &amp; <span class="number">0x80000000</span>u)) &#123;</span><br><span class="line">    x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    r -= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求大于一个数的 2 的幂</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> __attribute_const__ <span class="title function_">roundup_pow_of_two</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1UL</span> &lt;&lt; generic_fls(x - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这本质上是利用二分查找的原理，使用状态机的一种实现。主要的巧妙之处是利用了左移操作将每一次二分查找的分支进行了合并，使得代码变得更为简洁。</p><h2 id="利用溢出实现读写偏移量计算"><a href="#利用溢出实现读写偏移量计算" class="headerlink" title="利用溢出实现读写偏移量计算"></a>利用溢出实现读写偏移量计算</h2><p>对一个数取模，从而使其保持在一定范围内，是常见的操作数组、缓冲区等长度固定数据结构的操作。但相对来说，取模的运算速度会相对较慢。kfifo 为了实现更快的偏移量计算，并没有使用取模操作，而是使用位运算使长度溢出来实现的。</p><p>以写入为例，该部分的核心代码可以简化为（将部分进行了聚合处理）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __kfifo_get(<span class="keyword">struct</span> kfifo *fifo,</span><br><span class="line">                         <span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> l;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以写入的最大长度，由于 fifo-&gt;in 只会增长，即使有线程写入</span></span><br><span class="line">  <span class="comment">// 也只会导致可读区域变大，因此 len 是安全的</span></span><br><span class="line">  len = min(len, fifo-&gt;in - fifo-&gt;out);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内存屏障</span></span><br><span class="line">  smp_mb();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读当前位置到缓冲区末尾的数据</span></span><br><span class="line">  l = min(len, fifo-&gt;size - (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)));</span><br><span class="line">  <span class="built_in">memcpy</span>(buffer, fifo-&gt;buffer + (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)), l);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从缓冲区头读取剩余数据</span></span><br><span class="line">  <span class="built_in">memcpy</span>(buffer + l, fifo-&gt;buffer, len - l);</span><br><span class="line"></span><br><span class="line">  fifo-&gt;out += len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先忽略内存屏障，这里用到了几个小技巧。由于写入和读取的偏移量 <code>kfifo-&gt;in</code> 和 <code>kfifio-&gt;out</code> 都是无符号整形，即使 <code>kfifo-&gt;in</code>因为过大而发生了溢出，也能够保持<code>kfifo-&gt;in - kfifio-&gt;out &lt;= kfifo-&gt;size</code>。 因为 unsigned long类型的加减是回环的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m 是 unsigned long 最大值</span></span><br><span class="line">m := <span class="type">uint64</span>(<span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">println</span>(m + <span class="number">5</span> - m)<span class="comment">// 输出为 5</span></span><br></pre></td></tr></table></figure><p>另外一个比较巧妙的地方是，没有使用取模来计算偏移量，而是修改为了位运算的方式，这依赖于 kfifo 的缓冲区大小限定为 2 的幂。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统取模方式</span></span><br><span class="line"><span class="type">int</span> offset = kfifo-&gt;in % kfifo-&gt;size</span><br><span class="line"> </span><br><span class="line"><span class="comment">// kfifo 取模方式</span></span><br><span class="line"><span class="type">int</span> offset = kfifo-&gt;in &amp; (kfifo-&gt;size - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在二进制中，kfifo-&gt;size 可以表示为 1000···，那么 kfifo-&gt;size - 1 就可以表示为 0111···；同样地，kfifo-&gt;in 也可以分解为 offset + n2，其中 n2 是 kfifo-&gt;size的倍数，offset 是 kfifo-&gt;in % kfifo-&gt;size。由于 n2 是 kfifo-&gt;size 倍数，所以其数据只分布在大于 kfifo-&gt;size 位数的部分，因此只需要截取 kfifo-&gt;in 小于 kfifo-&gt;size 位数的部分，就可以得到 offset。观察到，kfifo-&gt;size - 1在每一个小于 kfifo-&gt;size 的位上的值均为 1，那么只要进行运算 kfifo-&gt;in % kfifo-&gt;size ，超出 kfifo-&gt;size 位数的部分会被截去，而小于 kfifo-&gt;size 位数的部分会被保留，即得到 offset。</p><p>还有一个比较巧妙的点是没有使用 if 进行判断，直接使用了两个memcpy。这里是直接利用 memcpy 的第三个参数进行了控制，当第一次 memcpy 完全拷贝时，第二次 memcpy 将不进行任何操作。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>在计算机操作系统中，一个读线程和一个写线程同时操作一个变量时不需要进行加锁的。在 kfifo 中，读操作与写操作分别只会更新 kfifo-&gt;out 和 kfifo-&gt;in，因此不会出现并发问题。</p><p>但是，参考《C++并发编程实践》第 123 页：“无论对象是怎么样的类型，对象都会存储在一个或多个内存位置上。每个内存位置不是标量类型的对象，就是标量类 型的子对象，比如，unsigned short、my_class*或序列中的相邻位域。当使用位域时就需要注意：虽然相邻位域 中是不同的对象，但仍视其为相同的内存位置。如图5.1所示，将一个struct分解为多个对象，并且展示了每个对象 的内存位置。”如下图，bf1 和 bf2 被保存在相同的位置。</p><p><img src="/images/image-20230113062116997.png" alt="image-20230113062116997"></p><p>这种情况下，bf1 和 bf2 可能会有多个副本分别存储在不同 CPU 的 Cache 中，如果线程 th1 写入 bf1 的同时线程 th2 读取bf2，那么 th2 可能会读取到在 CPU Cache 中的过期数据。由于 kfifo 中的成员都是基本类型，它们很有可能会被存储在相同的内存位置，因此需要引入内存屏障来保证以下写入顺序：</p><ul><li>kfifo-&gt;data 写入数据；</li><li>更新 kfifo-&gt;in 值。</li></ul><p>这也就是读取和写入操作中<code>  smp_mb()</code>的作用，用于强制保证内存的更新是全局的。</p><h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h2><ul><li>头文件：<a href="https://github.com/torvalds/linux/blob/master/include/linux/kfence.h">https://github.com/torvalds/linux/blob/master/include/linux/kfence.h</a></li><li>源文件：<a href="https://github.com/torvalds/linux/blob/master/lib/kfifo.c">https://github.com/torvalds/linux/blob/master/lib/kfifo.c</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Context 与超时控制</title>
      <link href="/2023/01/12/Context-%E4%B8%8E%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/"/>
      <url>/2023/01/12/Context-%E4%B8%8E%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Context-与超时控制"><a href="#Context-与超时控制" class="headerlink" title="Context 与超时控制"></a>Context 与超时控制</h1><p>Context 是 go 语言中监控与控制 goroutine 的一种方式，它可以在协程之间进行信息的传递，从而控制 goroutine 的行为。在一定程度上，可以将 context 看作包含一部分输入参数的 channel。与 channel 不同的是，channel 的传递并不是递归的，当一个 goroutine 调用的 goroutine 再次调用了 goroutine，简单使用 channel 进行退出通知是非常麻烦的；而使用 context 则能很轻松地使用递归的 goroutine 控制。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>context 在 go 语言中是一个接口，在此基础上可以衍生出不同的类型的 context，sdk 中提供了六种方法来获取不同类型的 context 以适用于不同的场景，可以概括为：</p><ul><li>两个接口：context、canceler</li><li>四种实现：emptyCtx、cancelCtx、timerCtx、valueCtx</li><li>六个方法：Background、TODO、WithCancel、WithDeadline、WithTimeout、WithValue</li></ul><h3 id="两个接口"><a href="#两个接口" class="headerlink" title="两个接口"></a>两个接口</h3><p>在 go sdk 中，context 和 canceler 接口定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 返回 context 的截止时间</span></span><br><span class="line">  Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">  <span class="comment">// 返回只读 channel，用于接收 context 是否完成</span></span><br><span class="line">  Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 返回 context 被取消的原因</span></span><br><span class="line">  Err() <span class="type">error</span></span><br><span class="line">  <span class="comment">// 返回 key 对应的 value</span></span><br><span class="line">  Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 取消方法</span></span><br><span class="line">  cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">  <span class="comment">// 返回只读 channel</span></span><br><span class="line">  Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这两种接口的基础上，sdk 实现了四种不同的基础 context，用户同样可以利用这些 context 来自行实现。</p><h3 id="四种实现"><a href="#四种实现" class="headerlink" title="四种实现"></a>四种实现</h3><p>在 context 和 canceler 接口的基础上，go sdk 包含了四种基础 context 实现。</p><h4 id="emptyCtx"><a href="#emptyCtx" class="headerlink" title="emptyCtx"></a>emptyCtx</h4><p>emptyCtx 的所有方法均为空方法，主要用于作为基础上下文，并衍生出其他上下文。由于 goroutine 的调用是树状的，因此 context 的组织形式也是树状的，一颗 context 树，其根节点应当是一个 emptyCtx 类型。</p><p>sdk 提供了 Background 和 TODO 两种 emptyCtx，两者互为别名，只是在语义上有所不同：</p><ul><li>context.Background 是上下文的默认值，所有其他的上下文都应该从它衍生出来；</li><li>context.TODO 应该仅在不确定应该使用哪种上下文时使用；</li></ul><p>一般情况下，会在一个模块的 main goroutine 使用 Background context；当想从一个叶 context 节点从派生出一个新的 context 叶时，可以选择使用 TODO。</p><h4 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h4><p>cancelCtx 是一个具备取消功能的 context，在父 goroutine 中可以使用 cancel 函数来通知 goroutine 进行取消。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父 goroutine 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parent</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取 context</span></span><br><span class="line">  ctx, cancel := context.WithCancel(context.Background(), time.Millisecond*<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    children(ctx)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知取消</span></span><br><span class="line">  cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">children</span><span class="params">(c *context.Context)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span>&#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;- c.Done():</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cancelCtx 可以用于用户交互等场景的控制，自由度比较高。</p><h4 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h4><p>timerCtx 主要通过两种方法来获得：WithDeadline、WithTimeout。不同之处就是一个是明确截止时间，一个是明确运行时间，使用方法与 cancelCtx 非常相似，也同样提供了 cancel 接口，用户可以手动进行取消，或等待设置的时间到期后自动取消。</p><p>timerCtx 是通过 timer.AfterFunc 来实现的，核心代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 设置定时器，当定时器到期后，自动调用取消函数</span></span><br><span class="line">    c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h4><p>valueCtx 提供了在不同 goroutine 之间利用 context 进行值传递的功能，可以使用 context 来进行链路追踪。valueCtx 只能够将值传递给子 goroutine，而不能够实现反向操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父 goroutine 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parent</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取 context</span></span><br><span class="line">  ctx := context.WithValue(context.Background(), <span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    children(ctx)</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">children</span><span class="params">(c *context.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 在子 goroutine 中获取值</span></span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;context key:&quot;</span>,c.Value(<span class="string">&quot;key&quot;</span>).(<span class="type">string</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不同-context-的混合使用"><a href="#不同-context-的混合使用" class="headerlink" title="不同 context 的混合使用"></a>不同 context 的混合使用</h3><p>用户可以将 sdk 中提供的六种方法混合使用，来构造较为复杂的 context，利用使用带有超时控制的值 context：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取超时</span></span><br><span class="line">withTimeout, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 加入值传递</span></span><br><span class="line">ctx := context.WithValue(withTimeout, <span class="string">&quot;traceId&quot;</span>, <span class="string">&quot;id12345&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Context-使用场景"><a href="#Context-使用场景" class="headerlink" title="Context 使用场景"></a>Context 使用场景</h2><p>context 可以很轻松地完成消息在 goroutine 中的传递，但是不能够直接完成对 goroutine 的控制，而是需要用户自行完成接收通知的逻辑，也就是这是一种侵入式比较强的消息传递方式。但由于这是在 go sdk 中提供的一种标准控制方式，所以其应用场景非常广，一些开源的工具包中基本上都提供了包含 context 的实现，使用起来会相对简单。</p><p>一般情况下，在下一级逻辑中，需要使用定时器和 select 来完成对 context 超时的读取，或者是使用 context 中的截止时间，不使用ctx.Done 函数完成超时控制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mongo-driver session.go</span></span><br><span class="line"><span class="comment">// 不使用 ctx.Done() 完成控制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// timeout 定时事件为 context deadline</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-timeout.C:</span><br><span class="line">    <span class="keyword">return</span> res, err</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// default 自旋，防止被阻塞</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> res, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论哪一种方式，使用 context 来完成超时控制都是需要使用 for - select 循环来处理的，对于网络 IO、信号阻塞等对 CPU 占用比较少的情景，使用 context 是非常合适的。但是如果使用 context 来处理一些比较重型的任务，就显得不是特别合适，因为不能够直接在任务中去执行检查。这种情况下，可以考虑使用状态机来将任务进行分解，每一个阶段来完成后检查一次是否超时。</p><h2 id="另一种超时控制"><a href="#另一种超时控制" class="headerlink" title="另一种超时控制"></a>另一种超时控制</h2><p>使用 context 进行超时控制是侵入式的，可能会破坏代码逻辑，增加维护的难度。最主要的是，当需要调用的代码并没有提供 context 接口时，无法使用 context 来完成控制逻辑。<strong>这种情况下，是无法完成对 goroutine 的调度的，只能够完成在逻辑上的退出，即上一层逻辑提前完成并放任下一层逻辑继续运行直至退出</strong>。这种情况下，可以使用 goroutine 来完成非侵入式的超时控制。gin-contrib 中的 timeout 中间件就是一个很好的例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码截自 gin-contrib/timeout@v0.0.3/timeout.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(opts ...Option)</span></span> gin.HandlerFunc &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开辟缓冲区，存储下一层逻辑返回值</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 goroutine 处理下一层逻辑</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理下一层逻辑中抛出的 panic</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        panicChan &lt;- p</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 处理下一层逻辑</span></span><br><span class="line">    t.handler(c)</span><br><span class="line">    <span class="comment">// 等待下一层逻辑完成</span></span><br><span class="line">    finish &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 处理下一层逻辑抛出的 panic</span></span><br><span class="line">    <span class="keyword">case</span> p := &lt;-panicChan:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 处理下一层逻辑完成</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-finish:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 default 返回值和 error:timeout 返回</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理超时</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(t.timeout):</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用下一层逻辑的返回值返回</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，源码中并没有去调度下一层逻辑的 goroutine，而是在超时后直接使用 default 值并抛出一个错误来完成退出。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这两种方法显然都不是特别完美，但是 goroutine 的调度机制决定了，一个 goroutine 只能够自行退出。这种调度方式是最符合 goroutine 的使用逻辑的，一个 goroutine 内必须是一个完整的状态机来处理逻辑，直接 abort 一个 goroutine 会大大增加状态的不确定性，这是一个非常危险的操作。</p><p>timeout 本身就是非常危险的，如果在操作一个有状态的程序，无法通过 timeout 来确定程序的状态。因此，需要避免在不需要进行用户交互的代码层级使用超时错误，并避免超时错误传递到数据库层级。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 中的 IO 操作</title>
      <link href="/2023/01/10/go-%E4%B8%AD%E7%9A%84-IO-%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/01/10/go-%E4%B8%AD%E7%9A%84-IO-%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="go-中的-IO-操作"><a href="#go-中的-IO-操作" class="headerlink" title="go 中的 IO 操作"></a>go 中的 IO 操作</h1><p>go 语言的官方库中对所有的文件描述符都做了统一的封装，无论是 socket 文件还是普通文件，都包含了<code>poll.FD</code>数据结构，并被 pollDesc 统一管理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通文件描述符</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">  pfd         poll.FD</span><br><span class="line">  name        <span class="type">string</span></span><br><span class="line">  dirinfo     *dirInfo <span class="comment">// nil unless directory being read</span></span><br><span class="line">  nonblock    <span class="type">bool</span>     <span class="comment">// whether we set nonblocking mode</span></span><br><span class="line">  stdoutOrErr <span class="type">bool</span>     <span class="comment">// whether this is stdout or stderr</span></span><br><span class="line">  appendMode  <span class="type">bool</span>     <span class="comment">// whether file is opened for appending</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket 描述符</span></span><br><span class="line"><span class="keyword">type</span> netFD <span class="keyword">struct</span> &#123;</span><br><span class="line">  pfd poll.FD</span><br><span class="line"></span><br><span class="line">  <span class="comment">// immutable until Close</span></span><br><span class="line">  family      <span class="type">int</span></span><br><span class="line">  sotype      <span class="type">int</span></span><br><span class="line">  isConnected <span class="type">bool</span> <span class="comment">// handshake completed or use of association with peer</span></span><br><span class="line">  net         <span class="type">string</span></span><br><span class="line">  laddr       Addr</span><br><span class="line">  raddr       Addr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种文件类型的读写操作都会最终调用 <code>poll.FD</code>的读写函数，以文件描述符的读操作为例，最终会调用以下函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read implements io.Reader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 检查、加锁、准备操作</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 忽略 EINTR 错误，并尝试进行读取</span></span><br><span class="line">    n, err := ignoringEINTRIO(syscall.Read, fd.Sysfd, p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      n = <span class="number">0</span></span><br><span class="line">      <span class="comment">// 如果读取失败，错误为 EAGAIN，且 fd 被注册到了多路复用管理器中</span></span><br><span class="line">      <span class="comment">// 主动进入阻塞状态，并等待被唤醒</span></span><br><span class="line">      <span class="keyword">if</span> err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() &#123;</span><br><span class="line">        <span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    err = fd.eofError(n, err)</span><br><span class="line">    <span class="keyword">return</span> n, err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数处理读取的主要逻辑为：尝试非阻塞读取——如果读取成功则返回/读取失败则进入阻塞。该函数的处理逻辑其实已经对普通文件和 socket 文件进行了分流，普通文件的读写通常是不会进入阻塞状态的，通常会在第一次读取时返回。而 socket 类型的文件描述符，在尝试读取失败后，会进入到 <code>fd.pd.waitRead(fd.isFile)</code>，最终调用<code>runtime_pollWait</code> 函数，将当前 goroutine 的标识为更改为阻塞状态。</p><p>go 语言中，虽然 IO 底层使用了非阻塞的多路复用，但最终提交给用户是阻塞调用的模式。非阻塞多路复用只是为了给 goroutine 提供调度——当一个协程发现自身不能满足执行条件时，得以能够主动修改自身状态，使自身进入到协程的阻塞状态，而不是被操作系统进行线程调度，使线程进入阻塞。用户态的阻塞 IO 是为了配合 goroutine 的调度机制和 go 语言的编程逻辑，即采用多个 goroutine 来处理并行的请求。这样程序在编写过程中就只要考虑请求的执行顺序，如果执行过程中遇到条件不满足的情况，直接进入阻塞并等待被唤醒。</p><p>如果需要在 go 中使用非阻塞 IO，那么可能就需要抛弃官方库所构建出的高层次抽象，这其实更像是在写 C/C++程序。go 语言在 package unix 中提供了比较底层的 unix 标准函数封装，用户可以在此基础上自行搭建非阻塞 IO 模型来满足特定场景下的需求。</p><p>如果需要调用底层的 package unix，一定要将 fd 设置为非阻塞的方式。因为操作系统的是无法感知到 goroutine 的，如果使用阻塞操作，可能会导致 M 被操作系统调度，导致无法进行 G 调度，导致 goroutine 正常切换调度收到影响。fd 的非阻塞已经在 package unix 中封装完毕，为了与 unix 函数保持一致，unix 包中的函数都没有自动设置为非阻塞状态，需要用户手动设置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非常经典的设置非阻塞，简直跟 C++ 一模一样</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetNonblock</span><span class="params">(fd <span class="type">int</span>, nonblocking <span class="type">bool</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">  flag, err := fcntl(fd, F_GETFL, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> nonblocking &#123;</span><br><span class="line">    flag |= O_NONBLOCK</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    flag &amp;= ^O_NONBLOCK</span><br><span class="line">  &#125;</span><br><span class="line">  _, err = fcntl(fd, F_SETFL, flag)</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>channel 与 select 的一些记录</title>
      <link href="/2023/01/10/channel-%E4%B8%8E-select-%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/01/10/channel-%E4%B8%8E-select-%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="channel-与-select-的一些记录"><a href="#channel-与-select-的一些记录" class="headerlink" title="channel 与 select 的一些记录"></a>channel 与 select 的一些记录</h1><p>本篇文章用于记录本人学习到的与 channel 与 select 有关的一些知识。</p><h2 id="CSP-并发模型"><a href="#CSP-并发模型" class="headerlink" title="CSP 并发模型"></a>CSP 并发模型</h2><p>CSP 并发模型是指“不要通过共享内存来通信，而应该通过通信来共享内存”。go 语言的并发模型是基于 CSP 模型的，这得益于完备的 go、channel、select 体系。这一模型的核心思想是尽量降低程序模块之间的耦合度，尽可能地将每一个模块封装为状态机的形式，在不同的模块之间通过数据或标志位的传递来改变状态机的行为，并尽可能降低不同模块之间的临界竞争。</p><p>在 C++程序中，线程之间的通信大多数场景也是遵循这一思想的。大部分线程之间会选择使用队列、原子标志位、期望值来进行同步，而不是多个线程同时去并发访问同一数据结构。毕竟无锁数据结构的设计非常复杂，并且可以设计为无锁形式的数据结构非常有限；而采取加锁的形式来保证线程安全可能会因为竞争而带来比较严重的性能问题。</p><p>C++的并发编程中，简单的控制同步可以直接使用原子量来完成，数据类型的传递可以使用队列来完成。但是，如果状态机中的某个状态具有多个分支，可能就需要使用多个原子量、或者使用多态类型的队列，在实际编程过程中可能会比较繁琐。而 go 语言中的 select 语句可以很好地实现信号的多路复用，使得一个程序的模块可以更加轻松地使用复杂的状态机。这也是为什么 goroutine 并没有提供外界退出的方式，而是必须从自身的逻辑中退出。go 语言的编程逻辑中，更希望每一个 goroutine 中封装的是一个完成的状态机，每一个 goroutine 都是一个独立的模块，从而实现程序不同模块间的低耦合。</p><p>如果进程内的所有线程/协程之间传递数据都使用FIFO 队列，可能会出现较多的内存拷贝。一种更好的方式是针对大对象，通过指针的方式来转移对象的所属权，使程序的不同模块用流水线的方式工作。</p><p>CSP 并发模型，更多地还是在描述程序不同模块之间如何去进行信息交换。在程序模块的内部，为了高性能可以尝试使用一些更加底层的方法来进行更加复杂的操作，但是最好不要将这种复杂度传递给模块之外，否则程序将会变得难以维护。</p><h2 id="hchan"><a href="#hchan" class="headerlink" title="hchan"></a>hchan</h2><p>go 语言中 channel 底层使用的是 hchan 结构体，它本质上是一个有锁的环形缓冲区，hchan 数据结构如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有缓冲时，存储相关信息</span></span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// 循环数组中的元素数量</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// 循环数组的长度</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 指向底层循环数组的指针</span></span><br><span class="line">    elemsize <span class="type">uint16</span> <span class="comment">//能够收发元素的大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    closed   <span class="type">uint32</span>   <span class="comment">//channel是否关闭的标志</span></span><br><span class="line">    elemtype *_type <span class="comment">//channel中的元素类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读写游标</span></span><br><span class="line">    sendx    <span class="type">uint</span>   <span class="comment">// 下一次发送数据的下标位置</span></span><br><span class="line">    recvx    <span class="type">uint</span>   <span class="comment">// 下一次读取数据的下标位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于处理读写阻塞</span></span><br><span class="line">    recvq    waitq  <span class="comment">// 读等待队列</span></span><br><span class="line">    sendq    waitq  <span class="comment">// 写等待队列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lock mutex <span class="comment">//互斥锁，保证读写channel时不存在并发竞争问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 hchan 中的 ring_buffer 缓冲区有数据，那么读写操作无特殊之处。若 hchan 中缓冲区为空，并且接收到一个读操作，或者 hchan 中缓冲区已满，但是接收到一个写操作；那么就会将该操作注册到 waitq 结构体中，waitq 结构体底层是一个 sudog 链表，存储了阻塞 goroutine 的相关调度信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始G结构。相当于g_id</span></span><br><span class="line">    g *g</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待链表上的指针</span></span><br><span class="line">    next *sudog</span><br><span class="line">    prev *sudog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所属的channel，相当于channel_id</span></span><br><span class="line">    c    *hchan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sudog 是注册在一个具体的 hchan 上的，这是因为一个 goroutine 可能会因为不同的 channel 阻塞，因此每一个 hchan 都必须要保留能够查询到阻塞 goroutine 的指针。</p><p>通过上述结构体的分析，goroutine 因为 channel 而陷入阻塞，是会主动让出执行权的。而唤醒操作则由另外一个操作 channel 的 goroutine 负责。</p><h2 id="channel-的并发读写"><a href="#channel-的并发读写" class="headerlink" title="channel 的并发读写"></a>channel 的并发读写</h2><p>一般的互斥量性能都会随着并发量的增长而迅速下降；channel 虽然是一个有锁的数据结构，但是因为底层做了特殊的优化，即使由大量的 goroutine 进行并发操作也不会造成性能的严重下降，只会发生 ns 级别的改变。</p><p>另外，由于涉及到 GC 的问题，所有数据结构在经过 channel 进行传递时都会发生一次复制。因此，可以尽量尝试使用指针来传递比较复杂的数据结构，防止内存复制损耗过多时间。</p><h2 id="select-的阻塞与唤醒"><a href="#select-的阻塞与唤醒" class="headerlink" title="select 的阻塞与唤醒"></a>select 的阻塞与唤醒</h2><p>在早期的版本中，select 语句是由后台 goroutine 轮询来实现的，当分支过多的情况下性能会比较差。在最新版本中，已经针对 select 语句进行了优化，采取了被动调度的方式进行唤醒。</p><p>select 语句的执行逻辑大致可以分为三步：</p><ul><li>判断当前是否有就绪 channel，并随机选择一个分支执行操作</li><li>若无就绪 channel，将 goroutine 信息注册到各个 channel 分支，进入阻塞</li><li>被唤醒时检测就绪 channel，随机选择一个分支操作</li></ul><p>这意味着，一个 for - select 循环在一直满足就绪条件下是可以不断执行的，直到运行被抢占。</p><p>当一个 goroutine 中的 select 语句中并没有可满足的条件时，runtime.selectgo 函数会根据不同分支的 poller 顺序来选择被唤醒时的轮询顺序（每一次完成选择后会重新将该顺序打乱，保证随机选择分支）；还需要根据 channel 的内存指针顺序来依次加锁，以防止死锁。完成上述操作后，goroutine 会进入阻塞状态，等待自身的 G 结构被其他 goroutine 因发送 channel 而状态改变为 _Grunnable，也就是进入 select 阻塞后的 goroutine 只能够被 goroutine 调度器唤醒，而不会主动尝试运行。当 goroutine 被唤醒时，会将所有的 channel 加锁，并且释放所有的 sudog 结构体。</p><p>由于 select 语句在进入阻塞和被唤醒时都需要对所有 channel 加锁，这里会有一定的性能损耗。</p><p>select 语句是一个多分支语句，只能够随机选择一个 channel 运行。但是 go 语言中，sudog 的节点的移出是由解除阻塞的一方负责的，如果不加以控制，就可能会出现多个分支注册的 sudog 同时被多个协程删除的情况，这样就会造成channel 消息的丢失。为了防止这一情况，select 语句注册的 sudog 会做出特殊的标记处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/chan.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *waitq)</span></span> dequeue() *sudog &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是链表删除的逻辑，进入函数前已经对 hchan 加锁</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if a goroutine was put on this queue because of a</span></span><br><span class="line">    <span class="comment">// select, there is a small window between the goroutine</span></span><br><span class="line">    <span class="comment">// being woken up by a different case and it grabbing the</span></span><br><span class="line">    <span class="comment">// channel locks. Once it has the lock</span></span><br><span class="line">    <span class="comment">// it removes itself from the queue, so we won&#x27;t see it after that.</span></span><br><span class="line">    <span class="comment">// We use a flag in the G struct to tell us when someone</span></span><br><span class="line">    <span class="comment">// else has won the race to signal this goroutine but the goroutine</span></span><br><span class="line">    <span class="comment">// hasn&#x27;t removed itself from the queue yet.</span></span><br><span class="line">    <span class="keyword">if</span> sgp.isSelect &amp;&amp; !atomic.Cas(&amp;sgp.g.selectDone, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sgp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果发现取出的 sudog 结构体是由 select 语句注册的，那么会使用 CAS 语句将 selectDone 标志位设置为 1。虽然在进入 dequeue 函数前已经对 hchan 加锁，但是这里的 selectDone 标志位也被注册到了其他 hchan 结构体中，可能会发生 concurrency unsafe。如果成功修改标志位，代表本次操作是第一个通知 select 的操作，此时才会进行数据拷贝；如果修改失败，那么会将忽略本次操作，并且再一次尝试取出 sudog。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gnet 与 net 网络库性能对比</title>
      <link href="/2023/01/09/gnet-%E4%B8%8E-net-%E7%BD%91%E7%BB%9C%E5%BA%93%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
      <url>/2023/01/09/gnet-%E4%B8%8E-net-%E7%BD%91%E7%BB%9C%E5%BA%93%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h1 id="gnet-与-net-网络库性能对比"><a href="#gnet-与-net-网络库性能对比" class="headerlink" title="gnet 与 net 网络库性能对比"></a>gnet 与 net 网络库性能对比</h1><p>在使用 go 语音进行网络编程时，由于 net.Conn.Read 提供的是阻塞读，通常需要将每一个客户端连接放在一个协程中处理，这种方式虽然比较简单，但是会带来一定的性能损耗。</p><h2 id="测试背景"><a href="#测试背景" class="headerlink" title="测试背景"></a>测试背景</h2><p>在使用 go 语言仿写 redis 服务器时，我尝试使用了三种不同的基础架构：</p><ol><li>每一个客户端开启协程负责协议解析、命令执行、消息写回，数据库采用读写锁；</li><li>每一个客户端开启协程负责协议解析，等待事务协程完成命令执行后，再由客户端协程写入消息，协程使用 channel 通信；</li><li>使用 gnet 网络库，采用传统单线程 reactor 模式。</li></ol><p>经过 redis-benchmark 的性能测试，在双核四线程的 CPU 上，这三者的并发量以及 redis-server 的并发量分别如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-server</span> </span><br><span class="line">Summary:</span><br><span class="line">  throughput summary: 76982.29 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.387     0.152     0.351     0.655     0.799     1.511</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式 1，单独设置事务协程</span></span><br><span class="line">Summary:</span><br><span class="line">  throughput summary: 46289.86 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.611     0.048     0.551     0.919     1.999     3.711</span><br><span class="line">        </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式 2，不单独设置事务协程</span></span><br><span class="line">Summary:     </span><br><span class="line">  throughput summary: 42680.32 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.620     0.048     0.599     0.863     1.279     4.871</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式 3，使用 gnet 网络库</span></span><br><span class="line">Summary:</span><br><span class="line">  throughput summary: 67977.26 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.590     0.120     0.543     1.079     1.439     2.335</span><br></pre></td></tr></table></figure><p>很显然，使用 gnet 网络库的并发量要远远高于使用原生的 go 语言网络库，并发量基本上可以达到 redis-server 的 90%左右，考虑到 go 语言中的 GC 机制，这是一个非常不错的并发量。</p><h2 id="火焰图分析"><a href="#火焰图分析" class="headerlink" title="火焰图分析"></a>火焰图分析</h2><p>使用 pprof 工具分别对这三种方式进行分析。</p><h3 id="单独设置事务协程"><a href="#单独设置事务协程" class="headerlink" title="单独设置事务协程"></a>单独设置事务协程</h3><p>在单独设置事务协程时，火焰图如下。可以看到事务的执行时间只占总时间片的 5%左右，其余的 CPU 时间片主要是用于网络 IO 以及 runtime 调度协程。</p><p><img src="/images/pprof-1.png" alt="pprof-1"></p><h3 id="不单独设置事务协程"><a href="#不单独设置事务协程" class="headerlink" title="不单独设置事务协程"></a>不单独设置事务协程</h3><p>在不单独设置事务协程时，火焰图如下，大部分的 CPU 时间片也是用于网络 IO 以及 runtime 调度协程。不过注意到，不单独设置事务协程时，runtime 进行协程调度的时间片要略高。</p><p><img src="/images/pprof-2.png" alt="pprof-2"></p><h3 id="使用-gnet"><a href="#使用-gnet" class="headerlink" title="使用 gnet"></a>使用 gnet</h3><p>在使用 gnet 网络库后，根据火焰图可以看到，原本占据约 1/3 CPU 时间片的协程调度部分消失了，这是 gnet 性能比 net 网络库要高的根本原因。</p><p><img src="/images/pprof-3.png" alt="pprof-3"></p><h2 id="三种模式的分析对比"><a href="#三种模式的分析对比" class="headerlink" title="三种模式的分析对比"></a>三种模式的分析对比</h2><p>无论是否单独设置事务协程，基于 net 架构的系统都只能有一个协程来进行数据库的读写，事务的执行效率其实是类似的。</p><p>在单独设置事务协程的情况下，由于事务协程通常是可以连续执行，不会主动进入阻塞状态，能够在一定程度上减少 goroutine 的调度次数，这一点也能够反应在火焰图中。不过单独设置事务协程的情况下，需要使用 channel 在协程之间进行消息传递，这也会在一定程度上造成性能的损耗。在不单独设置事务协程的情况下，协程可能会因为等待数据库锁而进行阻塞状态，当协程数量比较大时可能竞争会比较严重，比较依赖于锁的性能。</p><p>在少核环境下，根据测试，单独设置事务协程可能会更具有优势。</p><p>使用 gnet 网络库更像是在处理传统的 C/C++ 网络编程，因为不需要 goroutine 的调度，性能确实会比 net 的方式要高出一截。但是同样的，使用 gnet 意味着无法使用 go 语言的一些特性。并且，本次测试的程序，其事务流程都非常简单，事务的执行时间非常短，程序的性能更加程度上取决于网络架构。当服务器的事务执行较为复杂，或者是需要等待系统中其他模块的响应时，事务的执行时间会变长。由于 gent 更像是一个原生的 reactor 模式，单次的读事件如果长时间阻塞就会严重影响整个网络部分的性能。这种情况下，使用 gnet 带来的性能提升就没有那么高，并且可能需要对网络部分进行单独的模块封装，这样会增加系统的复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 goroutine 模拟 redis IO 模型</title>
      <link href="/2022/12/27/%E4%BD%BF%E7%94%A8%20goroutine%20%E6%A8%A1%E6%8B%9F%20redis%20IO%20%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/12/27/%E4%BD%BF%E7%94%A8%20goroutine%20%E6%A8%A1%E6%8B%9F%20redis%20IO%20%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-goroutine-模拟-redis-IO-模型"><a href="#使用-goroutine-模拟-redis-IO-模型" class="headerlink" title="使用 goroutine 模拟 redis IO 模型"></a>使用 goroutine 模拟 redis IO 模型</h1><p>在 redis 6.0 之后，redis 引入了 IO 线程的概念，但是并没有改变原有的单线程执行事务的模式。这是因为网络 IO 和协议解析在一次请求耗时中的占比是非常大的。使用单线程的模型可以简化应用层数据结构的设计，从而使代码更加便于维护。</p><p>而 go 语言中，同样可以利用 goroutine 和 channel 来模拟 redis 的请求处理方式，使用单一事务协程和多个协议解析协程的方式来处理客户端请求。这种处理方式不仅能够借助 go 语言的特点，还能够结合传统 reactor 事务模式的特点，使得代码更易于维护。这种模式下，网络 IO 可以分为 Accept Loop, IO Loop, Event Loop，分别完成建立新连接，解析客户端命令，处理客户端请求的功能。</p><h2 id="抽象客户端连接"><a href="#抽象客户端连接" class="headerlink" title="抽象客户端连接"></a>抽象客户端连接</h2><p>由于 goroutine 不具备传统线程的特点，不能够直接从外部来改变协程的状态。可以将每一个客户端连接所对应的协程抽象为一个 Client Struct，也就是一个 Context 进行管理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">  event *Request             <span class="comment">// 解析后的命令</span></span><br><span class="line">  raw []<span class="type">byte</span>               <span class="comment">// 解析前的命令</span></span><br><span class="line">  res <span class="keyword">chan</span> *Response <span class="comment">// 回包</span></span><br><span class="line"></span><br><span class="line">  cnn   net.Conn  <span class="comment">// 连接实例</span></span><br><span class="line">  id    uuid.UUID <span class="comment">// Cli 编号</span></span><br><span class="line">  tp    time.Time <span class="comment">// 通信时间戳</span></span><br><span class="line"></span><br><span class="line">  status ClientStatus  <span class="comment">// 状态 0 等待连接 1 正常 -1 退出 -2 异常</span></span><br><span class="line">  exit   <span class="type">bool</span> <span class="comment">// 退出标志</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(c net.Conn)</span></span> *Client &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个 <code>Client Struct</code> 都对应了一个 <code>net.Conn</code> 实例，并运行在一个单独的 goroutine 上。结构体内部存储与该连接相关的所有信息，当不同循环之间需要通信时，可以使用 <code>chan *Client</code> 进行通信，减少数据的拷贝。</p><h2 id="Accept-Loop"><a href="#Accept-Loop" class="headerlink" title="Accept Loop"></a>Accept Loop</h2><p>Accept Loop 主要执行 reactor 模型中 Acceptor 对象的功能，监听被动套接字，新连接抽象为<code>Client Struct</code>，并开启协程来处理读写请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理新连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AcceptLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> !quit&#123;</span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立一个新的 Client 实例</span></span><br><span class="line">    newCli := NewClient(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启协程处理 IO 请求</span></span><br><span class="line">    <span class="keyword">go</span> IOLoop(newCli)<span class="comment">// 这里也可以使用协程池的方式，一个协程绑定多个客户端连接</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="IO-Loop"><a href="#IO-Loop" class="headerlink" title="IO Loop"></a>IO Loop</h2><p>IO Loop 主要负责处理 socket 的读写，客户端请求的解析工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IOLoop</span><span class="params">(cli *Client)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> !cli.exit &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读请求</span></span><br><span class="line">    cli.cnn.Read(cli.raw[rd:])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析请求</span></span><br><span class="line">    parseRequest(cli.raw,cli.event)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 channel 发送通知</span></span><br><span class="line">    events &lt;- cli</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 Event Loop 执行</span></span><br><span class="line">    cli.cnn.Write( &lt;-cli.res) </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知 Event Loop 释放相关记录</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>Event Loop 处理 IO Loop 发送的活跃事件以及定时事件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EventLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> !quit&#123;</span><br><span class="line">    timer := time.NewTimer(time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行时间事件</span></span><br><span class="line">      execTimeEvent()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> cli := &lt;-events:</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行 IO 时间</span></span><br><span class="line">      eventRes := executeIOEvent(cli.event)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通知阻塞的客户端</span></span><br><span class="line">      cli.res &lt;- eventRes</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行退出事件</span></span><br><span class="line">  executeShutdownEvents()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>事件流程较为清晰，事件的处理并不存在并发。</li><li>可以减少应用层临界资源的竞争。</li><li>可以保证所有事件是串行执行的。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>使用管道传递主业务数据，会造成一定的性能损耗。</li><li>该模式不适合单个事件执行时间过长的场景。</li></ul><h3 id="redis-场景下的对比"><a href="#redis-场景下的对比" class="headerlink" title="redis 场景下的对比"></a>redis 场景下的对比</h3><p>在保证协议解析部分，数据库部分（除读写锁）相同的情况下，测试直接使用 goroutine 解析并执行命令（使用读写锁保证互斥）、使用单独的 goroutine 执行命令、redis-server 三者性能。redis-benchmark，测试环境为 MacOS Ventura 13.0，8 G 内存，双核四线程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用单独 goroutine 串行执行命令</span></span><br><span class="line">Summary:</span><br><span class="line">  throughput summary: 45289.86 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.611     0.048     0.551     0.919     1.999     3.711</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接使用 goroutine 解析并执行命令</span></span><br><span class="line">Summary:     </span><br><span class="line">  throughput summary: 42680.32 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.620     0.048     0.599     0.863     1.279     4.871</span><br><span class="line">        </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-server</span> </span><br><span class="line">Summary:</span><br><span class="line">  throughput summary: 76982.29 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.387     0.152     0.351     0.655     0.799     1.511</span><br></pre></td></tr></table></figure><p>经过多次对比，使用单独 goroutine 串行执行命令时，每秒钟执行的命令数比直接使用 goroutine 解析并执行命令多 3000 次左右，并且后者并没有执行 aof 刷盘、更新服务器状态等时间事件。而 redis-server 的每秒请求数保持在 76000 左右，远远高于 go 语言版本。</p><h2 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h2><p>使用 pprof 工具获取压力测试阶段的调用图。可以看到，syscall.read 和 syscall.write 占据了绝大多数的 CPU 时间片，网络 IO 是主要的性能瓶颈。</p><p><img src="/images/image-20230108035814657.png" alt="image-20230108035814657"></p><p>经过查阅资料，go 官方的 net 库性能较差，尝试选用 gnet 网络库更换 net 库。更换后，进行同样的测试，性能有较大的提升。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 gnet 网络库</span></span><br><span class="line">Summary:</span><br><span class="line">  throughput summary: 64977.26 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.590     0.120     0.543     1.079     1.439     2.335</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 暴露部分私有接口</title>
      <link href="/2022/12/27/C++-%E6%9A%B4%E9%9C%B2%E9%83%A8%E5%88%86%E7%A7%81%E6%9C%89%E6%8E%A5%E5%8F%A3/"/>
      <url>/2022/12/27/C++-%E6%9A%B4%E9%9C%B2%E9%83%A8%E5%88%86%E7%A7%81%E6%9C%89%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="C-暴露部分私有接口"><a href="#C-暴露部分私有接口" class="headerlink" title="C++ 暴露部分私有接口"></a>C++ 暴露部分私有接口</h1><p>C++ 中可以通过桥接类的方式来暴露类的一部分接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exposure</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hidden</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Exposure</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要隐藏的接口</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hidden</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exposure</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露 foo 接口 和 bar 接口</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> impl_-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> impl_-&gt;<span class="built_in">bar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Hidden *impl_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 防止头文件暴露私有变量</title>
      <link href="/2022/12/27/C++-%E9%98%B2%E6%AD%A2%E5%A4%B4%E6%96%87%E4%BB%B6%E6%9A%B4%E9%9C%B2%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F/"/>
      <url>/2022/12/27/C++-%E9%98%B2%E6%AD%A2%E5%A4%B4%E6%96%87%E4%BB%B6%E6%9A%B4%E9%9C%B2%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="C-防止头文件暴露私有变量"><a href="#C-防止头文件暴露私有变量" class="headerlink" title="C++ 防止头文件暴露私有变量"></a>C++ 防止头文件暴露私有变量</h1><p>C++ 中可以通过嵌套类的形式防止成员私有变量暴露在头文件里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exposure</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Exposure</span>();</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">interface</span><span class="params">(<span class="type">int</span> foo)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Impl</span>;</span><br><span class="line">  std::unique_ptr&lt;Impl&gt; impl_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exposure</span>::Impl &#123;</span><br><span class="line">  <span class="comment">// 具体实现</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">interfaceImpl</span><span class="params">(<span class="type">int</span> foo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exposure::<span class="built_in">Exposure</span>() : <span class="built_in">impl_</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;())&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Exposure::interface</span><span class="params">(<span class="type">int</span> foo)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;impl_-&gt;<span class="built_in">interfaceImpl</span>(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BSON结构分析</title>
      <link href="/2022/12/27/BSON%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/2022/12/27/BSON%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="BSON-结构分析"><a href="#BSON-结构分析" class="headerlink" title="BSON 结构分析"></a>BSON 结构分析</h1><h2 id="BSON-简介"><a href="#BSON-简介" class="headerlink" title="BSON 简介"></a>BSON 简介</h2><p>BSON 全称是 Binary JSON, 和 JSON 很像，但是采用二进制格式进行存储。相比 JSON 有以下优势：</p><ul><li><strong>访问速度更快。</strong>BSON 会存储 Value 的类型，相比于明文存储，不需要进行字符串类型到其他类型的转换操作。以整型 12345678 为例，JSON 需要将字符串转成整型，而 BSON 中存储了整型类型标志，并用 4 个字节直接存储了整型值；</li><li><strong>存储空间更低。</strong>还是以整型 12345678 为例，JSON 采用明文存储的方式需要 8 个字节，但是 BSON 对于 Int32 的值统一采用 4 字节存储，Long 和 Double 采用 8 字节存储。 当然这里说存储空间更低也分具体情况，比如对于小整型，BSON 消耗的空间反而更高；</li><li><strong>数据类型更丰富。</strong>BSON 相比 JSON，增加了 BinData，TimeStamp，ObjectID，Decimal128 等类型。</li></ul><h2 id="BSON-存储格式"><a href="#BSON-存储格式" class="headerlink" title="BSON 存储格式"></a>BSON 存储格式</h2><p>一条最简单的 BSON 文档，从前向后可以拆解成以下几个部分：</p><ol><li>文档的总长度， 占 4 个字节；</li><li>Value 类型，参考<a href="https://github.com/mongodb/mongo/blob/r4.2.21/src/mongo/bson/bsontypes.h#L59-L110">代码定义</a>，占 1 个字节；</li><li>Key 的 String 表示形式（Key 只能 String 类型），长度不固定，以 ‘\0’ 结尾，占 len(Key)+1 个字节；</li><li>Value 的二进制存储，比如 Int32 占 4 字节，Long 和 Double 占 8 个字节等；</li><li>文档以 ‘\0’ 结尾，也就是在遍历 BSON 到末尾时，常见的 EOO(End Of Object)，占 1 个字节；</li></ol><h2 id="紧凑格式的缺点"><a href="#紧凑格式的缺点" class="headerlink" title="紧凑格式的缺点"></a>紧凑格式的缺点</h2><p>BSON 的存储格式非常紧凑，不同的键值对之间是无间隔存储。因此，修改 BSON 中的某一字段意味着需要组织处一个新的 BSON 对象。如果增加、删除或者修改了某个字段，要生成新 BSON 文档，而非在原有 BSON 文档上原地修改。</p><p>在使用 MongoDB 时，可以使用 JSON 格式来暂时存储数据以便在不同的程序模块之间传递。当数据需要插入 MongoDB 时，再将数据封存，转换为 BSON 格式。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 复制集同步过程</title>
      <link href="/2022/12/26/MongoDB-%E5%A4%8D%E5%88%B6%E9%9B%86%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/12/26/MongoDB-%E5%A4%8D%E5%88%B6%E9%9B%86%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB-复制集同步过程"><a href="#MongoDB-复制集同步过程" class="headerlink" title="MongoDB 复制集同步过程"></a>MongoDB 复制集同步过程</h1><p>MongoDB Replica Set 是一种基于分布式选举和复制状态机的高可用架构，这一套模式虽然与 paxos、raft 协议非常相似，但实质上差异却非常大。raft 协议中，所有事务的提交都是线性的，所有节点会进行同步提交，因此可以保持很高的数据一致性，但是写性能会比较差；而 MongoDB 的复制集则是一种异步复制+选举算法的结合，通过调节事务的提交时间来完成数据一致性的保证。</p><h2 id="基于-Oplog-的数据同步机制"><a href="#基于-Oplog-的数据同步机制" class="headerlink" title="基于 Oplog 的数据同步机制"></a>基于 Oplog 的数据同步机制</h2><p>与 raft 协议类似，MongoDB 中也是采用复制状态机的模式来进行数据复制，在 MongoDB 中用于节点同步的日志类型称为 Oplog。Oplog 其实并不是一种日志文件，而是 WiredTiger 中一个特殊的 Collection，这种特殊的模式使得 MongoDB 中应用层日志、数据、索引实际上是作为一个事务整体写入的。这种设计能够有效地规避应用层日志与数据库日志不相同的问题，这个问题在 MySQL 中有所体现，并且困惑了开发者相当长一段时间。对比 etcd 的实现，可以认为 etcd 是按照 raft 状态机的模式，在 raft 节点之上构建一个数据库；而 MongoDB 其实仍然是一个传统的数据库同步模式，是一个基于数据库引擎的复制模式，这是两者之间的核心差异。</p><h2 id="Oplog-的异步复制"><a href="#Oplog-的异步复制" class="headerlink" title="Oplog 的异步复制"></a>Oplog 的异步复制</h2><p>经过上一小节的讨论，MongoDB 的复制机制并不是 etcd 的模式，而是类似 MySQL 主从复制的模式。这样就能够更加轻松地理解为什么 Oplog 采取的一种异步复制的模式。</p><img src="/images/20jq7bq4ya.png" alt="20jq7bq4ya" style="zoom: 67%;" /><p>Oplog 的异步复制是由从节点发起的，每一个从节点都会有一个特殊的线程用于从主节点拉取 Oplog，我们这里称之为拉取线程。当拉取线程只负责完成 Oplog 的复制，并写入到本地的 Collection 中，当写入完成后拉取线程就会继续向主节点请求下一批 Oplog。拉取线程在拉取 Oplog 过程中不会发生任何的阻塞。</p><p>Oplog 的重放是由重放线程来完成的，根据设置 MongoDB 中可以存在多个重放线程来加快复制速度，默认的重放线程为 16 个。重放线程实际上是在模拟客户端的请求向数据库发送命令完成数据的复制。回放线程尽量累积大量数据才回放（批量并发执行效率高）。但是如果oplog比较少，会提前返回。但是极端情况下，可能会有最多阻塞1秒的情况。</p><p>当重放线程完成重放后，会直接通知主节点自身的当前版本。心跳与版本上报是两个不同的过程，因为心跳周期两秒的间隔时间过长，如果使用心跳上报会导致客户端请求长时间被阻塞。心跳只用于无请求时的保活操作。</p><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p>MongoDB 中的选举与 raft 算法也有着一定的区别。raft 算法中由于客户端请求必须到达多数节点才能够提交，因此在选举过程中需要考虑数据一致性的问题，防止数据回滚。而 MongoDB 中，客户端操作并不会因为未到达多数节点而提交失败，只会发生超时错误（超时错误不会导致回滚），因此 MongoDB 中的选举算法主要考虑如何更快地选择数据更多更新的节点，并且尽量保证不丢失数据。</p><p>MongoDB 选举机制中比较特殊的地方在于：当选举完成后，新选举的主节点会要求所有的从节点发送自身的最近数据，并且取这些数据的并集作为集群视图，raft 协议中则是直接按照主节点的状态机作为新视图。这点不同主要是考虑到每个从节点进行 Oplog 重放的顺序可能不同，虽然 Oplog 的拉取是严格按照次数的，但是在重放过程中由于使用了多线程重放，可能会有一部分线程阻塞，发生事务提交的重排。</p><h2 id="网络分区的风险"><a href="#网络分区的风险" class="headerlink" title="网络分区的风险"></a>网络分区的风险</h2><p>当 MongoDB 复制集集群中发生主节点网络分区时，虽然集群中已经完成了选举，但主节点在当前的心跳周期仍然可以处理客户端的请求。</p><p>如果客户端的写入请求为 w:1，那么在这种情况下仍然是可以成功写入的，并且客户端并不会得到写入超时的通知，即客户端视角下无法得知异常发生，无法采取相关的异常处理操作。当主节点网络恢复后，这部分时间内发生的写请求会发生回滚，回滚的数据会被写入到回滚文件中，必须要人工进行数据维护。如果不使用高于 w:majority 的写入等级，就需要承受数据发生回滚的风险。</p><p>发生网络分区时，客户端的读请求会因为不同的  Read Peference 而发生不同的处理。在约一个心跳周期的时间范围内，MongoDB 只能够保证采取相同Read Concern 和 Read Peference 的读请求保持正确的读顺序。当Read Concern 和 Read Peference 不同时，可能会出现读请求R1读到主节点的过期数据，读请求R2 读到其他节点的正常数据，当 R2 时间早于 R1 时就会出现读操作的不安全性。 最好对相同的 Collection 采取相同的读设置来获取更一致的视图。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 无锁 Write FLow</title>
      <link href="/2022/12/26/MongoDB%20%E6%97%A0%E9%94%81Write%20FLow/"/>
      <url>/2022/12/26/MongoDB%20%E6%97%A0%E9%94%81Write%20FLow/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB-无锁-Write-FLow"><a href="#MongoDB-无锁-Write-FLow" class="headerlink" title="MongoDB 无锁 Write FLow"></a>MongoDB 无锁 Write FLow</h1><h2 id="同一-key-的无锁读写"><a href="#同一-key-的无锁读写" class="headerlink" title="同一 key 的无锁读写"></a>同一 key 的无锁读写</h2><p>MongoDB 的一个 B+树索引中具有三个数据结构来存储键值对数据：</p><ul><li>WT_ROW 数组，存储原本 Check Point 时刻的值。</li><li>WT_UPDATE 跳跃表数组，存储已有键值对的更新值。</li><li>WT_INSERT_HEAD 跳跃表数组，存储新插入键值对的更新值。</li></ul><p>MongoDB 中所有的写操作并不会直接修改原有的内存位置，而是将新数据写入到B+树索引节点中的跳跃表中。结合惰性删除机制，跳跃表是可以做到无锁读写的。</p><p>但是这种设计会使得读取的流程较长，因为要查询数据需要依次搜索WT_UPDATE，WT_ROW和WT_INSERT_HEAD 这三个数据结构，当插入数据过多时，跳跃表的搜索性能是要比 WT_ROW 的有序数组结构差的。</p><h2 id="Check-Point-技术"><a href="#Check-Point-技术" class="headerlink" title="Check Point 技术"></a>Check Point 技术</h2><p>MongoDB 中会定期对 B+ 树进行整理，防止插入数据过多，影响读取性能，Check Point 技术会定期整理内存和硬盘中的 B+树结构。</p><p>当一次 Check Point 发生后，MongoDB 将会新建一个 B+树，所有的写入操作会被转移到新的 B+树中。而所有的刷盘以及分裂操作只会影响到旧的 B+ 树。具体过程比较复杂，可以参考《MongoDB 核心原理与实践》。</p><h2 id="变长-Page-减少-B-树节点分裂"><a href="#变长-Page-减少-B-树节点分裂" class="headerlink" title="变长 Page 减少 B+ 树节点分裂"></a>变长 Page 减少 B+ 树节点分裂</h2><p>MongoDB 中的索引部分使用的是 B+ 树这种数据结构，一般来说 B+ 树在节点分裂的过程中是无法做到无锁的，但是 WiredTiger 基于变长 Page 的技术来避免 B+ 树分裂时加锁。</p><p>在数据库系统中，B+树在硬盘中的页面大小通常是硬盘扇区的大小，这主要是考虑到硬盘读写的原子性，防止破坏 B+树节点的内部结构。因为这种考虑，B+树的硬盘节点通常都比较小。而比较小的 B+树节点可能就意味着需要经常进行分裂操作来保持 B+树的平衡性。</p><p>MongoDB 的 B+ 树在内存中和在硬盘中的 page 大小是不相同的，内存中的 page 大小要远远大于硬盘中的 page 大小。当内存中的 B+树 page 需要刷盘时，会将内存 page 分裂为多个硬盘 page 写入到硬盘中，这就是变长 Page 技术。变长 Page 技术能够减少 B+ 树的持久化次数，还能够尽量避免 B+ 树因为插入而导致的分裂。引入了变长 Page 技术后，MongoDB 中索引 B+ 树的节点分裂会被转移到 reconcile 和 eviction 过程中，从而避免了在 Write Flow 中出现索引变更的情况。</p><h2 id="插入过多时小粒度分裂"><a href="#插入过多时小粒度分裂" class="headerlink" title="插入过多时小粒度分裂"></a>插入过多时小粒度分裂</h2><p>仅仅依靠变长 Page 还不能够解决所有的问题，如果在某一时刻发生大量的写入操作，导致一个B+树节点在短时间内就达到了内存 page 的上限，这种情况下依旧需要发生 B+树节点的分裂。</p><p>由于 MongoDB 中所有新插入的节点都是存在于 WT_INSERT_HEAD 跳跃表数组中的，当B+树节点因为插入数量过多需要分裂时，会将WT_INSERT_HEAD 中的最后一个跳跃表复制到新的节点中（MongoDB 中的主键值基本上是自增的，最后一个跳跃表中的节点在大部分情况下是最多的）。这种小粒度的分裂能够避免对B+树进行大面积修改。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptables 转发规则</title>
      <link href="/2022/12/26/iptables%20%E8%BD%AC%E5%8F%91%E8%A7%84%E5%88%99/"/>
      <url>/2022/12/26/iptables%20%E8%BD%AC%E5%8F%91%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Iptables-转发规则"><a href="#Iptables-转发规则" class="headerlink" title="Iptables 转发规则"></a>Iptables 转发规则</h1><p>iptables 是 linux 中的防火墙模块，用于网络包的过滤与转发，一共可以分为五链四表。</p><p><img src="/images/BD5561C0-D097-4A4F-BF4F-146FA15C46D7.jpg" alt="image">￼</p><h3 id="iptbles-的匹配规则"><a href="#iptbles-的匹配规则" class="headerlink" title="iptbles 的匹配规则"></a>iptbles 的匹配规则</h3><p>一台主机中，可能会具有多个网卡，这些网卡会有不同的网络地址，但是所有网卡会共用同一个 iptables 匹配规则，也会共用宿主机的路由转发规则。</p><p><strong>在路由选择中，只有最终判断为本地地址，如 127.0.0.1，本机的网卡地址的网络包才会被转发到 INPUT</strong>，而 docker 虚拟网卡上挂载的地址，则会被转发到虚拟网卡上，而不是直接进入INPUT 链中。注意，虚拟网卡上的转发是不经过 iptables 的，一个网络包到达 docker0 网卡后只会经过网卡的转发规则，直接被转发到对应的进程中。在进入 docker 进程后，使用的 iptables 规则和宿主机 iptables 规则是不相同的。</p><p>外部的流量在PREROUTING 链进行 DNAT 后，会根据目的网络地址来判断是否能够匹配本地路由地址，否则将会被转发到 FORWARD 链中。</p><p>内部的流量流出时，会直接根据目的地址判断是否为本地流量，如果是本地流量则不经过 OUTPUT 链，直接被转发到 INPUT 链中。<strong>这意味着 localhost 与 127.0.0.1 这两个地址是不会经过任何的DNAT 的。</strong>如果目的地址不是本机地址，那么会经过 OUTPUT 和 POSTROUTING链进行 DNAT 和 SNAT，这时候会再次通过路由表判断流量的地址转发到具体的网卡上。</p><h3 id="不容易理解的地方"><a href="#不容易理解的地方" class="headerlink" title="不容易理解的地方"></a>不容易理解的地方</h3><p>如果一个主机挂载了一个 docker0 网卡，那么 iptables 的转发规则就会稍微有些难以理解。</p><ul><li>172.0.0.x 网段不是本机的 ip 地址，因此在路由选择中不会转发给 INPUT，而是会转发给 FORWARD，然后经过 POSTROUTING，然后转发给 docker0 网卡，docker0 网卡会根据目的 ip 地址将网络包转发给虚拟机，注意此时的虚拟机收到网络包后已经不与宿主机使用同一个 iptables。</li><li>localhost 和 127.0.0.1 会经过路由选择后直接转发给 INPUT，不能够经过任何的 DNAT 修改，因此针对 localhost 的转发都是无效的。</li><li>DNAT 和 SNAT 是具有记忆性的。如果一次 tcp 中，宿主机给出流量做了 DNAT，那么收到这个 tcp 的回包时，将会自动进行反操作，因此 docker 中的虚拟容器只需要一次 DNAT 就可以访问外界流量了。</li></ul><h3 id="如何做-NAT-转换"><a href="#如何做-NAT-转换" class="headerlink" title="如何做 NAT 转换"></a>如何做 NAT 转换</h3><p>1、首先需要开启端口转发<br>2、<code> sudo iptables -t nat -A PREROUTING -d x.x.x.x -p tcp -dport x -j DNAT --to-destinaton x.x.x.x:x</code></p><p>3、<code> sudo iptables -t nat -A POSTROUTING -d x.x.x.x -p tcp -dport x -j SNAT --to-source x.x.x.x</code></p><p>4、需要在 FORWARD 链中放行流量，例如</p><p><code>sudo iptables -A FORWARD  -i eth0 -o eth0 -j ACCEPT</code></p><p>5、如果只需要在本主机进行端口转换，则应该使用重定向来代替</p><p><code>sudo iptables -t nat -A PREROUTING -d 127.0.0.1 -dport x -j REDIRECT to-ports x</code></p><h3 id="利用-string模块完成应用层过滤"><a href="#利用-string模块完成应用层过滤" class="headerlink" title="利用 string模块完成应用层过滤"></a>利用 string模块完成应用层过滤</h3><p>iptables 的 string 模块可以将网络包中的关键词进行匹配，从而实现禁止访问某些 url，禁止访问某些内容，或者禁止回复某些内容的效果。具体代码如下：</p><p><code>sudo iptables -t filter INPUT -m string --algo bm --string &#39;sf&#39; -j DROP</code></p><p>但是，iptables 不能够确定字符串出现的位置，因此可能会出现误伤的情况。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s proxy 网络模型</title>
      <link href="/2022/12/25/k8s-proxy-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/12/25/k8s-proxy-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="k8s-proxy-网络模型"><a href="#k8s-proxy-网络模型" class="headerlink" title="k8s proxy 网络模型"></a>k8s proxy 网络模型</h1><h3 id="iptables-模式"><a href="#iptables-模式" class="headerlink" title="iptables 模式"></a>iptables 模式</h3><p><img src="/images/DF43002E-5DBE-415E-94FB-6505B66D850A.jpg" alt="image">￼</p><p>注意，所有的k8s 标记只分为两种，一种是需要转发的标记0x400，一种是需要丢弃的标记0x800。前者会最终在 POST 中被转发。</p><p>下面解释一下为什么会有需要丢弃的数据包。由于规则链的建立并不是原子性的，所以可能会出现一种情况，规则链建立一半时，已经有相关的数据包到达了——这是一个非常危险的情况，可能会导致一些未定义的行为。因此，在规则正在建立的过程中，需要将相关数据包标记为 0x800，并最终丢弃掉。也就是 0x800 是用于标识规则链是否完全建立的。</p><p>另外一种情况是按照用户的需求，对一些虚拟容器进行隔离操作。</p><h3 id="iptables-clusterIP访问模式"><a href="#iptables-clusterIP访问模式" class="headerlink" title="iptables - clusterIP访问模式"></a>iptables - clusterIP访问模式</h3><p>这种访问模式一般是用于访问启动了多个实例的服务，并且需要进行负载均衡。客户端访问的链路可以表示为：</p><p>PREROUTING -&gt; KUBE-SERVICE -&gt; KUBE-SVC-SERV -&gt; KUBE-SEP-POD</p><p>​    所有外部流量都会被 KUBE-SERVICE 链截获，并检查是否有流量是流向某一clusterIP的，并将流量传递给对应的 KUBE-SVC-SERV。KUBE-SVC-SERV 根据设置的负载均衡算法，将流量转发给对应的 KUBE-SEP-POD 链，并最终在该链中进行 DNAT 处理。</p><h3 id="iptables-NodePort-访问模式"><a href="#iptables-NodePort-访问模式" class="headerlink" title="iptables - NodePort 访问模式"></a>iptables - NodePort 访问模式</h3><p>这种方式通常用来访问单独启动的服务实例。客户端的访问链路可以表示为：</p><p>PREROUTING -&gt; KUBE-SERVICE -&gt; KUBE-NODEPORTS -&gt; KUBE-SVC-XXX -&gt; KUBE-SEP-XXX</p><p>单独启动的服务实例会单独注册在 KUBE-SERVICE链中，当clusterIP匹配完成后，才会进行 NodePort 规则匹配。<strong>使用 nodePort 方式来访问一个容器，其转发链路要更长，因此性能要稍差。</strong></p><h3 id="ipvs-模式"><a href="#ipvs-模式" class="headerlink" title="ipvs 模式"></a>ipvs 模式</h3><p><img src="/images/71E894A0-C367-4B4F-A7DE-FF0275149CD4.jpg" alt="image">￼<br>ipvs 因为继承了 lvs 模块，所以其实是更加简单的。只需要在流量入口处进行流量区分和标记就可以。客户端进行访问的链路可以表示为：</p><p>PREROUTING -&gt; KUBE-SERVICES -&gt; KUBE-CLUSTER-IP -&gt; INPUT -&gt; KUBE-FIREWALL -&gt; POSTROUTING</p><p>或者为：</p><p>PREROUTING –&gt; KUBE-SERVICES –&gt; KUBE-NODE-PORT –&gt; INPUT –&gt; KUBE-FIREWALL –&gt; POSTROUTING</p><ul><li>KUBE-SERVICES 链负责劫持所有的流量，进行粗删选，根据主机所设置的网段号来初步判断流量目标是否是k8s 服务。</li><li>KUBE-CLUSTER-IP 负责第二次筛选，将网段正确的流量匹配ipset集合，如果通过集合，则标记为0x2000，如果失败则标记为0x4000。</li><li>如果 KUBE-SERVICES 链没有通过筛选，则进入 KUBE-NODE-PORT 链中，判断是否是单独开启的服务实例。</li><li>INPUT 与 KUBE-FIREWALL：判断是否有标记为 0x4000 的流量，如果有，直接丢弃。</li><li>IPVS 与 POSTROUTING：将通过匹配的流量通过 nat 的方式转发到负载均衡算法计算后的地址。使用 nat 是因为可以很好地进行端口映射，这样会使得调度机制更加灵活，</li></ul>]]></content>
      
      
      <categories>
          
          <category> 云技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ipvs </tag>
            
            <tag> iptables </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 网络模型</title>
      <link href="/2022/12/25/Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/12/25/Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-网络模型"><a href="#Docker-网络模型" class="headerlink" title="Docker 网络模型"></a>Docker 网络模型</h1><p>Docker 容器为了实现网络隔离，可以看作连接在不同虚拟网卡上的主机。网络隔离的基本需求是不同虚拟主机直接网络不能够互通，虚拟主机可以访问外部设备，而外部设备不能够直接访问虚拟主机，只能够通过端口来访问。</p><h3 id="根据链来分"><a href="#根据链来分" class="headerlink" title="根据链来分"></a>根据链来分</h3><ul><li>FORWARD 拦截所有非本地流量，所有 docker 流量都被包含在这里。下图，ISO 是隔离不同网桥之间的互相访问。由于已经过滤掉了不同隔离网络之间的访问，所以 docker 链中是接受所有外界的流量到 docker 网卡中。再往下两条是允许虚拟网卡流量流向主机外部和网卡本身。<br><img src="/images/25044E49-54B6-443E-AD9D-28A50BA05F43.jpg" alt="image">￼</li><li>OUTPUT 和PREROUTING链则是截获所有本地非容器流量，他们都公用 DOCKER 链，如果发现是要访问host:port，将其 DNAT 到对应的容器地址。<br><img src="/images/46722EDA-E303-4193-BA0E-FFF224792801.jpg" alt="image">￼</li><li>POSTROUTING 链是将所有容器访问主机外的流量，伪装成本地流量。<br><img src="/images/FCF35C50-9952-49CA-8613-306460E4EE80.jpg" alt="image">￼</li></ul><h3 id="单机网桥模式"><a href="#单机网桥模式" class="headerlink" title="单机网桥模式"></a>单机网桥模式</h3><p>单机网桥模式是没有指定任何网络选项的容器，假设容器的虚拟 ip 为 172.10.0.x，由于该网段宿主机并没有暴露给外界，因此外界无法访问容器。但有一种例外情况，就是外界主机通过修改路由表强行将 172.10.0.x 的流量转发给宿主机。这样流量在到达宿主机后是可以匹配到一条路由规则的，从而实现外界流量访问虚拟容器。</p><p>容器内部的出流量在宿主机的 POST 链做了 MASQUERADE 处理，所以可以访问外界。假设容器的虚拟 ip 为 172.10.0.x，容器所有的出流量都会经过宿主机的 OUTPUT 和 POSTROUTING 链后选择合适的网卡进行转发。根据 docker 设置的 iptables 规则，所有出流量在 POSTROUTING 链经过 MASQUERADE 的 SNAT 伪装成为宿主机流量。tcp 回路的时候，宿主机会发现该数据包经历过 SNAT 规则转发，自动将回包的地址修改为 172.10.0.x，经过本地的路由规则转发到 docker0 网桥后就可以发送给对应的虚拟容器。</p><h3 id="网桥模式"><a href="#网桥模式" class="headerlink" title="网桥模式"></a>网桥模式</h3><p>网桥模式即使用 -p 选项进行端口映射来启动的容器。单机网桥模式会复用主机端的端口，外部流量通过宿主机的 ip 地址加对应的端口号来访问虚拟容器。因此流量只要是到达主机的对应端口，就默认一定是访问主机端的服务。只用端口来判断流量是否走向 docker 容器就可以了。</p><ul><li>外部流量入：外部流量需要走 PREROUTING-FORWARD-POSTROUTIN 链，外部流量的网卡是除了docker自带的网卡之外的所有网卡。所以这些流量都需要在 PREROUTING 做 DNAT 处理，将流量的目的地址修改为 docker 容器的网段。</li><li>经过 DNAT 后，宿主机发现流量流向地址不是本地应用，转发到 FORWARD 和 POSTROUTING，并且根据路由表转发到容器对应的虚拟网卡里面。</li><li>内部流量出：docker 容器出流量也是宿主机应用出流量，所以会从 docker 虚拟网卡发送到 OUTPUT 链，需要在 OUTPUT 链中进行 MASQUERADE 将发送到外部的流量全部 SNAT 为宿主机的地址；此外，还要将发送给本机暴露出的端口也进行 SNAT 处理，即自访问。</li><li>不同网桥之间的隔离操作：一个网桥发送给其他网桥的流量不会 SNAT 和 DNAT，会被直接发送到虚拟网卡上。虚拟网卡的入链同样会走 PRE 链，检测到是虚拟网卡流量，直接不进行操作。放行到 FORWARD，检测到不同网桥之间的相互访问，由 ISO1 截获，由 ISO2 丢弃。</li><li>用户安全性操作：所有外部流量在截获前，都会被DOCKER-USER 链截获，用户需要将自己的链接入 DOCKER-USER 链中。</li></ul><p>网桥模式中，主要是通过匹配端口号来实现外部流量的转发的，内部流量的流出过程与单机网桥模式是相同的。除此此外，网桥模式下还需要对不同 docker 网络段之间的流量进行隔离操作，防止没有连接的两个虚拟网络段之间相互通信。</p><h3 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h3><p>对于使用了 network 选项启动的容器，docker 会自动使用 127.0.0.11 来创建一个 DNS 服务器，所有 docker 创建出的进程会使用该地址作为默认的 DNS 服务器。并且每一个服务名都会作为一个域名进行注册。该内嵌的 DNS 服务器会根据容器的网段地址来进行选择性查询，从而来实现不同网络驱动之间的域名隔离。</p><h3 id="ROUTING-MESH模式"><a href="#ROUTING-MESH模式" class="headerlink" title="ROUTING MESH模式"></a>ROUTING MESH模式</h3><p>该模式的意思是，从任何一个宿主机上暴露端口访问，都可以被负载均衡到任一台宿主机的容器上。</p><p><img src="/images/F0FC6715-47DA-4E75-AB35-A856B43431AA3.jpg" alt="image">￼</p><ul><li>外部流量入口：所有的外部流量都会被 PREROUTING 中的 DOCKER-INGRESS 链截获。如果流量目标端口是一个使用 overlay 网络模式的容器，那么该流量会被捕获到 172.18.0.2 容器中。</li><li>ingress-sbox：用来进行第二步iptables 流量控制。这里是通过mark+ipvs的方式来完成的，ipvs 的 vip 被绑定到overlay-bridge上。FORWARD 和 INPUT 链都会对不同端口数据包进行不同的标记，当数据包通过 INPUT 进入ipvs的vip 时，根据不同的标记进行负载均衡。</li><li>目标容器：直接对流量进行处理。</li><li>容器流量出口：vxlan 流量出来经过容器后，会经重定向发送到挂在宿主机的虚拟网卡。此时，网卡会被 OUTPUT链截获，如果发现是发送给 overlay 网络的流量，则会被 DNAT 到 ingress-box中。注意，docker_gwbridge 没有做外部 DNAT，无法被外部访问。</li><li>以上是实现了overlay网络与普通网络流量之间的隔离。这个隔离是使用一个容器来完成的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 云技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> ipvs </tag>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis与限流算法</title>
      <link href="/2022/12/25/redis%E4%B8%8E%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
      <url>/2022/12/25/redis%E4%B8%8E%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="redis与限流算法"><a href="#redis与限流算法" class="headerlink" title="redis与限流算法"></a>redis与限流算法</h1><p>由于 Web 应用在部署时，常常使用多网关，微服务的组织形式，因此经常需要在进程间进行数据交换，从而达到更好的限流效果。由于限流算法中的数据具有很强的时效性，并且不需要较高的安全性，使用 redis 组件来实现限流算法是一个很好的选择。</p><p>常见的限流算法一共有四种：固定窗口，滑动窗口，桶漏算法，令牌桶。这些算法具有一定的复杂度，需要借助 redis 中的 lua 脚本来实现。</p><h2 id="固定窗口"><a href="#固定窗口" class="headerlink" title="固定窗口"></a>固定窗口</h2><p>每个请求到达时，检查是否具有窗口存在，如果无窗口存在，则将创建窗口并且设置过期时间、允许通过的流量。此后，每一个请求到达时，如果窗口存在，都将流量-1，如果不能够完成操作，则需要等待。优点是性能比较好，实现简单，缺点是精度不够高，这个适合作为每一个用户的限流次数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- Check whether a single user reaches the traffic limit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;exists&quot;</span>,key) == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&quot;set&quot;</span>,key,<span class="number">10</span>,<span class="string">&quot;EX&quot;</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> count = <span class="built_in">tonumber</span>(redis.call(<span class="string">&quot;decr&quot;</span>,key))</span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口是固定窗口的一种优化，它将窗口改变为一个链表，如将一分钟划分为 6 段，每一段代表十秒钟。每个请求到达时，先检查所有窗口是否过期，如果过期则删除窗口，并且检查最后一个窗口的创建时间，如果窗口超过 10s，那么在其后面写入多个窗口，并在最后一个窗口处写入值。滑动窗口同样适合作为每一个用户的限流算法。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--获取KEY</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">--获取ARGV内的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 缓存时间</span></span><br><span class="line"><span class="keyword">local</span> expire = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 当前时间</span></span><br><span class="line"><span class="keyword">local</span> currentMs = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="comment">-- 最大次数</span></span><br><span class="line"><span class="keyword">local</span> count = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"><span class="comment">--窗口开始时间</span></span><br><span class="line"><span class="keyword">local</span> windowStartMs = currentMs - expire * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">--获取key的次数</span></span><br><span class="line"><span class="keyword">local</span> current = redis.call(<span class="string">&#x27;zcount&#x27;</span>, key, windowStartMs, currentMs)</span><br><span class="line"></span><br><span class="line"><span class="comment">--如果key的次数存在且大于预设值直接返回当前key的次数</span></span><br><span class="line"><span class="keyword">if</span> current <span class="keyword">and</span> <span class="built_in">tonumber</span>(current) &gt;= count <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tonumber</span>(current);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清除所有过期成员</span></span><br><span class="line">redis.call(<span class="string">&quot;ZREMRANGEBYSCORE&quot;</span>, key, <span class="number">0</span>, windowStartMs);</span><br><span class="line"><span class="comment">-- 添加当前成员</span></span><br><span class="line">redis.call(<span class="string">&quot;zadd&quot;</span>, key, <span class="built_in">tostring</span>(currentMs), currentMs);</span><br><span class="line">redis.call(<span class="string">&quot;expire&quot;</span>, key, expire);</span><br><span class="line"></span><br><span class="line"><span class="comment">--返回key的次数</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">tonumber</span>(current)</span><br></pre></td></tr></table></figure><h2 id="桶漏算法"><a href="#桶漏算法" class="headerlink" title="桶漏算法"></a>桶漏算法</h2><p>记录每一个请求，并且将其放入缓冲区中，缓冲区具有上限，如果超出缓冲区则直接拒绝。每隔设置的时间间隔，会从缓冲区中选取设置数量的请求进行处理。优点是请求处理非常平滑，缺点是不能够应对突发请求。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 1 代表成功，0 代表失败</span></span><br><span class="line"><span class="keyword">local</span> capacity = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">local</span> acquire = <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>])</span><br><span class="line"><span class="keyword">local</span> water = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;hget&#x27;</span>, KEYS[<span class="number">1</span>] , KEYS[<span class="number">2</span>]) <span class="keyword">or</span> <span class="number">0</span>) </span><br><span class="line"><span class="keyword">local</span> <span class="built_in">time</span> = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;hget&#x27;</span>, KEYS[<span class="number">1</span>] , KEYS[<span class="number">3</span>]) <span class="keyword">or</span> now) </span><br><span class="line">water = <span class="built_in">math</span>.<span class="built_in">max</span>(<span class="number">0</span>, water - (now - <span class="built_in">time</span>) * rate)</span><br><span class="line">redis.call(<span class="string">&#x27;hset&#x27;</span> , KEYS[<span class="number">1</span>] ,KEYS[<span class="number">3</span>] , now)</span><br><span class="line"><span class="keyword">if</span> (water + acquire &lt;= capacity) <span class="keyword">then</span></span><br><span class="line">  redis.call(<span class="string">&#x27;hset&#x27;</span> , KEYS[<span class="number">1</span>] , KEYS[<span class="number">2</span>] , water + acquire)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><p>桶漏算法的相反操作。每隔一段时间，将名额放入缓冲区中，名额具有上限，每一个请求需要拿到一个名额，否则会被拒绝处理。令牌桶算法允许的瞬时压力是桶上限+ 定时刷新名额，持续压力是定时刷新的名额。允许一定突发压力出现。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- @param key 令牌的唯一标识</span></span><br><span class="line"><span class="comment">--- @param permits  请求令牌数量</span></span><br><span class="line"><span class="comment">--- @param curr_mill_second 当前时间</span></span><br><span class="line"><span class="comment">--- 0 没有令牌桶配置；-1 表示取令牌失败，也就是桶里没有令牌；1 表示取令牌成功</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">acquire</span><span class="params">(key,  permits, curr_mill_second)</span></span></span><br><span class="line">    <span class="keyword">local</span> local_key =  key <span class="comment">--- 令牌桶key ,使用 .. 进行字符串连接</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tonumber</span>(redis.<span class="built_in">pcall</span>(<span class="string">&quot;EXISTS&quot;</span>, local_key)) &lt; <span class="number">1</span> <span class="keyword">then</span> <span class="comment">--- 未配置令牌桶</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">--- 令牌桶内数据：</span></span><br><span class="line">    <span class="comment">---             last_mill_second  最后一次放入令牌时间</span></span><br><span class="line">    <span class="comment">---             curr_permits  当前桶内令牌</span></span><br><span class="line">    <span class="comment">---             max_permits   桶内令牌最大数量</span></span><br><span class="line">    <span class="comment">---             rate  令牌放置速度</span></span><br><span class="line">    <span class="keyword">local</span> rate_limit_info = redis.<span class="built_in">pcall</span>(<span class="string">&quot;HMGET&quot;</span>, local_key, <span class="string">&quot;last_mill_second&quot;</span>, <span class="string">&quot;curr_permits&quot;</span>, <span class="string">&quot;max_permits&quot;</span>, <span class="string">&quot;rate&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> last_mill_second = rate_limit_info[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">local</span> curr_permits = <span class="built_in">tonumber</span>(rate_limit_info[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">local</span> max_permits = <span class="built_in">tonumber</span>(rate_limit_info[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">local</span> rate = rate_limit_info[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">--- 标识没有配置令牌桶</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(max_permits) == <span class="string">&#x27;boolean&#x27;</span> <span class="keyword">or</span> max_permits == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">   <span class="comment">--- 若令牌桶参数没有配置，则返回0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(rate) == <span class="string">&#x27;boolean&#x27;</span> <span class="keyword">or</span> rate == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> local_curr_permits = max_permits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">--- 令牌桶刚刚创建，上一次获取令牌的毫秒数为空</span></span><br><span class="line">    <span class="comment">--- 根据和上一次向桶里添加令牌的时间和当前时间差，触发式往桶里添加令牌，并且更新上一次向桶里添加令牌的时间</span></span><br><span class="line">    <span class="comment">--- 如果向桶里添加的令牌数不足一个，则不更新上一次向桶里添加令牌的时间</span></span><br><span class="line">    <span class="comment">--- ~=号在Lua脚本的含义就是不等于!=</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">type</span>(last_mill_second) ~= <span class="string">&#x27;boolean&#x27;</span>  <span class="keyword">and</span> last_mill_second ~= <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span>(curr_mill_second - last_mill_second &lt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="comment">--- 生成令牌操作</span></span><br><span class="line">        <span class="keyword">local</span> reverse_permits = <span class="built_in">math</span>.<span class="built_in">floor</span>(((curr_mill_second - last_mill_second) / <span class="number">1000</span>) * rate) <span class="comment">--- 最关键代码：根据时间差计算令牌数量并匀速的放入令牌</span></span><br><span class="line">        <span class="keyword">local</span> expect_curr_permits = reverse_permits + curr_permits;</span><br><span class="line">        local_curr_permits = <span class="built_in">math</span>.<span class="built_in">min</span>(expect_curr_permits, max_permits);  <span class="comment">--- 如果期望令牌数大于桶容量，则设为桶容量</span></span><br><span class="line">        <span class="comment">--- 大于0表示这段时间产生令牌，则更新最新令牌放入时间</span></span><br><span class="line">        <span class="keyword">if</span> (reverse_permits &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            redis.<span class="built_in">pcall</span>(<span class="string">&quot;HSET&quot;</span>, local_key, <span class="string">&quot;last_mill_second&quot;</span>, curr_mill_second)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        redis.<span class="built_in">pcall</span>(<span class="string">&quot;HSET&quot;</span>, local_key, <span class="string">&quot;last_mill_second&quot;</span>, curr_mill_second)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="comment">--- 取出令牌操作</span></span><br><span class="line">    <span class="keyword">local</span> result = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> (local_curr_permits - permits &gt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        redis.<span class="built_in">pcall</span>(<span class="string">&quot;HSET&quot;</span>, local_key, <span class="string">&quot;curr_permits&quot;</span>, local_curr_permits - permits)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        redis.<span class="built_in">pcall</span>(<span class="string">&quot;HSET&quot;</span>, local_key, <span class="string">&quot;curr_permits&quot;</span>, local_curr_permits)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="四种算法对比"><a href="#四种算法对比" class="headerlink" title="四种算法对比"></a>四种算法对比</h2><ul><li><p>固定窗口：不需要定时维护，实现非常简单，单个用户限流</p></li><li><p>滑动窗口：可以在用户请求线程中维护，精度需求较高的单个用户限流</p></li><li><p>桶漏算法：一般用于保护数据库等后端系统不会被突发压力击溃。</p></li><li><p>令牌桶：一般用于统一网关的限流，允许合理范围内应对突发压力。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 两次挥手？记录一次抓包异常</title>
      <link href="/2022/12/25/TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B%E2%80%94%E2%80%94%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%8A%93%E5%8C%85%E5%BC%82%E5%B8%B8/"/>
      <url>/2022/12/25/TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B%E2%80%94%E2%80%94%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%8A%93%E5%8C%85%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-两次挥手？记录一次抓包异常"><a href="#TCP-两次挥手？记录一次抓包异常" class="headerlink" title="TCP 两次挥手？记录一次抓包异常"></a>TCP 两次挥手？记录一次抓包异常</h1><h2 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h2><p>我们都知道，正常的 TCP 关闭连接时是需要发生四次挥手的。但是在 wireshark 的一次抓包过程中，我却偶然发现了有一个 tcp 连接只发生了两次挥手，即客户端发送了 FIN 报文，并且收到了服务端的 ACK 报文，但是服务端却没有继续发送 FIN 报文，本次异常断开的抓包结果如下，图中的 192.168.10.1 是某经过系统刷机的路由器：</p><p><img src="/images/image-20221225152318823.png" alt="img"></p><p>这其实是由于服务端在收到客户端的关闭请求后，并没有使用系统调用 shutdown 或者 close 来对 tcp 通道进行关闭，导致这时的 tcp 连接变成了一个半双工的状态，即服务端仍然保持写入状态（虽然并没有数据需要写入)。这里可能是路由器的 http 服务中忘记对客户端连接进行关闭所导致的一次 tcp 异常断开。</p><h2 id="孤儿-socket-在-tcp-挥手的作用"><a href="#孤儿-socket-在-tcp-挥手的作用" class="headerlink" title="孤儿 socket 在 tcp 挥手的作用"></a>孤儿 socket 在 tcp 挥手的作用</h2><p>在本次的 tcp 连接断开异常后，如果服务端还有数据需要写入，但是此时客户端中的浏览器已经关闭，这种情况下操作系统是如何处理的呢？</p><p>这里需要提到一个概念：孤儿 socket。这是 socket 的一个特殊的状态，该状态下用户进程不再继续对 socket 持有，不进行写入和读取操作，但是 socket 仍未完成 tcp 的四次挥手，这时系统栈中仍然会保留该 socket 的资源来进行 tcp 挥手操作。孤儿 socket 的引入就是为了解决 tcp 连接不能够正常断开的情况的。在孤儿 socket 的引入后，一次 tcp 挥手的流程可以分为不同的情况：</p><p>不优雅的 tcp 关闭（一）：客户端直接调用 close</p><ul><li>客户端需要关闭连接时，直接使用 close 系统调用，发送一个 FIN 报文，此后 socket 资源栈全部由系统负责（孤儿 socket）。</li><li>服务端接收到 FIN 报文，并回复 ACK 报文，若此时服务端无数据需要写入，则再发送一个 FIN，接收到 ACK 后 socket 正常释放。</li><li>若服务端接收到 FIN 报文后，仍然需要写入数据，由于对端已经全双工关闭，无法接受到数据，此时对端的操作系统协议栈在收到数据后会给服务端发送 RST 报文，提醒对端协议栈进行关闭。此时进程继续写入数据会收到一个 EOF 提醒，进程必须放弃写入，否则继续写入将会收到一个 SIGPIPE 信号。</li></ul><p>不优雅的 tcp 关闭（二）：客户端进程崩溃</p><ul><li>客户端进程崩溃会导致服务端进程不会收到任何 FIN 报文，此时的客户端 socket 同样是一个孤儿 socket。</li><li>客户端进程崩溃的情况下，系统的协议栈会自动给对方发送 RST 报文来重置连接。</li></ul><p>优雅的 tcp 关闭：使用 shutdown 进行关闭</p><ul><li>客户端需要关闭连接时，使用 shutdown 关闭写入端，使 tcp 成为半双工状态，向对方发送 FIN 报文。</li><li>服务端接收到 FIN 报文，回复 ACK 报文，在完成写入后使用 close 或 shutdown 系统调用关闭连接，发送 FIN 报文。</li><li>客户端接收到 FIN 报文并且回复一个 ACK 报文。</li></ul><h2 id="HTTP-重定向"><a href="#HTTP-重定向" class="headerlink" title="HTTP 重定向"></a>HTTP 重定向</h2><p>如果仔细看上述的抓包结果，可以注意到当客户端收到一个 HTTP 302 报文后，客户端会主动关闭 tcp 连接，并且重启一个新的 tcp 连接来访问重定向后的 url。这是因为重定向后的结果可能在一个新的 host 下，所以旧连接不一定可用，重新启动一个 tcp 连接更加安全。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程文档汇总</title>
      <link href="/2022/12/25/%E5%B7%A5%E7%A8%8B%E6%96%87%E6%A1%A3%E6%B1%87%E6%80%BB/"/>
      <url>/2022/12/25/%E5%B7%A5%E7%A8%8B%E6%96%87%E6%A1%A3%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>这里汇总了我因学习需要或一时兴起写的小项目。</p><h2 id="工程文档链接"><a href="#工程文档链接" class="headerlink" title="工程文档链接"></a>工程文档链接</h2><ul><li><p>MVCC：一个基于跳跃表的进程内并发读写数据结构。 <a href="https://github.com/tangrc99/MVCC">github仓库</a> <a href="https://tangrc99.github.io/MVCC">项目文档链接</a></p></li><li><p>Gossip：一个基于 gossip 协议的分布式信息交互组件。<a href="https://github.com/tangrc99/Gossip">github仓库</a> <a href="https://tangrc99.github.io/Gossip">项目文档链接</a></p></li><li><p>MLog：一个仿照 WiredTiger 日志系统的玩具项目。<a href="https://github.com/tangrc99/MLog">github仓库</a> <a href="https://tangrc99.github.io/MLog">项目文档链接</a></p></li><li><p>TinySwarm：一个轻量级的分布式调度系统。 <a href="https://github.com/tangrc99/TinySwarm">github仓库</a> <a href="https://tangrc99.github.io/TinySwarm">项目文档链接</a></p></li><li><p>MemTable：使用 go 语言仿写的 redis 服务器。  <a href="https://github.com/tangrc99/MemTable">github仓库</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis 为什么那么快</title>
      <link href="/2022/12/23/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB/"/>
      <url>/2022/12/23/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-为什么那么快"><a href="#Redis-为什么那么快" class="headerlink" title="Redis 为什么那么快"></a>Redis 为什么那么快</h1><p>Redis 的速度为什么那么快？这个问题有点过于宽泛了，必须要确定 redis 的比较对象才方便进行比较。对比传统的硬盘数据库来说，redis 的读写操作大部分都只发生在内存中，不需要昂贵的硬盘 IO；对比较为新型的 NoSQL 数据库而言，这些数据库如 MongoDB 虽然也大量利用了内存缓存，但相比之下，redis 单索引、不保证数据安全性的特点使得 redis 的读写 flow 更加短，因此能够取得更好的效果；相比于同类型的缓存服务，如 memcached，redis 的速度其实并没有太大的优势，这是 redis 的单线程事务模型带来的缺点。</p><h2 id="高效的数据结构"><a href="#高效的数据结构" class="headerlink" title="高效的数据结构"></a>高效的数据结构</h2><p>redis 是一个基于内存的数据库，因而可以使用更加高效灵活的数据结构——哈希表。由于哈希表的查询时间复杂度为 O(1)，在千万级别的数据量下，单次查询性能仍然能够保持在 us 级别。</p><h2 id="高效的网络-IO-模型"><a href="#高效的网络-IO-模型" class="headerlink" title="高效的网络 IO 模型"></a>高效的网络 IO 模型</h2><p>最新版本的 redis 中，网络 IO 线程与事件处理线程是分离的，是一个非标准的 reactor 模式。这种非标准的设计主要是考虑了复杂度问题，如果使用多线程进行事务处理需要付出高昂的工程代价，并且只能够获得大概 8%左右的性能提升（参考 memcached 与 redis 的性能测试对比）。</p><p>在引入多线程 IO 后，仍然只有主线程是负责 epoll 的逻辑的，流程可以简述如下：</p><p>1、主线程负责接收建立连接请求，获取 socket 放入全局等待读处理队列<br>2、主线程处理完读事件之后，通过 RR(Round Robin) 将这些连接分配给这些 IO 线程<br>3、主线程阻塞等待 IO 线程读取 socket 完毕<br>4、主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行<br>5、主线程阻塞等待 IO 线程将数据回写 socket 完毕<br>6、解除绑定，清空等待队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> 有可读 socket&#123;</span><br><span class="line">    平均分配 socket 给 IO 线程组</span><br><span class="line">  &#125;</span><br><span class="line">  等待所有 IO 线程组读取完成</span><br><span class="line">  </span><br><span class="line">  按照次序执行所有的 IO 请求</span><br><span class="line">    </span><br><span class="line">  等待所有 IO 线程组写入完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO 线程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  </span><br><span class="line">  等待主线程分配 IO 读事件</span><br><span class="line">  </span><br><span class="line">  通知主线程读取完成（原子操作）</span><br><span class="line">    </span><br><span class="line">  等待主线程分配 IO 读事件</span><br><span class="line">  </span><br><span class="line">  通知主线程写入完成（原子操作）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis 这里的 IO 事件是按组进行的，主线程会阻塞等待一组中所有的 IO 事件读或者写完成。这里主要是为了防止事件乱序执行，否则可以等待单个 IO 完成后就执行任务。由于 IO 过程非常快，所以这里的性能损耗基本可以忽略不计。</p><h2 id="成熟的事件调度机制"><a href="#成熟的事件调度机制" class="headerlink" title="成熟的事件调度机制"></a>成熟的事件调度机制</h2><p>redis 的事件主要可以分为 IO 事件、定时事件、后台线程事件这三种，主循环只负责处理 IO 事件和定时事件，这两种事件的处理速度较快因而可以放在一起处理。</p><p>在 redis 的主循环处理流程伪代码可以表示如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">最大等待时间 = 最近定时任务 - 当前时间</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 有IO事件可以处理 &#123;</span><br><span class="line"><span class="keyword">if</span> IO为轻量级任务</span><br><span class="line">    处理 IO 事件</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    放入后台线程处理</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">休眠最大等待时间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 有定时任务可以处理</span><br><span class="line">处理定时任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我接触到 redis 比较早，在初学时比较困惑，为什么这种循环处理的逻辑能够保证客户端请求的高效处理，并且如何保证定时任务及时处理的。</p><p>首先说明如何保证定时任务的处理。在主循环处理流程中，IO 事件即客户端请求事件是优先处理的，并不保证定时事件一定能够及时处理，但是这种延迟是非常细微的。以 <code>std::unordered_map</code> 为例，在 1000W 级别的数据中，平均的单条读取时间是 1us 级别的，因此单个 IO 事件即使是计算了读取和写入 socket 所耗费的时间，通常也是不足 1ms 的，只会是 10 us 级别。在这种操作速度的数量级下，即使是同一时间到达万级请求，也不会对定时任务造成秒级别的延迟，这是完全可以接受的。另外，受限于物理机器的网卡速度、协议栈复制速度等因素，一次主循环中并不会到达过多的请求。因此，完全不必担心定时任务会因为短时间内出现大量 IO 请求而延迟较大。</p><p>既然用户 IO 请求不会过多影响定时任务的触发时机，那么定时任务显然也不会影响到 IO 事件的处理。redis 中的定时任务基本上可以分为以下几种：</p><ul><li>过期键的删除操作</li><li>更新服务器状态</li><li>清理过期和失效的客户端</li><li>尝试开始持久化操作</li><li>与其他服务器同步消息</li></ul><p>redis 中这些定时任务的执行时间通常更短，因为任务所查询的数据量级是远远小于 redis 数据库的数据量级的，并且 redis 内部具有计时机制来主动防止定时任务消耗过多时间。这些定时任务会每隔 100ms 执行一次，每次的总执行时间在 ms 级别，不会对客户端请求造成很大的延迟。</p><p>归根结底，redis 采用的这种事件循环调度机制，是考虑到单个事件的执行时间非常短，这主要还是由于所有的操作都只与内存进行交互，现代计算机的内存速度是非常快的。</p><h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><p>redis 中比较重量级的事件会考虑放入到后台线程中来完成，防止主循环的单次循环时间过长，使客户端请求延迟增加。会放入到后台线程中的事件主要有：</p><ul><li>大键的惰性删除</li><li>AOF 持久化刷盘</li><li>关闭 file descriptor</li></ul><p>这些事件在执行过程中，可能产生的耗时是毫秒级别的，与其他的事件的时间相差过大，直接在主线程中执行可能会造成循环时间过长。</p><p>redis 中是通过队列的方式来实现主线程与后台线程之间的任务分配的，以上三个事件都有各自的队列，这是为了防止某一个类型的后台任务过多，从而阻塞了其他种类任务的执行。每次后台线程选择任务执行时会采用一定的策略公平公正地对三种任务执行，防止某一种事件过长时间无法执行。</p><h2 id="合适的高可用架构"><a href="#合适的高可用架构" class="headerlink" title="合适的高可用架构"></a>合适的高可用架构</h2><p>redis 官方提供了哨兵模式的高可用架构，这是一个比较松散的高可用方案。相比于 etcd、MongoDB 中的高可用实现，redis 的哨兵模式会舍弃一部分的数据安全性来换取更高的性能。</p><p>哨兵模式其本质上是一个能够自动切换节点的主从复制结构。同其他数据库的主从复制结构类似，redis 中的主从复制也是异步复制的过程。异步复制的好处是性能较高，不会过多影响主节点的吞吐量，这正是 redis 所需要的，但缺点就是会带来数据延迟，当主节点下线可能会造成一部分数据的丢失。但由于 redis 所存储的数据本身不需要过高的安全性，所以 redis 完全可以舍弃一部分安全性来换取更高的吞吐量。并且这种因主节点下线造成的数据丢失数量是非常少的。</p><p>如果引入 raft、paxos 等选举算法，虽然能够保证更高的可用性，但是会造成非常严重的性能劣化。想象一下，引入这些选举算法，所有的客户端请求相当于是一个 2pc，需要引入主节点-从节点的通信延迟、从节点提交的延迟，这里性能可能会折半甚至更低。这就是为什么 redis 并没有引入选举算法——一切为了性能。</p><p>哨兵模式的高可用体现在，故障自动恢复的容灾而不是数据一致性的保障。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>etcd 设计亮点与工程优化</title>
      <link href="/2022/12/13/ETCD%20%E8%AE%BE%E8%AE%A1%E4%BA%AE%E7%82%B9%E4%B8%8E%E5%B7%A5%E7%A8%8B%E4%BC%98%E5%8C%96/"/>
      <url>/2022/12/13/ETCD%20%E8%AE%BE%E8%AE%A1%E4%BA%AE%E7%82%B9%E4%B8%8E%E5%B7%A5%E7%A8%8B%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="etcd-设计亮点与工程优化"><a href="#etcd-设计亮点与工程优化" class="headerlink" title="etcd 设计亮点与工程优化"></a>etcd 设计亮点与工程优化</h1><h2 id="raft-协议"><a href="#raft-协议" class="headerlink" title="raft 协议"></a>raft 协议</h2><p>根据 MIT6.824 的讲解，在原生的 raft 协议中，所有的读写操作都是完全串行的，虽然能够保证读写的线性一致性，但是性能非常差，必须要经过工程上的优化才能够获得比较好的性能。</p><h3 id="ReadIndex-解决读操作落盘问题"><a href="#ReadIndex-解决读操作落盘问题" class="headerlink" title="ReadIndex 解决读操作落盘问题"></a>ReadIndex 解决读操作落盘问题</h3><p>为了避免网络分区问题出现时，旧主仍然在为客户端提供读服务，在最初的 raft 协议中，读操作也同样需要通过 raft log 落盘，以此来保证网络分区问题出现时，旧主停止所有的读写服务。由于原生 raft 协议中操作是串行化的，每一个读操作都需要进行落盘显然会使得读性能很低，必须要作出一定的优化。</p><p>ReadIndex 是 raft 论文作者所提出的一种优化方法，核心的思想有两点，一是 Leader 在处理客户端请求时必须要确认自己仍然是 Leader ，二是读请求只能够看到已经到达大多数节点的数据。在 ReadIndex 实现下，每一次读请求返回时，Leader 需要向每一个从节点发送心跳来确认自身状态，并且更新当前的数据可见区域。这种处理相比于原生的 raft 协议，仍然需要向所有的节点发送 rpc，但是避免了读操作的落盘，但是读操作仍然会导致与从节点的通信。每当一个写操作被从节点成功写入 entry，都会向主节点发送一个通知来更新状态。只有被提交到大多数节点中的请求，才会对读操作可见。</p><p>事实上，并不需要每一次读操作都进行一次心跳包请求，只需要每隔一段时间进行心跳包请求即可。这样可以节约网络带宽，但是会造成部分读操作等待，可能会造成一定的读延迟。在 etcd 的实现中，主节点会定期询问并更新当前集群的最低水位，这样可以确保最低水位之前的读操作都是可以提交的。</p><h3 id="noop-解决-Stale-Read-问题"><a href="#noop-解决-Stale-Read-问题" class="headerlink" title="noop 解决 Stale Read 问题"></a>noop 解决 Stale Read 问题</h3><p>Stale Read 是由幽灵复现问题带来的，即一个主节点在任期中的最后几条 log 并没有及时响应，下一轮选举中，另一节点当选并且没有写入数据后下线，第三轮选举中，最初的主节点又成功当选。这样会导致某几个记录在第二轮选举中无法被查询到，但是却能够在第三轮选举周期中被查询到。这显然是违反了线性一致的。</p><p>在 raft 协议中，为了避免幽灵复现问题，使用了 Noop 机制。每一个新主在完成选举后必须 commit 一条空记录，该记录带有最新的任期，才能够处理读操作。当 Noop 成功提交后，由于旧主是不具备最新任期日志的，所以无法再一次当选，因此不会出现幽灵复现问题。</p><h3 id="PreCandidate-避免不必要选举"><a href="#PreCandidate-避免不必要选举" class="headerlink" title="PreCandidate 避免不必要选举"></a>PreCandidate 避免不必要选举</h3><p>考虑以下一种状况：如果某个 raft 节点由于网络故障无法收到其他节点的网络包，那么它将会一直处于 Candidate 状态。由于无法选举成功，每一次选举失败都会导致 Term 自加，一段时间后，该节点的 Term 号会比较大。这时，如果网络突然恢复将会发生一轮选举。但是由于该节点的日志是过时的，并不会选举成功，相当于进行了一次不必要的选举。</p><p>为了解决这种问题，etcd 在三种 raft 状态之外还引入了 PreCandidate 状态。从节点心跳超时并不会直接进入 Candidate 状态，而是进入 PreCandidate 状态，并且发送 rpc 询问其他节点自身是否可以获得投票（预选举），只有询问结果超过半数时才会进入 Candidate 状态。如果从节点在 PreCandidate 状态进行预选举失败，将会退回到原有的状态。PreCandidate 状态的节点，仍然与 Follower 状态节点保持相同的选举机制，可以给其他投票。</p><p>PreCandidate 的引入不仅能够解决上述网络分区带来的选举问题，还能够加速正常选举的收敛——较慢的节点并不会真正参加选举，只能够进行投票，从而使能够成功选主的节点有更大概率获得半数以上投票。</p><h3 id="Batch-与-Pipeline-加快读写进程"><a href="#Batch-与-Pipeline-加快读写进程" class="headerlink" title="Batch 与 Pipeline 加快读写进程"></a>Batch 与 Pipeline 加快读写进程</h3><p>由于对每一条 Log Entry 都进行刷盘会导致效率较低，etcd 中会将同一时刻到达的写请求批量发送给从节点，从节点也会批量对 log 进行刷盘操作，这种实现在避免事务进行等待的前提下实现了日志的批量刷盘。</p><p>但是单纯使用 Batch 优化是不够的，如果单个 Batch 比较大，可能从节点会分批次进行持久化处理，这可能会导致某些小事务被阻塞无法提交。所以，在从节点提交状态时，并不会使用 Batch 的模式，而是使用 Pipeline 的模式，每次存在新的已提交日志就会返回主节点结果。</p><h3 id="对比-MongoDB-中的实现"><a href="#对比-MongoDB-中的实现" class="headerlink" title="对比 MongoDB 中的实现"></a>对比 MongoDB 中的实现</h3><p>MongoDB 的设计目标更多地考虑了高性能的问题，对数据的线性一致性有着较多的取舍，也正是这些原因 MongoDB 并不适合数据安全性要求较高的场景。</p><ul><li>网络分区下读问题：MongoDB 中的实现并不能够保证在双主状态下读到最新的数据，因为 MongoDB 的读取流程只会检查主节点当前的提交水位，而不会检查主节点租约是否有效。当网络分区问题发生时，旧主将会在一个心跳包的时间内继续进行工作，在该心跳包内读取到的数据可能已经被更新，即使采用 r : majority 选项也不能够保证读到的是最新数据。（不确定）</li><li>网络分区下写问题：MongoDB 中的实现可以保证 w : majority 写入安全，需要人工来保证 w : 1 级别的写入安全。当网络分区出现并恢复后，旧主会作为从节点工作，其中不一致的数据将会被写入到回滚文件中，具体如何操作需要由用户决定。参考链接：<a href="https://www.mongodb.com/docs/manual/core/replica-set-rollbacks/">https://www.mongodb.com/docs/manual/core/replica-set-rollbacks/</a></li><li>选举机制：由于 MongoDB 的 w : n 机制存在，其实并不能够保证数据一定会被写入到大多数节点上。所以 MongoDB 在 raft 选举的基础上增加了反对票选项，被投反对票的节点大概率是无法当选的，这是为了保证拥有最新数据的节点当选。</li><li>选举后的数据状态问题：MongoDB 中选举成功后，新主并不会直接按照自身的状态来确认当前状态，而是会要求其他节点发送与自身不一致的数据，然后再根据具体情况来判断是否保留。这同样是因为 w : n 机制的存在。</li><li><strong>写入超时</strong>：这是 MongoDB 中一个非常特殊的错误。如果在一段时间内无法达到规定的写入要求，会返回这个错误。该错误不会对写入内容进行直接回滚，因为该内容可能能够提交成功。客户端需要使用特殊的机制来判断发生该错误后，是否写入成功。</li></ul><p>通过对比，etcd 通过牺牲读性能获取了线性读，而 MongoDB 则正好相反，这是因为二者的定位不同。另外，在 MongoDB 的实现中，选举通常需要耗费更长的时间，通常情况下在 5s 左右，这种牺牲是为了保证写入的灵活性。</p><h2 id="数据库部分"><a href="#数据库部分" class="headerlink" title="数据库部分"></a>数据库部分</h2><h3 id="MVCC——-内存数据库变为硬盘数据库反而变快了？"><a href="#MVCC——-内存数据库变为硬盘数据库反而变快了？" class="headerlink" title="MVCC—— 内存数据库变为硬盘数据库反而变快了？"></a>MVCC—— 内存数据库变为硬盘数据库反而变快了？</h3><p>在 etcd v2 中使用的是内存数据库，而在 etcd v3 中使用的是硬盘数据库，但是后者的性能反而比前者更好，这是由于 MVCC 的引入。首先需要思考一个问题，raft 协议中所有操作都是串行提交的，为什么还会需要读写并发控制？原因有以下几点：</p><ul><li>通过对raft协议优化，读操作并不会写状态机，从而实现了读操作与写操作的并行。</li><li>虽然写 raft log 时是串行的，但是当 raft 状态机更新后，写入到数据库时仍然可能是并发的。</li><li>etcd 中的 watch 机制需要保存每一个键值对的历史版本，多个读操作可能会并发到达</li></ul><p>因此，MVCC 机制不仅可以解决并发问题，还很好地契合了 etcd 的应用场景。由于 MVCC 版本链表可能较大，不太适合直接存储在内存中，因而从内存数据库切换到了硬盘数据库。虽然单个的读写操作性能降低了，但是却允许了更多操作并发，因而整体性能反而是上升的。</p><p>在 etcd 中，MVCC 机制中每一个键值对都有一个 revision。revision 结构体包含两个部分：全局唯一事务号、事务内部编号。这种实现方法同其他的数据库类似。</p><h3 id="读操作等待"><a href="#读操作等待" class="headerlink" title="读操作等待"></a>读操作等待</h3><p>etcd 中并非所有读请求都会被立即处理，而是有可能会被阻塞一段时间。例如当一个线性读请求到达从节点，版本号为 v2，而当前从节点的提交版本号为 v1，且 v1&lt; v2，那么该读请求就会一直阻塞直到版本号到达 v2。这里发生的阻塞等待是为了保证线性读：如果一个客户端发送了两次读请求，并且两个读请求被分派到了两个从节点上，因为两个从节点的提交速度并不一样，如果不采取上述的策略就可能会发生更新的读请求反而读到了更旧版本的数据。</p><p>为了保证线性读，etcd 中<strong>写操作会阻塞该操作后的所有读操作</strong>。如果没有写操作发生，那么任何时刻 etcd 的读操作都不需要阻塞；如果有写操作发生，由于 etcd 的写操作是批量提交的，那么读操作就需要阻塞等待一个周期后才能够完成。</p><p>虽然这种等待看起来比较愚蠢，但是却能够简单有效地保证线性读的特性，结合 etcd 其他部分的优化，实际的性能并没有想象中差。如果需要避免读操作的等待，可以关闭线性读的选项，通过降低安全性来提升读取的性能。及时是关闭了线性读，etcd 的读安全性仍然是高于大于部分分布式数据库的。</p><h3 id="事务批量提交"><a href="#事务批量提交" class="headerlink" title="事务批量提交"></a>事务批量提交</h3><p>数据库中的事务批量提交是建立在 raft 层中 Batch 优化的基础上的。raft 层的 Batch 优化使得数据库写入的并发压力提高了。而提升数据库写入吞吐量的一个经典优化就是批量提交。当一个写事务完成 raft 层的复制后，并不会被立刻插入到 boltDB 中，而是会写入缓冲区中然后等待一定的时间或者使用其他 trigger 触发后。被写入缓冲区的操作会合并成为一整个事务插入事务库。这种优化使得在某一时刻基本上是不存在写操作之间的并发的，因此 MVCC 的统一事务管理器并不会存在版本号的竞争问题。而 MVCC 中比较困难的优化就是版本号的竞争问题，etcd 这里的事务批量提交的优化非常巧妙。</p><h3 id="读写缓冲区"><a href="#读写缓冲区" class="headerlink" title="读写缓冲区"></a>读写缓冲区</h3><p>在 etcd v3.2 版本中引入了读写缓冲区和读写锁机制来改善读写性能。这里改善主要是针对 etcd v3.1 版本中读操作与读操作也无法并发，但实际上经过优化后的版本还是具有一定的问题，该问题最终在 v3.4 版本引入的完全并发读解决。</p><h3 id="完全并发读"><a href="#完全并发读" class="headerlink" title="完全并发读"></a>完全并发读</h3><p>完全并发读是 etcd v3.4 中引入的优化，该优化主要是为了解决 boltdb 中事务锁和读写锁粒度过粗的问题。首先介绍完全并发读要解决的问题：</p><p>由于 etcd 默认是线性读，需要避免不可重复读和幻读的影响。在 etcd 最初的实现中，读写操作是通过读写锁来控制的，这是一种不太适合 etcd 使用场景的实现——etcd 中的所有读操作都是范围查询的，并且经常面临着较为 expensive 的读事务。如果一个读事务跨越了多个写事务批量提交的时间点，就会导致大量的写请求堆压，最终在长事务结束时全部提交，增加了读写锁的竞争压力，导致 etcd 的性能在某个时间点急剧下降。参考 <a href="https://www.cnblogs.com/alisystemsoftware/p/11555426.html">https://www.cnblogs.com/alisystemsoftware/p/11555426.html</a></p><p>完全并发读包含以下几个核心点，按照个人的理解其实就是多缓冲区加惰性刷盘：</p><ul><li>取消读写锁，已经开始的读写操作并不会相互阻塞。</li><li>使用快照机制 concurrentReadTxn 作为读视图</li></ul><p>这两条核心思想其实需要解决的核心问题就是如何寻找一个合适的时机将写操作持久化到数据库中，etcd 中的实现使用的是经典的多缓冲区加滑动窗口的机制。我们将已经落盘的数据版本视为 v1，每次需要写事务需要提交的版本为 v2、v3… vn。当写事务持久化数据时，并不直接刷盘，而是先写 WAL，然后将数据放入到一个缓冲区链表中，确保数据不会丢失。</p><p><strong>由于 etcd 中读写操作的特性</strong>，写操作开始前已经发送的读操作不会依赖该写操作的数据，而依赖该写操作数据的读操作必须等待该写操作完成后才会开始。因此，每次写操作进行提交时，可以先写入到缓冲区链表的尾部，并且将之前的部分全部持久化到硬盘中；这样就可以保证在任何一个时刻的读操作视角都是正确的。而在内存中的缓冲区应该都具有一个引用计数，当链表首段的引用计数为 0 时，才会执行内存释放的操作。这样就避免了写操作阻塞等待当前读操作完成。</p><p>当读操作发生时，需要从缓冲区链表的尾部（最新版本）拷贝一个副本，副本的引用计数加一，假设获得的缓冲区版本为 vn。读操作读数据时，会首先从缓冲区中查找，若无记录才会到落盘的数据中查找。这样，已经更新的数据在读操作中的视图是最新的。当读操作结束时，检查当前的引用计数，如果引用计数为 0，则缓冲区数据可以允许被释放。</p><p>当然，具体的执行逻辑要比上述流程稍微复杂。加入完全并发读机制后，写操作只需要等待所有读操作完成缓冲区的拷贝后就可以执行，大大减少了写提交的延迟。</p><h2 id="应用层部分"><a href="#应用层部分" class="headerlink" title="应用层部分"></a>应用层部分</h2><h3 id="双索引-Watch"><a href="#双索引-Watch" class="headerlink" title="双索引 Watch"></a>双索引 Watch</h3><p>参考链接 <a href="https://www.alicharles.com/article/etcd/etcd-watch/">https://www.alicharles.com/article/etcd/etcd-watch/</a></p><p>etcd 中的 watcher 分类两种，一种是精确到具体键值对的 Key Watcher，另外一种是监听某个范围的 Range Watcher。etcd 中建立了哈希表和红黑树两种索引来实现对不同类别 watcher 的查找。Key Watcher 可以直接使用哈希表进行匹配，而 Range Watcher 则需要对红黑树进行一次带记忆的深度优先搜索。当写事务完成修改时，会分别查找两种索引中是否具有满足匹配的 watcher。如果具备则会将信息发送到该 watcher 对应的 channel 中。</p><h3 id="Watch-推送机制"><a href="#Watch-推送机制" class="headerlink" title="Watch 推送机制"></a>Watch 推送机制</h3><p>由于 etcd 中所有写事务会被聚合为一个大事务完成，事务在执行 PUT 操作时，由 <code>notify</code> 方法同步推送。理想情况下，这些更新会被grpc 双向流立即发送给客户端。但实际上，由于网络、客户端程序阻塞、服务端事件堆积等问题，可能会造成部分 Watcher 无法及时消费最新消息，造成了消息异常和堆积的问题。</p><p>为了处理推送 Watch 消息的异常和堆积问题，etcd 中将 Watcher 分为三类：synced watcher，unsynced watcher，victim wathcer。参考 <a href="https://www.lixueduan.com/posts/etcd/13-watch-analyze-1/">https://www.lixueduan.com/posts/etcd/13-watch-analyze-1/</a></p><ul><li>synced watcher：状态正常，不存在历史消息未消费，可以随时等待新消息到来。</li><li>unsynced watcher: 状态正常，存在历史消息未消费，等待数据推送同步。</li><li>victim wathcer：状态不正常，存在历史消息未消费，因 channel 阻塞导致。</li></ul><p>etcd 并不会为 unsynced watcher 在内存中保留一个缓冲区来记录所有未发送的消息，这是考虑到 etcd 中的 watcher 可能会非常多，并且该 watcher 可能是一个 range watcher，如果未每一个 watcher 保留相应的历史消息缓冲，将会占用大量的内存。当 unsynced watcher 需要历史数据时，需要开启一个读事务，并且查询数据库，这是一个非常 expensive 的操作。因此，etcd 会每 100ms 将 unsynced watcher 分组合并后，<strong>通过一次遍历取出多个 watcher 需要的值</strong>。</p><p>而 victim watcher 则是由于 go 中的 channel 缓冲区已满而无法正常发送消息给 rpc stream，etcd 会将无法发送的那一条消息缓存，等待再一次发送。 这里的主要考虑如下：victim watcher 是一个异常状态，etcd 必须<strong>尽快完成消息重发防止 victim watcher 变更为 unsynced watcher</strong>，否则遍历数据库将会非常 expensive。因此，etcd 每 10ms 就会开始一次 victim watcher 的清理工作。</p><table><thead><tr><th>Watcher 类别</th><th>消息情况</th><th>处理机制</th><th>产生原因</th><th>备注</th></tr></thead><tbody><tr><td>synced watcher</td><td>不存在历史消息</td><td>等待新消息到来，直接推送</td><td>正常状态</td><td></td></tr><tr><td>unsynced watcher</td><td>存在历史消息</td><td>等待 syncWatchersLoop 调度，<strong>按组</strong>遍历数据库查找历史消息，并一次性全部推送给客户端，调度周期 100ms</td><td>客户端指定历史版本，或 victim watcher 阻塞过久</td><td>由于需要遍历数据库，核心思想是尽量等待有足够多的 watcher 一次遍历数据库拿出全部的历史值</td></tr><tr><td>victim wathcer</td><td>存在历史消息</td><td>等待 syncVitctimssLoop 调度，重新发送缓存的消息，调度周期 10ms</td><td>channel 缓冲区已满，无法正常推送消息</td><td>为了防止 victim watcher 阻塞过久，变成 unsynced watcher，必须尽快完成消息的重发</td></tr></tbody></table><h3 id="租约机制"><a href="#租约机制" class="headerlink" title="租约机制"></a>租约机制</h3><p>etcd v3 中键值对的过期时间具有两种模式，一种是使用客户端租约，另外一种是直接使用键值对 TTL。客户端租约存储采用的数据结构是堆实现的优先队列。客户端租约的模式能够解决键值对规模过大时过期键值对无法及时处理的问题，是一种广泛采用的处理模式。</p><p>单机的租约机制实现较为简单，但 etcd 是一个高可用、强一致系统，如何保证租约在不同节点之间的转移是需要关注的重点问题。在早期版本中，etcd 所采取是实现为：主节点只在租约导致数据发生变更时通知从节点，即只有租约创建和失效的时候才会与从节点进行同步。由于从节点并不会收到续约的通知，因此并不会主动进行淘汰操作。当选举发生时，新主将会自动给所有的租约进行续期。但如果网络波动很严重，导致不断选举，可能会造成租约无法过期的情况。</p><p>在新版本中，etcd 做出了以下两点优化，但是由于对性能影响较大，仍然处于实验阶段：</p><ul><li>定期同步租约信息给从节点</li><li>每次租约更新时，同步信息给从节点</li></ul><p>以上的两点优化，都是将租约信息也加入到了 raft 状态机里面，所以可能会对性能造成一定影响。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> etcd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WiredTiger 日志组提交</title>
      <link href="/2022/10/27/WiredTiger%E6%97%A5%E5%BF%97%E7%BB%84%E6%8F%90%E4%BA%A4/"/>
      <url>/2022/10/27/WiredTiger%E6%97%A5%E5%BF%97%E7%BB%84%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="WiredTiger-日志组提交"><a href="#WiredTiger-日志组提交" class="headerlink" title="WiredTiger 日志组提交"></a>WiredTiger 日志组提交</h1><p>Wiredtiger 中的日志系统设计参考了论文 Scalability of write-ahead logging on multicore and multisocket hardware，链接为 <a href="https://infoscience.epfl.ch/record/170505/files/aether-smpfulltext.pdf%E3%80%82">https://infoscience.epfl.ch/record/170505/files/aether-smpfulltext.pdf。</a> </p><p>以下内容参考了官方文章 <a href="https://www.mongodb.com/blog/post/breaking-wired-tiger-logjam-write-ahead-log">https://www.mongodb.com/blog/post/breaking-wired-tiger-logjam-write-ahead-log</a></p><h2 id="日志组提交模式"><a href="#日志组提交模式" class="headerlink" title="日志组提交模式"></a>日志组提交模式</h2><p>用户在写日志时，对于日志缓冲区的竞争是无锁的，只使用原子标志来进行同步。日志写入的流程如下：</p><p><img src="/images/mlog.png" alt="mlog"></p><p>在 Slot 的竞争阶段，不同的线程会竞争修改Slot 的原子标志。若修改成功，则线程需要负责分配下一个 Slot；若修改失败，则会根据返回的 entry 位置，将日志拷贝到 Slot 中；如果下一个Slot 分配完成，则本 Slot 禁止写入，返回的 entry &lt; 0，线程需要再次竞争下一个 Slot。</p><p>当线程完成 Slot 的写入，可以根据日志写入等级选择返回时机，而最后一个完成写入的线程则需要负责将 Slot 写入硬盘缓冲区，若该 Slot 中有现成要求写入硬盘，则进行刷盘操作。</p><h2 id="自由调控日志等级"><a href="#自由调控日志等级" class="headerlink" title="自由调控日志等级"></a>自由调控日志等级</h2><p>由于每一个用户线程都深度参与了日志的提交过程，用户线程具有三个时机可以返回：1、写入日志缓冲区。2、写入硬盘缓冲区。3、写入硬盘。这种自由度允许了 MongoDB 的 CRUD 操作具备了更高的调控等级：不写日志、日志写入缓冲区、日志写入硬盘，对于一些高写入压力的场景，如分布式日志，数据采集系统，可以根据具体情况来选择日志等级，加快客户端的提交速度。</p><h2 id="轻量级缓冲区"><a href="#轻量级缓冲区" class="headerlink" title="轻量级缓冲区"></a>轻量级缓冲区</h2><p>相比于 InnoDB 中采用 Log File 缓冲区，WiredTiger 中的缓冲区量级要更小。这是因为 MongoDB 中需要写入日志的线程数量更多，经常会大于 CPU 的核数，如果采用大缓冲区，各个线程之间对锁的竞争力度会很大。采用更小的缓冲区，并且采用 join 机制，虽然各个线程仍然存在竞争，但是竞争失败并不会阻塞线程，只是会调整线程的活动模式。这种设计在面对短时间内的高并发写入，能够保证日志写入的高效性。</p><h2 id="无后台线程负责写入日志"><a href="#无后台线程负责写入日志" class="headerlink" title="无后台线程负责写入日志"></a>无后台线程负责写入日志</h2><p>传统的后台线程写入的日志模式在无日志缓冲区时会陷入阻塞，而唤醒线程则需要花费 20us 左右的时间，而这一延迟按照论文中的方法是可以优化的，也就是 Wiredtiger 中采取的日志模式。当发生 少量写入操作到达———短时间空闲———少量写入操作到达，这种情况；传统的后台日志写入模式可能就会损耗较大的性能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Wiredtiger 中的日志组提交的设计来源于 MongoDB 的特殊需求：大量的事务线程同时提交事务，大量日志不需要较高的写入等级。该日志系统主要思想可以概括为以下几点：</p><ul><li>日志组提交采取锁来同步，但获取锁失败并不会阻塞线程</li><li>并发写入日志缓冲区不需要加锁</li><li>日志缓冲区写入硬盘需要使用版本号约束</li><li>每个线程可以选择日志的同步等级</li><li>不需要后台线程写入日志</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>write系统调用失效？——MacOS权限设置问题</title>
      <link href="/2022/09/16/write%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%A4%B1%E6%95%88%EF%BC%9F%E2%80%94%E2%80%94MacOS%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/16/write%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%A4%B1%E6%95%88%EF%BC%9F%E2%80%94%E2%80%94MacOS%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近，同课题组的师弟在学习 C++ 时遇到了一个奇怪的问题，使用<code>open</code>和<code>write</code>系统调用后，程序的输出是正常的，但是无法正常显示文件的内容。出现问题的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = ::<span class="built_in">open</span>(<span class="string">&quot;111.txt&quot;</span>,O_CREAT | O_WRONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        std::cerr &lt;&lt; errno;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(<span class="number">1</span>&lt;&lt; <span class="number">10</span>,<span class="string">&#x27;1&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> wr = ::<span class="built_in">write</span>(fd,str.<span class="built_in">c_str</span>(),str.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;total write bytes: &quot;</span> &lt;&lt;wr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序输出为</span></span><br><span class="line">total write bytes: <span class="number">1024</span></span><br></pre></td></tr></table></figure><p>但是，在 CLion 中打开目标文件，却不能显示任何内容：</p><p><img src="/images/image-20230126195448049.png" alt="image-20230126195448049"></p><p>最初学弟以为是文件内容没有成功写入，在网上寻找答案未果。经过排查后，发现问题出现在文件的权限上，而非程序写入失败。在终端使用 ls 和 cat 命令可以验证这一猜想：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 <span class="built_in">ls</span> 发现文件大小是 1024，证明写入成功，但权限非常奇怪</span></span><br><span class="line">ls -l 111.txt</span><br><span class="line">--w-r-x---  1 tangrenchu  staff  1024 Jan 26 19:58 111.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 <span class="built_in">cat</span> 命令</span></span><br><span class="line">cat 111.txt</span><br><span class="line">zsh: permission denied: ./111.txt</span><br><span class="line"></span><br><span class="line">sudo cat 111.txt</span><br><span class="line">111111111111111111111111111...</span><br></pre></td></tr></table></figure><p>这段代码的编译和运行环境为 MacOS，可能由于 MacOS 的权限分组比较奇怪，导致代码所在的用户组与登录用户不同，导致登录用户没有权限读取文件内容。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LevelDB 学习备忘</title>
      <link href="/2022/05/30/LevelDB%20%E5%AD%A6%E4%B9%A0%E5%A4%87%E5%BF%98/"/>
      <url>/2022/05/30/LevelDB%20%E5%AD%A6%E4%B9%A0%E5%A4%87%E5%BF%98/</url>
      
        <content type="html"><![CDATA[<h1 id="LevelDB-学习备忘"><a href="#LevelDB-学习备忘" class="headerlink" title="LevelDB 学习备忘"></a>LevelDB 学习备忘</h1><h2 id="LevelDB-设计出发点"><a href="#LevelDB-设计出发点" class="headerlink" title="LevelDB 设计出发点"></a>LevelDB 设计出发点</h2><p>​        LevelDB 是一个<strong>轻量级，写优先，批量读，硬盘存储</strong>的K-V嵌入式数据库，这是其许多设计和优化的出发点。为了保证读性能中查找操作的可用性，一段数据必须要被有序地放入到数据库中，并且最优的算法复杂度是固定的——O(nlogn)，这意味着数据被放入预定位置延迟是具有最小值的，即写操作必定会具有固定的延迟。LevelDB 的设计就是如果合理地利用结构来优化这个延迟，来获得最小的写入延迟，核心技巧就是将数据写入数据库的操作分解，并且尽可能地将操作放入后台线程中运行，以此来获得最小的用户输入延迟，从而获得优异的批量写入性能，并且同时保证一定的读性能。</p><p>​        LevelDB 的典型应用之一是作为临时存储——在本地临时存储用户的工作数据，当工作确认提交后再整体发送给其他数据库。</p><h2 id="LevelDB-的写入延迟优化"><a href="#LevelDB-的写入延迟优化" class="headerlink" title="LevelDB 的写入延迟优化"></a>LevelDB 的写入延迟优化</h2><p>​        不同于其他的单机数据库形式，LevelDB 的设计更多地用于嵌入式数据库，因此必须要保证数据库的系统资源占用较小。LevelDB 的写入延迟优化的核心思想是进行数据写入操作的分解，牺牲一定的总操作时间，来换取每一步操作的低延迟，从而实现较低的用户操作延迟以及较低的系统资源占用。</p><p>​        总体来看，LevelDB 中数据的写入流程可以被分解为：</p><ul><li>WAL 日志：目的为获得低用户写入延迟</li><li>批写入缓冲：目的为获得较少的线程同步次数</li><li>内存缓冲表：目的为优化用户修改近期数据的需要</li><li>SSTFile 以及合并：目的为减少系统占用，优化读性能</li></ul><h3 id="WAL-日志"><a href="#WAL-日志" class="headerlink" title="WAL 日志"></a>WAL 日志</h3><p>​        虽然将数据有序地写入数据库中的延迟最小是 O(nlogn)，但是只是将数据持久化到硬盘中的延迟只有 O(1)。利用 WAL 操作，用户调用 <code>Put()</code>操作时，操作被追加到 WAL 文件中即可对用户操作返回成功。实际设计中，LevelDB 将操作记录到内存缓冲区后，再写入到 WAL 文件中，后台线程会根据内存缓冲区完成后续的数据写入操作。由于 WAL 文件流时追加形式，并且是持续打开的，不需要寻址，因此该速度非常快。</p><h3 id="批写入缓冲"><a href="#批写入缓冲" class="headerlink" title="批写入缓冲"></a>批写入缓冲</h3><p>​        在 LevelDB 中，具有一个缓冲区用于存储用户的写入操作。只有当该缓冲区满时，或者经过一段时间后，后端线程才会将该缓冲区中的数据真正写入到内存中的跳跃表中。这一设计主要的优点如下：</p><ul><li>优化跳跃表写入时间：跳跃表写入操作需要进行查找，查找操作是插入延时的主要原因。利用批写入缓冲，可以将用户的 N 个操作根据键值进行排序，在进行跳跃表写入时，最坏情况下只需要从头遍历一次跳跃表，大大节约了查找的时间。</li><li>符合用户操作习惯：用户在执行插入操作时，可能会在短期内多次更新同一个值，这样可以将多次插入操作合并为一次。</li><li>优化线程同步：跳跃表是需要由多个后台线程共享的（插入线程，持久化线程，读取线程），执行写入操作时是需要进行加锁的。执行批写入时，写入时间更短，获取锁的时间更短，同时唤醒其他线程的时机也更少，对线程同步是有益的。</li></ul><p>​        批量写入也有一定的弊端，主要是数据库宕机时会增加恢复时间，但总体来说对数据库性能的影响很小。</p><h3 id="MMAP-跳跃表"><a href="#MMAP-跳跃表" class="headerlink" title="MMAP (跳跃表)"></a>MMAP (跳跃表)</h3><p>​        mmap 主要是实现了缓冲区的功能，将多次写入硬盘的操作合并为一次写入。由于操作系统的调度机制，频繁进行 IO 的线程优先级是比较低的，线程频繁进行 IO 操作会浪费很多时间在调度上。同时，使用内存缓冲区时，可以将整个表进行数据压缩操作，节约硬盘的存储空间。</p><p>​        跳跃表是一个综合来看比较优异的数据结构。对比跳跃表、哈希表、红黑树三种典型的数据结构，哈希表并不是一种顺序容器，在迭代操作的时候可能会遇到问题（迭代器失效），红黑树的插入操作因为涉及到旋转，时间常数会比较高，插入性能略差。而跳跃表可以提供顺序迭代访问，并且插入数据时比较简单，很容易实现无锁结构，易于并发访问，因此 LevelDB、Redis 等一些内存数据库经常会使用跳跃表进行缓存操作。</p><p>​        MMAP 的惰性删除机制：在引入惰性删除机制前，对跳跃表的操作需要分为四类：读、写、删除、修改。其中，写、删除操作因为涉及链表的重构，是需要写并发控制才能够运行的；而另外两种操作，并不涉及到链表内部节点的修改，只需要将值设置为原子量就可以进行并发访问了。在引入惰性删除机制后，通过修改节点的标志量来标记删除，当 MMAP 持久化时再删除节点，这样就将删除操作变更为了修改操作，能够大大提升对内存表的并发访问量。</p><h3 id="SSTFile"><a href="#SSTFile" class="headerlink" title="SSTFile"></a>SSTFile</h3><p>​        为了保证读性能的可用性，必须将键值对放入预期的位置。如果数据库简单地将所有数据在硬盘中有序排列，那么每次将 MMAP 中的数据插入到硬盘的操作时间复杂度就是 O(nlogn)，但是这样会导致一次插入操作的系统占用过高。LevelDB 设计了一套分层存储机制来代替传统的存储机制。</p><p>​        SSTFile 是数据在硬盘中的组织形式，不同的 SSTFile 分为不同的层级（ 0 - n ），文件内部的键值对是有序排列的，Level 0 之外的文件在层级之间也是有序排列的。每次 MMAP 中的数据需要持久化时，会生成一个 Level 0 的 SSTFile，如果一个 Level 对应的文件数量过多会触发合并操作。这样设计，高层级的数据是有序的旧数据，低层级因为单个文件数据量很小，因此无序存储也不会过多地影响系统的读性能。每次进行读取操作时，从低层次往高层次进行查找，直到找到数据。</p><p>​        很显然，这种设计会造成写扩大：同样的数据被写入硬盘多次才保证了全局一致性；但是这种写扩大是被分摊到多个不同的时间节点的，虽然总的写入时间加大了，但是却能够确保每个时间点的系统占用很小。因为 SSTFile 的合并是被动的，数据库只会惰性地检查每个层级是否满足合并条件，并且确保一次只存在一个合并操作；此外，如果一次合并操作花费过多的时间，那么数据库还会中断本次操作并选择延迟执行，以防止MMAP 不能及时持久化到硬盘中。</p><h3 id="修改和删除数据"><a href="#修改和删除数据" class="headerlink" title="修改和删除数据"></a>修改和删除数据</h3><p>​        由于数据库采用层级的查找机制，当用户需要进行旧数据的修改时（MMAP 中数据并不存在）；LevelDB 其实并不会对文件中的数据进行查找，而是直接将新的数据写入到 MMAP 中，并不需要删除掉旧数据。因此，在 LevelDB 中，修改操作其实已经退化为了写入操作。同样地，删除操作也只会在 MMAP 中查找数据，若未查询到数据，则会在 MMAP 中插入一条删除记录。</p><p>​        这种优化是因为 LevelDB 面向的应用场景中，用户更加倾向于频繁修改最近的数据，而旧数据的修改可能只会零散的发生，因此额外的硬盘占用量是很小的。</p><h2 id="LevelDB-的读取优化"><a href="#LevelDB-的读取优化" class="headerlink" title="LevelDB 的读取优化"></a>LevelDB 的读取优化</h2><p>​        LevelDB 是一个批处理的数据库系统，这种应用场景下，读取操作是具有显著特征的。</p><ul><li>用户可能会多次修改最近的数据，如不小心输入错误的数据。</li><li>对于旧的数据，用户可能会批量读取并进行操作。</li></ul><p>​        由于 LevelDB 本身存在两个缓冲区，因此已经满足了修改最近数据的需求，基本上只有对旧数据的读取需要进行大规模优化。</p><h3 id="文件索引与布隆过滤器"><a href="#文件索引与布隆过滤器" class="headerlink" title="文件索引与布隆过滤器"></a>文件索引与布隆过滤器</h3><p>​        文件索引是一个经典的文件读取优化模式。在 LevelDB 中，每个 SSTFile 都会在内存中保留一个索引，索引包含了数据日期，最大键值、最小键值、最近操作时间、最近读取次数等一系列信息。如果 MMAP 中没有查询到用户需要的数据，那么就会触发对 SSTFile 的查找，在每个高层级中键值是有序的，因此可以在层级中对键值对执行二分查找；对于无序的Level 0 数据，因为文件数量很小，执行顺序查找也不会有较高的性能损失。</p><p>​        通过键值范围确定可能的 SSTFile 文件后，LevelDB 还需要通过布隆过滤器来保证该数据存在的可能性；只有成功通过布隆过滤器，数据库才会将文件读取到内存中。同样，文件的内部也是有序的，同样可以执行二分查找，降低查找的时间复杂度。被读取到内存中的文件会缓存一段时间，以此来应对用户多次读取同一段数据的需要。</p><h3 id="版本控制-MVCC"><a href="#版本控制-MVCC" class="headerlink" title="版本控制 MVCC"></a>版本控制 MVCC</h3><p>​        LevelDB 中写入操作是直接写入到最上层级的，并不会被读操作读到，因此唯一可能出现的冲突是 SSTFile 合并操作与读操作的冲突，使用简单的 MVCC 并发控制就可以避免冲突。</p><p>​        执行读操作时，LevelDB 会将对应文件的引用量加一；当执行迭代器操作时，会将当前全部文件标注引用。当合并操作被触发，原有的文件需要删除时，根据文件的引用量来判断是否真正执行删除操作；若引用不为 0，则进行惰性删除机制，当引用为 0 时再自动触发删除操作。</p><h3 id="迭代器遍历操作"><a href="#迭代器遍历操作" class="headerlink" title="迭代器遍历操作"></a>迭代器遍历操作</h3><p>​        LevelDB 的读场景存在大量的批量读取，使用迭代器进行数据库的遍历有助于用户简化代码。但由于 LevelDB 中修改和删除操作并不会真正地删除掉旧数据，因此在遍历数据库时必须采取一定措施来防止用户读取过期数据。</p><p>​        LevelDB 中只提供全局有序的迭代器操作，并且能够保证数据的有效性。具体做法为：在每个 Level 上都创建一个内部迭代器，当调用迭代器 <code>MoveNext()</code>操作时，使用类似归并的思想进行操作，这样就能够消除过期数据带来的影响。同时，在创建一个迭代器时，会自动创建一个快照，快照只记录需要访问的文件并声明引用，并不会直接复制数据。</p><h3 id="防止读扩大"><a href="#防止读扩大" class="headerlink" title="防止读扩大"></a>防止读扩大</h3><p>​        LevelDB 的层级读取机制并不能很好地处理一种情景：用户短时间内需要频繁读取一段老数据。该情况下，每次都需要从头开始查找，会消耗过多的查询时间，同时还会造成读取的文件过大，这是需要进行优化的。具体的优化措施为：开辟一片最近读内存缓冲区，将最近读取过的数据存入缓冲区中。缓冲区采用一定的置换策略，并且保证在缓冲区内被多次读取的数据会被持久化到 Level 0 中。</p><h2 id="LevelDB-的系统占用优化"><a href="#LevelDB-的系统占用优化" class="headerlink" title="LevelDB 的系统占用优化"></a>LevelDB 的系统占用优化</h2><p>​        当 LevelDB 作为嵌入式数据库使用时，必须要保证较低的内存和 CPU 占用来维持整体软件的性能。类似于写入操作，LevelDB 完成相应功能的总时间也是具有优化上限的，只有采用分割任务的方法，才能保持长时间的低系统占用。</p><h3 id="内存池与-Slice"><a href="#内存池与-Slice" class="headerlink" title="内存池与 Slice"></a>内存池与 Slice</h3><p>​        LevelDB 内部的内存分配是使用内存池进行分配的，内存池具有效率高、能够避免系统级内存碎片的优点。数据库进程如果只是使用系统调用来简单分配内存，不仅会出现内存频繁申请和销毁的情况，长时间运行还会造成系统级内存碎片，导致系统可用内存下降。</p><p>​        使用内存池会引入较为繁琐的内存管理，因此 LevelDB 引入 <code>Slice</code> 数据结构来简化内存分配。 <code>Slice</code> 是字符串指针和字符串长度的集合，LevelDB 中的所有数据段底层都被存储为 <code>Slice</code> 格式，所有内存申请都是建立在内存池的基础上的，并且会尽量保证持有的内存区域尽可能小。</p><h3 id="SSTFile-合并"><a href="#SSTFile-合并" class="headerlink" title="SSTFile 合并"></a>SSTFile 合并</h3><p>​        SSTFile 合并操作会评估当前数据库的系统占用情况，并且会保证一次合并操作并不会持续过长时间。如果一次合并操作耗时过长，该合并操作会被中断，并且选择合适的时机再次执行。                </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 与 MySQL 的一些读写优化</title>
      <link href="/2022/05/12/MongoDB%20%E4%B8%8E%20MySQL/"/>
      <url>/2022/05/12/MongoDB%20%E4%B8%8E%20MySQL/</url>
      
        <content type="html"><![CDATA[<p>本篇文章简述了 MongoDB 与 MySQL 设计中的一些读写优化，更加偏向随笔记录。</p><p>由于 MongoDB 与 MySQL 的设计年代不同，因此设计思路也有所不同。从整体上看，MongoDB 的优化更加偏向于写入性能，而 MySQL 的优化更加偏向于读取性能。</p><h2 id="读取链路的优化"><a href="#读取链路的优化" class="headerlink" title="读取链路的优化"></a>读取链路的优化</h2><p>​    由于 MongoDB 大量数据和索引是常驻内存的，所以读取性能是会比 MySQL 高很多的，通常来说 MongoDB 的写入性能更容易达到瓶颈。MongoDB 的设计中牺牲了一定的读取性能来换取更高的写入性能。而 MySQL 大量数据是常驻在硬盘中的，读性能的可优化之处更多也更加具有性价比，因此做了较多的优化来换取更高的读取性能。</p><h3 id="MySQL-读取链路优化"><a href="#MySQL-读取链路优化" class="headerlink" title="MySQL 读取链路优化"></a>MySQL 读取链路优化</h3><p>​    MySQL 在读取链路的优化主要有查询缓存、页缓存、自适应哈希索引、CheckPoint、覆盖索引、MRR 优化、ICP 优化</p><h4 id="MRR-优化"><a href="#MRR-优化" class="headerlink" title="MRR 优化"></a>MRR 优化</h4><p>​    需要查询时，先根据辅助索引将 WHERE 语句中所有符合条件的主键值放入缓冲区，在缓冲区进行排序后查询。这样可以将随机 IO 转化为顺序 IO。</p><h4 id="ICP-优化"><a href="#ICP-优化" class="headerlink" title="ICP 优化"></a>ICP 优化</h4><p>​    当索引取出时，会根据 WHERE 语句条件进行判断，这一优化是适用于联合索引，或者 WHERE 语句中包含主键值的情况。</p><h2 id="写入链路的优化"><a href="#写入链路的优化" class="headerlink" title="写入链路的优化"></a>写入链路的优化</h2><h3 id="MongoDB-写入链路优化"><a href="#MongoDB-写入链路优化" class="headerlink" title="MongoDB 写入链路优化"></a>MongoDB 写入链路优化</h3><p>​    MongoDB 的写入链路主要做了以下几点优化：Check Point、Copy On Write、无锁 B+ 树、Insert List、事务组提交。</p><h4 id="Check-Point"><a href="#Check-Point" class="headerlink" title="Check Point"></a>Check Point</h4><p>​    Check Point 技术允许 MongoDB 按照每一秒的频率对整个 B+ 树进行刷盘操作，这使得大量的写入操作在写入日志后不需要立刻进行刷盘，只需要写入到内存当中。结合Copy On Write可以使得 B+ 树在正常刷脏的过程中也不会阻塞写入。</p><h4 id="Copy-On-Write"><a href="#Copy-On-Write" class="headerlink" title="Copy On Write"></a>Copy On Write</h4><p>​    Copy On Write 技术是在上一 Check Point 的基础上在内存中新开辟内存区域进行写入，这样做的好处主要有两点：第一是很好地区分了脏页，在刷脏的过程中减小了遍历的范围，提高了刷脏的效率，第二是能够减少刷脏过程中的阻塞时间，如果一页在刷脏过程中被写入，那么将会立刻开辟出一个新的缓冲区，写入操作将会写入到该缓冲区的跳跃表中，并不会造成写入的阻塞（但并不意味着不会增加写入的时间，事实上，在刷脏时写入将会等待缓冲区的分配，这会稍微延长写入时间）。</p><h4 id="Insert-List"><a href="#Insert-List" class="headerlink" title="Insert List"></a>Insert List</h4><p>​    MongoDB 中所有的写入操作并不是在原有的位置上更新。每一个页表中都有多个跳跃表，插入操作会将值插入到统一的缓冲区内，并且在跳跃表中增加指向该值的指针，并且跳跃表是可以做到无锁并发的，可以大大提高写入的性能。但是这同时会造成读取链路变长，在读取时需要首先查找原有的值数组，然后再对跳跃表进行遍历。</p><h4 id="无锁-B-树"><a href="#无锁-B-树" class="headerlink" title="无锁 B+ 树"></a>无锁 B+ 树</h4><p>​    这里主要是针对 B+ 树节点的分裂优化，由于 B+ 树节点的分裂会造成写入的阻塞，在 MongoDB 中只有单个节点短时间内插入过多数据时，才会允许 B+树节点的分裂，其余情况下，只有在 Check Point 或者冷淘汰过程中才会进行节点的分裂。所以 MongoDB 中内存中页面的大小可能与硬盘中的页面大小不相同，在刷入硬盘中时，会将内存中的页面分为几个较小的页面写入到硬盘中。</p><p>​    单个节点插入过多数据时，会将最后一个插入跳跃表放入到新的节点中，这一过程是可以做到不阻塞的（先将剩下的插入操作引导至新的页面中，随后再将旧节点拷贝到新的页面上）。但是这种设计会对热点数据的读取性能造成一定的影响，最新插入的数据需要更多的查询次数，降低了读取性能。</p><h4 id="事务组提交"><a href="#事务组提交" class="headerlink" title="事务组提交"></a>事务组提交</h4><p>​    事务组提交是数据库系统中比较常见的优化，但 MongoDB 与MySQL的组提交有所不同。MongoDB 中组提交的缓冲区很小，并且每次组提交后都会进行刷盘，而 MySQL 中时以文件的形式来进行刷盘的。MongoDB 中，一次组提交中线程会将 log 拷贝到缓冲区中，拷贝完成按照 log 的序列号进行提交，不会造成不同组的乱序提交。</p><h3 id="MySQL-的写入链路优化"><a href="#MySQL-的写入链路优化" class="headerlink" title="MySQL 的写入链路优化"></a>MySQL 的写入链路优化</h3><p>MySQL 写入的优化主要集中在如何将随机 IO 转化为顺序 IO 上，这是因为在设计时 MySQL 的 B+树索引主要是存储在硬盘上的。</p><h4 id="插入缓冲区"><a href="#插入缓冲区" class="headerlink" title="插入缓冲区"></a>插入缓冲区</h4><p>辅助索引的写入是统一写入到缓冲区后，再进行刷盘操作。这一优化是因为辅助索引通常并不是聚集的，直接写入会造成随机 IO，通常引入这样一个缓冲区，可以结合异步 IO 机制将随机 IO 转换为顺序 IO，提高刷盘时的性能。</p><h4 id="Check-Point-技术"><a href="#Check-Point-技术" class="headerlink" title="Check Point 技术"></a>Check Point 技术</h4><p>MySQL 中同样是采取了该技术，当数据需要写入时会将对应的页读取到内存中，然后在内存中进行修改，随后该页并不会被立刻刷入到硬盘中，而是会由 master 线程进行刷盘。MySQL 中的该设计其实主要是考虑到热数据的问题，刚刚写入的数据被再次修改和读取的概率是比较大的，这一举措不仅优化了写入性能，还能够优化读取性能。</p><h4 id="事务组提交-1"><a href="#事务组提交-1" class="headerlink" title="事务组提交"></a>事务组提交</h4><p>bin log 的组提交机制类似于 MongoDB。redo log 则是采用多个文件缓冲和双指针的机制，一个指针指向当前写入的文件缓冲区，另外一个指针指向需要刷盘的缓冲区，实现无锁写入。MySQL 的bin log组提交被 wiredtiger 中的 journal 组提交所借鉴，这确实是一个比较巧妙的设计，但是 MongoDB 中将应用层的日志也当做数据库中的记录，这一设计了避免了bin log 需要和 redo log 分开进行提交的缺陷。</p><h4 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h4><p>异步 IO 是 MySQL 其他许多优化的基础，异步 IO 允许操作系统将多个 IO 操作合并并且重新排列顺序，使之更加符合硬盘的写入顺序。 </p><h4 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h4><p>这一操作在固态硬盘时代好像是一个负优化，一般会关闭。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>​    MongoDB 的写入链路是比读取链路要短的，这一点与 MySQL 正好相反。对于单独的事务来看，由于应用层日志是不需要单独提交的，所以 MongoDB 的 WAL 写入理论上是要比 MySQL 快的，（事务在写入 WAL 后就可以返回）。</p><p>​    在大量事务写入的情况下，很容易会造成热点页刷脏的问题。由于 MongoDB 允许内存与硬盘中 B+树大小不相同，并且针对内存中的 B+ 树做了写入优化，大量写入的情况下会优先写入到内存缓冲区中，并且优先在内存中进行分裂。在处理这种瞬时写入压力时，MongoDB 的设计会更加好，这主要是 MongoDB 的设计考虑到了大量的内存缓冲，并且牺牲了一部分读取性能换来的。</p><p>​    最主要的是，MySQL 作为关系型数据库，其事务隔离等级要求较高，这同样会造成较大的性能损耗，例如外键约束、间隙锁等。</p><p>​    但是，MongoDB 在指定主键插入时，由于插入的位置可能并不是页面内最后一个跳跃表，这样就可能会导致创建出多个新页面才能够将插入位置放入到新页面中，或者来不及进行内存节点分裂，导致页面被锁住禁止写入，这样会造成较大的性能毛刺。因为要插入一个非常大的跳跃表，并且还要完成多个页面的持久化。此外，指定主键时，如果数据库体量较大，导致大部分数据不能够常驻内存，MongoDB 可能还需要从硬盘中读取数据来确保主键是唯一的，这样就导致数据量较大时指定主键的插入性能非常低。</p><p>​    所以，MongoDB 并不适合存储那些由用户指定，并且需要保证唯一性的数据，例如用户名称等，而订单编号这种情况可以直接使用 uuid 进行插入。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MongoDB </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保持后台线程不随主线程退出</title>
      <link href="/2022/04/17/2022-04-17-%E4%BF%9D%E6%8C%81%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%E4%B8%8D%E9%9A%8F%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA/"/>
      <url>/2022/04/17/2022-04-17-%E4%BF%9D%E6%8C%81%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%E4%B8%8D%E9%9A%8F%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>在 linux 系统中，线程是最小的调度单元，主线程与进程内的其余线程享受公平调度，同时也允许主线程退出后进程内其余线程继续运行。但是在编程中，当 main 函数 return 之后，所有的线程均会退出。这是因为 main 函数中的 return 和 exit 系统调用是等效的。如果 main 函数正常结束，那么进程内的所有内存、线程描述符等都会被回收，因此其余线程无法继续运行。</p><p>但有时候，我们并不希望后台线程直接退出，而是想让其完成一些善后工作。例如在进行图形化编程时，后台有线程正在执行某些操作（如重写文件、使用缓冲区向系统写入数据），我们希望这个操作不存在中间态，而直接阻塞主线程退出会导致图形界面退出时卡住。这种场景下，我们可以使用系统调用<code>pthread_exit</code>函数使主线程退出时并不会调用 exit，从而避免进程退出。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 MongoDB 复制集踩坑</title>
      <link href="/2022/04/12/%E8%AE%B0%E5%BD%95-MongoDB-%E5%A4%8D%E5%88%B6%E9%9B%86%E8%B8%A9%E5%9D%91/"/>
      <url>/2022/04/12/%E8%AE%B0%E5%BD%95-MongoDB-%E5%A4%8D%E5%88%B6%E9%9B%86%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>本文记录在部署 MongoDB 复制集时遇到的一些小坑和解决方法。</p><h2 id="docker-环境下-ip-设置错误导致无法访问"><a href="#docker-环境下-ip-设置错误导致无法访问" class="headerlink" title="docker 环境下 ip 设置错误导致无法访问"></a>docker 环境下 ip 设置错误导致无法访问</h2><p>在第一次部署 MongoDB 时，为了方便而选择了使用 docker 容器进行部署。部署过程中完全依照<a href="https://www.mongodb.com/docs/manual/tutorial/deploy-replica-set/">官方的教程</a>，但是最终部署的集群却无法在 docker 网络外以副本集模式访问。在调试过程中发现在 docker 网络内部可以进行访问，因此猜测可能是 DNS 或者监听的问题。</p><p>最终定位到问题在于初始化时选择的 host 错误。官方教程在初始化时，使用的命令如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 container name 初始化</span></span><br><span class="line"><span class="comment">// 只能够在 docker 网络内部访问</span></span><br><span class="line">rs.<span class="title function_">initiate</span>( &#123;</span><br><span class="line">   _id : <span class="string">&quot;rs0&quot;</span>,</span><br><span class="line">   <span class="attr">members</span>: [</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">0</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb0.example.net:27017&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">1</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb1.example.net:27017&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">2</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb2.example.net:27017&quot;</span> &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>官方的教程在部署过程中直接使用了 container name 作为 MongoDB 实例的 HostName，由于所有的副本集是部署在同一个 docker 网络中，所以可以通过 docker DNS 功能来实现服务发现。而在 docker 网络外部，无法使用 docker DNS 服务，因此不能够正确地访问集群。</p><p>经过修改后，将集群初始化命令修改为以下形式，可以正常访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容器使用 publish 端口</span></span><br><span class="line"><span class="comment">// 集群使用宿主机 ip 初始化</span></span><br><span class="line"><span class="comment">// 使其可以接受容器外部访问</span></span><br><span class="line">rs.<span class="title function_">initiate</span>( &#123;</span><br><span class="line">   _id : <span class="string">&quot;rs0&quot;</span>,</span><br><span class="line">   <span class="attr">members</span>: [</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">0</span>, <span class="attr">host</span>: <span class="string">&quot;宿主机ip:port&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">1</span>, <span class="attr">host</span>: <span class="string">&quot;宿主机ip:port&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">2</span>, <span class="attr">host</span>: <span class="string">&quot;宿主机ip:port&quot;</span> &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="宿主机-ip-变更，集群失效"><a href="#宿主机-ip-变更，集群失效" class="headerlink" title="宿主机 ip 变更，集群失效"></a>宿主机 ip 变更，集群失效</h2><p>上述部署方式，虽然解决了容器外部访问的问题，但是在一次网关配置的修改后，集群所在的宿主机 ip 发生了变化，导致之前部署的 ip 无法访问，需要修改集群的配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分容器 ip 改变，集群中仍有 master</span></span><br><span class="line">rs.<span class="title function_">reconfig</span>( &#123;</span><br><span class="line">   _id : <span class="string">&quot;rs0&quot;</span>,</span><br><span class="line">   <span class="attr">members</span>: [</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">0</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb0.example.net:27017&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">1</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb1.example.net:27017&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">2</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb2.example.net:27017&quot;</span> &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部容器 ip 改变</span></span><br><span class="line"><span class="comment">// 部分容器 ip 改变，集群中仍有 master</span></span><br><span class="line">rs.<span class="title function_">reconfig</span>( &#123;</span><br><span class="line">   _id : <span class="string">&quot;rs0&quot;</span>,</span><br><span class="line">   <span class="attr">members</span>: [</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">0</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb0.example.net:27017&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">1</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb1.example.net:27017&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">2</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb2.example.net:27017&quot;</span> &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;，&#123;<span class="attr">force</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>最好的部署方式还是在网关处部署一个 DNS 服务，用于集群的域名管理。</p><h2 id="网络吞吐量过大，查询不稳定"><a href="#网络吞吐量过大，查询不稳定" class="headerlink" title="网络吞吐量过大，查询不稳定"></a>网络吞吐量过大，查询不稳定</h2><p>由于在部署中利用了 MongoDB Gridfs 功能作为基础架构作为深度学习的标记、训练、测试的数据集来源，在我们的使用场景中，经常会需要从 MongoDB 集群中批量访问 500 张以上 15M 左右的图像。在最初的本地测试中，我测试了批量从 MongoDB 中读取 1000 张图像，所以运行速度一直非常稳定，保持在一张图像 150ms 左右的速度，这对我们来说是比较满意的性能。</p><p>但是将 MongoDB 集群投入到使用中，我们发现对图像的获取速度非常不稳定，有时获取一张图像只需要 200ms 左右，有时获取一张图像却需要 3~4 s。大部分情况下获取一张图像需要 1s 左右，而且 MongoDB 性能的波动非常严重，不符合我们最初的测试效果。</p><p>最初猜测是由于 MongoDB 中数据存储不合理，导致数据集查询较慢。但查询 MongoDB 的慢查询日志后，发现所有的查询操作均不是慢查询操作。通过 top 命令查询 MongoDB 部署的主机进行监控，发现在查询过程中，CPU 的占用率一直在 20%左右。正在一筹莫展时，突然发现主机的网卡占用率非常高，猜测是网络的问题。</p><p>利用 wireshark 抓包后，发现在查询过程中有大量 TCP 重传，可能是由于网络阻塞比较严重。经过排查后，发现是实验室的网关性能过差。</p><p>最终，更换了实验室网关，并且将需要批量查询图像的主机通过网线直接与 MongoDB 部署主机相连，最终批量查询的时间稳定在 200ms 左右。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从sqlite3看SQL编译</title>
      <link href="/2022/01/03/%E4%BB%8Esqlite3%E7%9C%8BSQL%E7%BC%96%E8%AF%91/"/>
      <url>/2022/01/03/%E4%BB%8Esqlite3%E7%9C%8BSQL%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>在学习 sql 语句的“编译”、“预编译”相关知识时，我发现互联网上的相关资料是比较匮乏的。本文在 sqlite3 的背景下，简要地介绍 sql 语句的编译与预编译在一个数据库引擎中究竟是如何发生的。</p><h2 id="什么是编译和预编译"><a href="#什么是编译和预编译" class="headerlink" title="什么是编译和预编译"></a>什么是编译和预编译</h2><p>SQL 是结构化查询语言（Structed Query Language）的简称，它是一种用于处理各种数据库技术的非过程化<strong>语言</strong>。但是较为特殊的是，SQL 语句只定义了必要的输入和输出参数，但是没有定义任何过程，因此并不能够单独执行，而是需要依赖具体的数据库引擎来处理。由于 SQL 语言是比较复杂的，大多数数据库引擎会将 SQL 语句转换为执行过程依赖于当前数据库的状态的可执行文件或机器码；这个过程就叫做 SQL 的编译。</p><p>有时候多个 SQL 语句的结构可能类似，只是某些过滤条件不同，例如<code>SELECT col FROM table WHERE col &gt; 1</code>和<code>SELECT col FROM table WHERE col &gt; 2</code>语句，此时可以先将 col_val 使用占位符 ? 替代传入数据库，得到语句<code>SELECT col FROM table WHERE col &gt; ?</code>进行编译，然后再将 col_val 作为输入参数执行编译文件；这个过程叫做 SQL 的预编译。</p><p>可以将编译和预编译过程理解为生成了依赖于数据库引擎运行的函数，其中编译的结果是一个无输入参数的函数，而预编译结果是一个含有输入参数的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQL compile result</span></span><br><span class="line"><span class="type">void</span> ** <span class="title function_">sql_exec</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    operation1_rely_on_database_API();</span><br><span class="line">    operation2_rely_on_database_API();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 查询结果;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SQL precompile result</span></span><br><span class="line"><span class="type">void</span> ** <span class="title function_">sql_exec</span><span class="params">(<span class="type">void</span> *placeholders...)</span>&#123;</span><br><span class="line"></span><br><span class="line">    operation1_rely_on_database_API(placeholders...);</span><br><span class="line">    operation2_rely_on_database_API(placeholders...);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 查询结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SQL 语句经过预编译后会在数据库引擎中缓存，为了表示区分，将已经完成预编译的 SQL 语句称为 statement。通常一个 statement 只对应一条 SQL 语句，并且不同的 statement 之间并不会共享编译结果：如果两个用户使用不同 statement 完成同一条查询语句，这个语句可能会被编译两次。</p><h2 id="sqlite3-编译过程"><a href="#sqlite3-编译过程" class="headerlink" title="sqlite3 编译过程"></a>sqlite3 编译过程</h2><p>根据 sqlite3 的官方文档说明：</p><blockquote><p><code>sqlite3_exec()</code> → A wrapper function that does <code>sqlite3_prepare()</code>, <code>sqlite3_step()</code>, <code>sqlite3_column()</code>, and <code>sqlite3_finalize()</code> for a string of one or more SQL statements.</p></blockquote><p>sqlite3 中不存在单独的 SQL 编译接口，它是依赖于预编译的；sqlite3 中的预编译流程如下：</p><p><img src="/images/sql_compile.png" alt="sql_compile"></p><p>sqlite3 的预编译接口为<code>sqlite3_prepare()</code>，它会根据输入的 SQL 语句返回一个<code>sqlite3_stmt*</code>指针，该指针实际上会指向一个<code>Vdbe</code>对象，该对象实质上是一段可执行代码。sqlite3 中所有的<code>sqlite3_prepare_XX()</code>函数都是接口函数，会对 SQL 进行一些预处理、加锁后调用函数<code>sqlite3Prepare</code>，将代码简化后，函数的主要逻辑为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sqlite3Prepare</span><span class="params">(</span></span><br><span class="line"><span class="params">    sqlite3 *db,              <span class="comment">/* Database handle. */</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *zSql,         <span class="comment">/* UTF-8 encoded SQL statement. */</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> nBytes,               <span class="comment">/* Length of zSql in bytes. */</span></span></span><br><span class="line"><span class="params">    u32 prepFlags,            <span class="comment">/* Zero or more SQLITE_PREPARE_* flags */</span></span></span><br><span class="line"><span class="params">    Vdbe *pReprepare,         <span class="comment">/* VM being reprepared */</span></span></span><br><span class="line"><span class="params">    sqlite3_stmt **ppStmt,    <span class="comment">/* OUT: A pointer to the prepared statement */</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> **pzTail       <span class="comment">/* OUT: End of parsed string */</span></span></span><br><span class="line"><span class="params">)</span>&#123;</span><br><span class="line">    <span class="type">int</span> rc = SQLITE_OK;       <span class="comment">/* Result code */</span></span><br><span class="line">    <span class="type">int</span> i;                    <span class="comment">/* Loop counter */</span></span><br><span class="line">    Parse sParse;             <span class="comment">/* Parsing context */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存等预处理工作，db 加锁是在上一层函数中进行的</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试对 schema 加锁，如果不成功则释放并返回</span></span><br><span class="line">    <span class="keyword">if</span>( !db-&gt;noSharedCache )&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;db-&gt;nDb; i++) &#123;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果加锁失败，退出</span></span><br><span class="line">            <span class="keyword">if</span>( failed )</span><br><span class="line">                <span class="keyword">goto</span> end_prepare;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有指定长度，获取 SQL 长度后进行解析阶段</span></span><br><span class="line">    <span class="keyword">if</span>( nBytes&gt;=<span class="number">0</span> &amp;&amp; (nBytes==<span class="number">0</span> || zSql[nBytes<span class="number">-1</span>]!=<span class="number">0</span>) )&#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>( failed )</span><br><span class="line">            <span class="keyword">goto</span> end_prepare;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            sqlite3RunParser(&amp;sParse, zSql);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sqlite3RunParser(&amp;sParse, zSql);</span><br><span class="line">    &#125;</span><br><span class="line">    assert( <span class="number">0</span>==sParse.nQueryLoop );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查错误以及善后工作</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( sParse.rc!=SQLITE_OK &amp;&amp; sParse.rc!=SQLITE_DONE )&#123;</span><br><span class="line">        <span class="comment">// 如果解析失败，进行清理工作</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 解析成功，将结果绑定到 stmt </span></span><br><span class="line">        *ppStmt = (sqlite3_stmt*)sParse.pVdbe;</span><br><span class="line">        rc = SQLITE_OK;</span><br><span class="line">        sqlite3ErrorClear(db);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理分配的内存空间</span></span><br><span class="line">    <span class="keyword">while</span>( sParse.pTriggerPrg )&#123;</span><br><span class="line">        TriggerPrg *pT = sParse.pTriggerPrg;</span><br><span class="line">        sParse.pTriggerPrg = pT-&gt;pNext;</span><br><span class="line">        sqlite3DbFree(db, pT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">end_prepare:</span><br><span class="line">    <span class="comment">// 清理分配的内存空间</span></span><br><span class="line">    sqlite3ParseObjectReset(&amp;sParse);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该函数首先检查是否能够对全部 schema 加锁，以判断当前是否有未完成的写操作；第二步则是调用<code>sqlite3RunParser</code>函数来获取 SQL 语句的解析结果，最后再将解析结果中的<code>Vdbe</code>绑定到用户输入的<code>sqlite3_stmt</code>指针上。由于<code>sqlite3.h</code>头文件中不包含<code>sqlite3_stmt</code>的定义，自然而然地隐藏了内部实现，这是一种零成本抽象。</p><p>在<code>sqlite3RunParser()</code>函数中，主要是以状态机的形式对 SQL 语句进行语义分析，即<code>while(1)</code>中的处理逻辑，代码部分进行了删改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Run the parser on the given SQL string.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3RunParser</span><span class="params">(Parse *pParse, <span class="type">const</span> <span class="type">char</span> *zSql)</span>&#123;</span><br><span class="line">  <span class="type">int</span> nErr = <span class="number">0</span>;                   <span class="comment">/* Number of errors encountered */</span></span><br><span class="line">  <span class="type">void</span> *pEngine;                  <span class="comment">/* The LEMON-generated LALR(1) parser */</span></span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;                      <span class="comment">/* Length of the next token token */</span></span><br><span class="line">  <span class="type">int</span> tokenType;                  <span class="comment">/* type of the next token */</span></span><br><span class="line">  <span class="type">int</span> lastTokenParsed = <span class="number">-1</span>;       <span class="comment">/* type of the previous token */</span></span><br><span class="line">  sqlite3 *db = pParse-&gt;db;       <span class="comment">/* The database connection */</span></span><br><span class="line">  <span class="type">int</span> mxSqlLen;                   <span class="comment">/* Max length of an SQL string */</span></span><br><span class="line">  Parse *pParentParse = <span class="number">0</span>;        <span class="comment">/* Outer parse context, if any */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> sqlite3Parser_ENGINEALWAYSONSTACK</span></span><br><span class="line">  yyParser sEngine;    <span class="comment">/* Space to hold the Lemon-generated Parser object */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  VVA_ONLY( u8 startedWithOom = db-&gt;mallocFailed );</span><br><span class="line"></span><br><span class="line">  assert( zSql!=<span class="number">0</span> );</span><br><span class="line">  mxSqlLen = db-&gt;aLimit[SQLITE_LIMIT_SQL_LENGTH];</span><br><span class="line">  <span class="keyword">if</span>( db-&gt;nVdbeActive==<span class="number">0</span> )&#123;</span><br><span class="line">    AtomicStore(&amp;db-&gt;u1.isInterrupted, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pParse-&gt;rc = SQLITE_OK;</span><br><span class="line">  pParse-&gt;zTail = zSql;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配内存</span></span><br><span class="line">  pEngine = sqlite3ParserAlloc(sqlite3Malloc, pParse);</span><br><span class="line">  <span class="keyword">if</span>( pEngine==<span class="number">0</span> )&#123;</span><br><span class="line">    sqlite3OomFault(db);</span><br><span class="line">    <span class="keyword">return</span> SQLITE_NOMEM_BKPT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert( pParse-&gt;pNewTable==<span class="number">0</span> );</span><br><span class="line">  assert( pParse-&gt;pNewTrigger==<span class="number">0</span> );</span><br><span class="line">  assert( pParse-&gt;nVar==<span class="number">0</span> );</span><br><span class="line">  assert( pParse-&gt;pVList==<span class="number">0</span> );</span><br><span class="line">  pParentParse = db-&gt;pParse;</span><br><span class="line">  db-&gt;pParse = pParse;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 主要的解析逻辑，利用状态机来进行语义分析</span></span><br><span class="line">  <span class="keyword">while</span>( <span class="number">1</span> )&#123;</span><br><span class="line">    n = sqlite3GetToken((u8*)zSql, &amp;tokenType);</span><br><span class="line">    mxSqlLen -= n;</span><br><span class="line">    <span class="keyword">if</span>( mxSqlLen&lt;<span class="number">0</span> )&#123;</span><br><span class="line">      pParse-&gt;rc = SQLITE_TOOBIG;</span><br><span class="line">      pParse-&gt;nErr++;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLITE_OMIT_WINDOWFUNC</span></span><br><span class="line">    <span class="keyword">if</span>( tokenType&gt;=TK_WINDOW )&#123;</span><br><span class="line">      assert( tokenType==TK_SPACE || tokenType==TK_OVER || tokenType==TK_FILTER</span><br><span class="line">           || tokenType==TK_ILLEGAL || tokenType==TK_WINDOW </span><br><span class="line">      );</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span>( tokenType&gt;=TK_SPACE )&#123;</span><br><span class="line">      assert( tokenType==TK_SPACE || tokenType==TK_ILLEGAL );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SQLITE_OMIT_WINDOWFUNC */</span></span></span><br><span class="line">      <span class="keyword">if</span>( AtomicLoad(&amp;db-&gt;u1.isInterrupted) )&#123;</span><br><span class="line">        pParse-&gt;rc = SQLITE_INTERRUPT;</span><br><span class="line">        pParse-&gt;nErr++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>( tokenType==TK_SPACE )&#123;</span><br><span class="line">        zSql += n;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>( zSql[<span class="number">0</span>]==<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">/* Upon reaching the end of input, call the parser two more times</span></span><br><span class="line"><span class="comment">        ** with tokens TK_SEMI and 0, in that order. */</span></span><br><span class="line">        <span class="keyword">if</span>( lastTokenParsed==TK_SEMI )&#123;</span><br><span class="line">          tokenType = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( lastTokenParsed==<span class="number">0</span> )&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          tokenType = TK_SEMI;</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLITE_OMIT_WINDOWFUNC</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>( tokenType==TK_WINDOW )&#123;</span><br><span class="line">        assert( n==<span class="number">6</span> );</span><br><span class="line">        tokenType = analyzeWindowKeyword((<span class="type">const</span> u8*)&amp;zSql[<span class="number">6</span>]);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>( tokenType==TK_OVER )&#123;</span><br><span class="line">        assert( n==<span class="number">4</span> );</span><br><span class="line">        tokenType = analyzeOverKeyword((<span class="type">const</span> u8*)&amp;zSql[<span class="number">4</span>], lastTokenParsed);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>( tokenType==TK_FILTER )&#123;</span><br><span class="line">        assert( n==<span class="number">6</span> );</span><br><span class="line">        tokenType = analyzeFilterKeyword((<span class="type">const</span> u8*)&amp;zSql[<span class="number">6</span>], lastTokenParsed);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SQLITE_OMIT_WINDOWFUNC */</span></span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Token x;</span><br><span class="line">        x.z = zSql;</span><br><span class="line">        x.n = n;</span><br><span class="line">        sqlite3ErrorMsg(pParse, <span class="string">&quot;unrecognized token: \&quot;%T\&quot;&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pParse-&gt;sLastToken.z = zSql;</span><br><span class="line">    pParse-&gt;sLastToken.n = n;</span><br><span class="line">    <span class="comment">// 调用 Lemon 组件生成编译结果</span></span><br><span class="line">    sqlite3Parser(pEngine, tokenType, pParse-&gt;sLastToken);</span><br><span class="line">    lastTokenParsed = tokenType;</span><br><span class="line">    zSql += n;</span><br><span class="line">    assert( db-&gt;mallocFailed==<span class="number">0</span> || pParse-&gt;rc!=SQLITE_OK || startedWithOom );</span><br><span class="line">    <span class="keyword">if</span>( pParse-&gt;rc!=SQLITE_OK ) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  assert( nErr==<span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理中间量</span></span><br><span class="line">  sqlite3ParserFree(pEngine, sqlite3_free);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理分配的内存</span></span><br><span class="line">  <span class="keyword">if</span>( db-&gt;mallocFailed )&#123;</span><br><span class="line">    pParse-&gt;rc = SQLITE_NOMEM_BKPT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>( pParse-&gt;zErrMsg || (pParse-&gt;rc!=SQLITE_OK &amp;&amp; pParse-&gt;rc!=SQLITE_DONE) )&#123;</span><br><span class="line">    <span class="keyword">if</span>( pParse-&gt;zErrMsg==<span class="number">0</span> )&#123;</span><br><span class="line">      pParse-&gt;zErrMsg = sqlite3MPrintf(db, <span class="string">&quot;%s&quot;</span>, sqlite3ErrStr(pParse-&gt;rc));</span><br><span class="line">    &#125;</span><br><span class="line">    sqlite3_log(pParse-&gt;rc, <span class="string">&quot;%s in \&quot;%s\&quot;&quot;</span>, pParse-&gt;zErrMsg, pParse-&gt;zTail);</span><br><span class="line">    nErr++;</span><br><span class="line">  &#125;</span><br><span class="line">  pParse-&gt;zTail = zSql;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( pParse-&gt;pNewTable &amp;&amp; !IN_SPECIAL_PARSE )&#123;</span><br><span class="line">    <span class="comment">/* If the pParse-&gt;declareVtab flag is set, do not delete any table </span></span><br><span class="line"><span class="comment">    ** structure built up in pParse-&gt;pNewTable. The calling code (see vtab.c)</span></span><br><span class="line"><span class="comment">    ** will take responsibility for freeing the Table structure.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sqlite3DeleteTable(db, pParse-&gt;pNewTable);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>( pParse-&gt;pNewTrigger &amp;&amp; !IN_RENAME_OBJECT )&#123;</span><br><span class="line">    sqlite3DeleteTrigger(db, pParse-&gt;pNewTrigger);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>( pParse-&gt;pVList ) sqlite3DbNNFreeNN(db, pParse-&gt;pVList);</span><br><span class="line">  db-&gt;pParse = pParentParse;</span><br><span class="line">  assert( nErr==<span class="number">0</span> || pParse-&gt;rc!=SQLITE_OK );</span><br><span class="line">  <span class="keyword">return</span> nErr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看到，sqlite3 中的语义分析与 SQL 编译实际上是混合在一起的，而不是完成语义分析后再生成可执行代码。在<code>sqlite3Parser</code>函数中，Lemon 解析器会使用 sqlite 中的 code generator 来生成具体的执行计划。Code generator 并不是一个具体的数据结构，而是一系列函数接口，分别对应着不同的功能；这有点类似于深度学习网络中的每一个层级。这些代码生成器分布在不同的文件中，如select.c、where.c 等。Lemon Parser 最终会将这些函数接口组装起来，并进行优化，最终生成一个<code>Vdbe</code>对象。</p><p><code>Vdbe</code>对象是一条 SQL 语句经过 sqlite3 编译后的产物。它是一个虚拟机，其中的程序运行在一个虚拟环境之中，类似于 redis 中的 lua 环境。<code>Vdbe</code>中的程序会直接与数据库中的 B+ 树进行交互，执行事务操作。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> sqlite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 C++ protobuf 动态消息一次踩坑</title>
      <link href="/2021/12/07/%E8%AE%B0%E5%BD%95-C++-protobuf-%E5%8A%A8%E6%80%81%E6%B6%88%E6%81%AF%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91/"/>
      <url>/2021/12/07/%E8%AE%B0%E5%BD%95-C++-protobuf-%E5%8A%A8%E6%80%81%E6%B6%88%E6%81%AF%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>尽量 C++ 并不直接支持反射的功能，但是 protobuf 自行实现了一套反射的功能，用于动态生成消息。protobuf 提供了两种方式用于生成动态消息，一种是调用一个 message 实例的 <code>New()</code>接口，另外一种则是通过导入 proto 文件，利用工厂类实现生成。这两种方式生成的消息类型都是 <code>google::protobuf::Message*</code>，即 protobuf 消息的基类。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>由于通过反射的方式对 <code>google::protobuf::DynamicMessageFactory</code>生成的消息进行赋值较为麻烦，因此想通过 <code>google::protobuf::down_cast&lt;T&gt;()</code>方法对生成的消息进行向下转换。使用一下代码段进行测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input input;</span><br><span class="line"><span class="comment">// 使用 New 接口生成消息</span></span><br><span class="line"><span class="keyword">auto</span> newedMessage = input.<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装了 DynamicMessageGenerator，生成消息</span></span><br><span class="line">Message * generatedMessage = generator.<span class="built_in">paramToMessage</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;this_is_str&quot;</span>, <span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Generated Content:\n&quot;</span> &lt;&lt;generatedMessage-&gt;<span class="built_in">DebugString</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 generatedMessage 赋值给 newedMessage</span></span><br><span class="line">newedMessage-&gt;<span class="built_in">ParseFromString</span>(generatedMessage-&gt;<span class="built_in">SerializeAsString</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> downNewed = google::protobuf::internal::<span class="built_in">DownCast</span>&lt; Input *&gt;(newedMessage);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;downNewed Content:\n&quot;</span>&lt;&lt; downNewed-&gt;<span class="built_in">DebugString</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> downGenerated = google::protobuf::internal::<span class="built_in">DownCast</span>&lt; Input *&gt;(generatedMessage);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;downGenerated Content:\n&quot;</span>&lt;&lt; downGenerated-&gt;<span class="built_in">DebugString</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>但是这样使用会导致使用动态工厂生成的消息抛出类型检查错误，错误信息为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出信息</span></span><br><span class="line">Generated Content:</span><br><span class="line">strVal: <span class="string">&quot;this_is_str&quot;</span></span><br><span class="line">intVal: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">downNewed Content:</span><br><span class="line">strVal: <span class="string">&quot;this_is_str&quot;</span></span><br><span class="line">intVal: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Assertion failed: (f == <span class="literal">nullptr</span> || <span class="built_in">dynamic_cast</span>&lt;To&gt;(f) != <span class="literal">nullptr</span>), function down_cast, file casts.h, line <span class="number">94.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应 protobuf 代码段</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> To, <span class="keyword">typename</span> From&gt;     <span class="comment">// use like this: down_cast&lt;T*&gt;(foo);</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> To <span class="title">down_cast</span><span class="params">(From* f)</span> </span>&#123;                   <span class="comment">// so we only accept pointers</span></span><br><span class="line">  <span class="comment">// Ensures that To is a sub-type of From *.  This test is here only</span></span><br><span class="line">  <span class="comment">// for compile-time type checking, and has no overhead in an</span></span><br><span class="line">  <span class="comment">// optimized build at run-time, as it will be optimized away</span></span><br><span class="line">  <span class="comment">// completely.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">implicit_cast</span>&lt;From*, To&gt;(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(NDEBUG) &amp;&amp; PROTOBUF_RTTI</span></span><br><span class="line">  <span class="built_in">assert</span>(f == <span class="literal">nullptr</span> || <span class="built_in">dynamic_cast</span>&lt;To&gt;(f) != <span class="literal">nullptr</span>);  <span class="comment">// RTTI: debug mode only!</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;To&gt;(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码中的提醒信息，将 CMake 的构建方式设置为 Release 模式， assert 代码被跳过，测试程序可以正常运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Generated Content:</span><br><span class="line">strVal: <span class="string">&quot;this_is_str&quot;</span></span><br><span class="line">intVal: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">downNewed Content:</span><br><span class="line">strVal: <span class="string">&quot;this_is_str&quot;</span></span><br><span class="line">intVal: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">downGenerated Content:</span><br><span class="line">strVal: <span class="string">&quot;this_is_str&quot;</span></span><br><span class="line">intVal: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里的一行 assert 代码在 Debug 模式时确实会比较麻烦，算是一个小坑吧。</p><h2 id="动态工厂反射简单封装"><a href="#动态工厂反射简单封装" class="headerlink" title="动态工厂反射简单封装"></a>动态工厂反射简单封装</h2><p>由于动态工厂的接口直接用起来非常麻烦，需要使用多个类才能完成反射的赋值，因此将这几个类进行封装，并最终通过一行代码进行动态消息生成。这里主要是通过 C++中的类型检查和动态参数来完成的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> google::protobuf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> google::protobuf::compiler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicGenerator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 构造函数，主要负责从硬盘中读取 proto 文件并导入内存</span></span><br><span class="line">  <span class="comment">/// \param disk_path 读取路径</span></span><br><span class="line">  <span class="comment">/// \param proto_name proto 文件名</span></span><br><span class="line">  <span class="built_in">DynamicGenerator</span>(<span class="type">const</span> std::string &amp;disk_path,<span class="type">const</span> std::string &amp;proto_name) :</span><br><span class="line">  <span class="built_in">m_factory</span>(<span class="keyword">new</span> DynamicMessageFactory), <span class="built_in">source</span>(<span class="keyword">new</span> DiskSourceTree) &#123;</span><br><span class="line">    source-&gt;<span class="built_in">MapPath</span>(<span class="string">&quot;&quot;</span>, disk_path);</span><br><span class="line">    importer.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Importer</span>(&amp;*source, &#123;&#125;));</span><br><span class="line">    <span class="comment">//runtime compile foo.proto</span></span><br><span class="line">    importer-&gt;<span class="built_in">Import</span>(proto_name);</span><br><span class="line">    pool = importer-&gt;<span class="built_in">pool</span>();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 获得反射赋值后的 Message</span></span><br><span class="line">  <span class="comment">/// \tparam Types 模板参数，允许每一个 param 类型不同</span></span><br><span class="line">  <span class="comment">/// \param type Message 类型描述符</span></span><br><span class="line">  <span class="comment">/// \param params Message 参数，需要按照定义顺序输入</span></span><br><span class="line">  <span class="comment">/// \return 反射赋值后的 Message 指针</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Types&gt;</span></span><br><span class="line"><span class="function">  Message *<span class="title">paramToMessage</span><span class="params">(<span class="type">const</span> Descriptor *type, Types ... params)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Message *tempo = m_factory-&gt;<span class="built_in">GetPrototype</span>(type);</span><br><span class="line">    Message *message = tempo-&gt;<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Reflection *reflection = message-&gt;<span class="built_in">GetReflection</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>...(params) &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">addValues</span>(input, reflection, message, params...);</span><br><span class="line"></span><br><span class="line">    field_id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> DescriptorPool *pool;</span><br><span class="line">  std::unique_ptr&lt;DynamicMessageFactory&gt; m_factory;</span><br><span class="line">  std::unique_ptr&lt;DiskSourceTree&gt; source;</span><br><span class="line">  std::unique_ptr&lt;Importer&gt; importer;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> field_id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值实现，利用 Reflection 设置指定 field 的值</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span></span></span><br><span class="line"><span class="function">  <span class="title">addValues</span><span class="params">(<span class="type">const</span> Descriptor *input, <span class="type">const</span> Reflection *reflection, Message *message,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> Type &amp;param)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> field = input-&gt;<span class="built_in">FindFieldByNumber</span>(field_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (field == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Invalid field_id.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_same_v&lt;Type, std::string&gt; || std::is_same_v&lt;Type, <span class="type">const</span> <span class="type">char</span> *&gt;)</span> </span>&#123;</span><br><span class="line">      reflection-&gt;<span class="built_in">SetString</span>(message, field, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;Type, <span class="type">int</span>&gt;) &#123;</span><br><span class="line">      reflection-&gt;<span class="built_in">SetInt32</span>(message, field, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;Type, <span class="type">float</span>&gt;) &#123;</span><br><span class="line">      reflection-&gt;<span class="built_in">SetFloat</span>(message, field, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;Type, <span class="type">double</span>&gt;) &#123;</span><br><span class="line">      reflection-&gt;<span class="built_in">SetDouble</span>(message, field, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Unknown Type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(param).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    field_id++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接口，依次递归调用每一个 params</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type, <span class="keyword">typename</span> ...Types&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">addValues</span><span class="params">(<span class="type">const</span> Descriptor *input, <span class="type">const</span> Reflection *reflection, Message *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> Type &amp;param, <span class="type">const</span> Types &amp;... params)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addValues</span>(input, reflection, message,  param);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addValues</span>(input, reflection, message,params...);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP出现异常如何处理</title>
      <link href="/2021/11/03/TCP%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
      <url>/2021/11/03/TCP%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>TCP 连接状态的维护是在内核协议栈上的，它保存了一个 TCP 中的序列号、四元组、绑定进程等信息，并且负责维护进程的收发缓冲区，TCP 异常也是根据这些信息来进行处理的</p><h2 id="报文处理原则"><a href="#报文处理原则" class="headerlink" title="报文处理原则"></a>报文处理原则</h2><p>任何非 RST 报文都是按照次序进行处理的，若出现包延迟或丢包，seq 不连续的报文将会被放入等待队列中等待处理。</p><h2 id="异常原则"><a href="#异常原则" class="headerlink" title="异常原则"></a>异常原则</h2><p>在 TCP 状态机中，只要有任何一个位置出现异常，都会以一个 RST 包来结束本次 TCP 连接来标识本次连接发生了异常。当内核中的 TCP 协议栈收到 RST 包后，会检查 RST 包的序列号，如果序列号正确，将会<strong>立刻丢弃掉缓冲区内的所有数据</strong>并且告知本端进程错误，即 Connection Reset By Peer。</p><h2 id="本端进程状态"><a href="#本端进程状态" class="headerlink" title="本端进程状态"></a>本端进程状态</h2><p>内核协议栈会检查 Socket 所绑定进程的状态，以及该进程对 Socket 的读写权限；并根据这些信息来处理相关异常情况。</p><ol><li><p>Socket 直接由协议栈回收时，将会释放协议栈相关资源，并且向对方发送 RST 包关闭连接；</p></li><li><p>若进程关闭了读权限，对端继续写入将会收到 RST 包，因为进程永远不会读到新发送的数据；</p></li><li><p>若进程在有读缓冲区的情况下关闭 Socket，将会给对方发送 RST 包；</p></li></ol><p>情况一对应了一个进程崩溃，或者进程没有正确关闭 Socket 的情况。在这种情况下，Socket 并不是由进程主动释放的，而是由协议栈来进行回收的，这时协议栈会判断为进程因为某些原因而异常退出，协议栈所能采取的更安全的做法就是立刻丢弃掉缓冲区内的数据，并且向对端发送 RST。因此，只有在进程退出时主动释放 Socket 相关资源才是安全的，否则会导致写入缓冲区的数据并不会完全被对方收到。</p><p>情况二对应了 TCP 四次挥手时进程不正常关闭而导致出现孤儿 Socket。当 TCP 主动关闭的端直接使用 close 来关闭 Socket 的读写时，对端继续写入数据是无法被对端收到的。但协议栈并不能判断对方是否仍然有数据来写入，因此协议栈中仍然会保留该 Socket，如果对端在四次挥手中没有需要写入的数据，那么就会被视为一次正常关闭，否则将会被视为异常关闭。</p><p>情况三则代表了虽然协议栈中收到了 TCP 数据包，但是在进程层面来看则并没有收到，因此内核协议栈是有责任来告知这一次连接并不是被安全关闭的。</p><h2 id="TCP-状态机"><a href="#TCP-状态机" class="headerlink" title="TCP 状态机"></a>TCP 状态机</h2><p>内核协议栈还会根据当前维护的 TCP 状态机来决定如何对收到的 TCP 报文做出应答。虽然 TCP 已经采取了多种机制来避免收到非本次连接中的 TCP 包，但是仍有一定概率会收到异常包。根据收到的报文种类，可以分为以下几个异常情景：</p><ol><li>收到非窗口内的非 SYN 报文，不回复；</li><li>已建立连接收到了一个 SYN 包，这时会回复 Challenge ACK；</li><li>收到一个指向不存在的或不存活的 Socket 的请求，回复 RST；</li><li>Time Wait 状态收到 SYN 包。</li></ol><p>情况一比较容易理解，即收到了延迟较高的数据包，或者收到了非本次连接的包。</p><p>情况二区别于情况一，收到一个乱序的 SYN 包并不会丢弃，而是要采取更为复杂的处理措施。因为该乱序的 SYN 包可能是本次连接的超时包，也可能是来自一个新的三次握手的请求包。即对端崩溃后，本端并没有及时感知到，对端又再一次发送了连接请求。显然，后一种情况下，TCP 连接已经不安全了，因此内核会发送一个带有当前 TCP 序列号的 ACK 包，称为 Challenge ACK，用于确认对端的状态。如果这是一个过期的 SYN 包，那么对端 TCP 仍然是存活的，这时该 ACK 包会在窗口内，对端不会进行回复。如果对端是崩溃后重连，则该 ACK 序列号并不符合期望，对端协议栈将会发送一个 RST 包来重置连接。</p><p>情况三也比较容易理解，即当前 host 没有绑定进程，或者 host 正处于 timewait 等不可用状态。</p><p>而第四种情况较为特殊，当 Time Wait 状态下收到一个序列号大于当前序列号的 SYN 包，并且四元组相同，该 socket 将会被复用。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 并发编程实践笔记</title>
      <link href="/2021/08/23/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/23/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="序论"><a href="#序论" class="headerlink" title="序论"></a>序论</h1><h2 id="并发的一些基本概念"><a href="#并发的一些基本概念" class="headerlink" title="并发的一些基本概念"></a>并发的一些基本概念</h2><ul><li><p>并发：在单个系统中可以同时执行多个独立的任务，这些任务可是不是在同一时刻开始的。<strong>并发的关注点为任务分离和任务响应</strong></p></li><li><p>并行：是指系统在同一时刻创建出多个并发的线程，这些任务的开始间隔很小，近似为同一时刻。<strong>并行的关注点再数据批量处理</strong></p></li><li><p>C++中，同一进程的线程之间是共享同一片内存地址的；而进程之间的内存地址之间是隔离开的。因此，进程之间的通信十分复杂，或通信速度较慢；而线程之间的通信简单，且速度很快。</p></li><li><p>并发的缺点：并发的设计和维护的代价非常大，也更容易引起错误。过多的线程也会造成系统的运行效率下降。</p></li><li><p>C++标准库对系统底层工具进行了封装，<strong>这代表其会产生一定的抽象代价</strong>     </p></li></ul><h2 id="并行的常用方式"><a href="#并行的常用方式" class="headerlink" title="并行的常用方式"></a>并行的常用方式</h2><ul><li>任务并行：将一个大任务分为几部分，各自单独运行。数据分批次，算法是整体的。<strong>任务并行常常用来提升任务运行速度</strong></li><li>数据并行：将一个算法分为几部分，形成线程之间的流水线工作。<strong>数据并行常常用来提升数据吞吐量</strong></li></ul><h2 id="并发编程常用思想"><a href="#并发编程常用思想" class="headerlink" title="并发编程常用思想"></a>并发编程常用思想</h2><p>​    下面介绍的是在并发编程中经常会用到的一些模式和思想。</p><h3 id="函数化编程"><a href="#函数化编程" class="headerlink" title="函数化编程"></a>函数化编程</h3><p>​    函数化编程是指函数的结果只依赖于传入函数的参数，而不依赖于外部的状态。通常所说的外部状态有：全局变量，外部域变量、系统参数等，<strong>注意不要忽略系统参数</strong>。函数化编程具有以下的优点：</p><ul><li><strong>可再现性</strong>：函数化编程的结果与输入一一对应，可以避免一些预料之外的错误。</li><li><strong>低条件竞争</strong>：函数化编程不依赖外部参数，因而很难会发生条件竞争。</li><li><strong>高并发</strong>：采用函数化编程，可以在同一时刻并发多个线程，而不会造成阻塞。</li></ul><h3 id="通信顺序处理"><a href="#通信顺序处理" class="headerlink" title="通信顺序处理"></a>通信顺序处理</h3><p>​    通信顺序处理是指线程之间的消息只通过消息队列传递，而不使用共享地址空间。由于 C++线程共享一块地址空间，所以 C++只能够模拟而非真正实现通信顺序处理。</p><p>​    基于通信顺序处理，可以实现多线程下的有限状态机</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>​    指数据结构在多线程环境下，无数据的丢失和损毁，所有的数据需要维持原样且无条件竞争。    <strong>单纯使用锁会导致序列化，即线程只能轮流访问被保护的数据；在数据结构这个节点上并不能实现真正的并发</strong>；线程安全的含义：</p><ul><li>确保无线程能看到修改够数据结构的“不变量”时的状态，即<strong>数据修改对任何线程是原子的</strong></li><li>小心会引起条件竞争的接口，提供完整操作的函数，而非<strong>操作步骤</strong></li><li>注意数据结构的行为是否会产生异常，从而确保“不变量”的状态，即<strong>实现“异常-安全”</strong></li><li>降低死锁概率，限制锁的范围，降低锁的粒度，避免嵌套锁的存在。</li></ul><h1 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h1><h2 id="简单地定义一个模板的初始化"><a href="#简单地定义一个模板的初始化" class="headerlink" title="简单地定义一个模板的初始化"></a>简单地定义一个模板的初始化</h2><p>C++线程是一个模板类，提供的函数对象和数据（除 <code>std::ref()</code>外）都会被复制到新的线程中去，<strong>如果拷贝后主线程的函数或数据发生变化不会造成子线程的变化，这可能会导致一些错误</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">int</span> &amp; num)</span></span>&#123; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">createFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用类的成员函数时要加上 &amp;类型::</span></span><br><span class="line">    <span class="comment">//默认参数需要拷贝到新线程中去，除非显示使用 std::ref</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(&amp;SomeClass::someFunction,<span class="keyword">this</span>,std::ref(num))</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个线程可以被 Join 一次，主线程运行至 join 处</span></span><br><span class="line"><span class="comment">//会等待其他线程运行完毕</span></span><br><span class="line"><span class="keyword">if</span>(thread1.joinable)</span><br><span class="line">thread1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//detach 通常用来分离守护线程,被分离后的线程不能 Join</span></span><br><span class="line"><span class="comment">//守护线程：没有显显式的用户接口，在后台持续运行，可能会贯穿整个应用生命周期</span></span><br><span class="line">thread1.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//yield 用来主动让出时间片，即若有其他线程在等待，则优先让其他线程运行</span></span><br><span class="line">thread1.<span class="built_in">yield</span>();</span><br></pre></td></tr></table></figure><ul><li>std::thread 变量是一个右值类型，不能够拷贝和赋值，只能够使用 std::move 进行移动操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设有两个线程 thread1、thread2 </span></span><br><span class="line"></span><br><span class="line">thread1 = thread2 <span class="comment">//这是错误的</span></span><br><span class="line">thread1.<span class="built_in">swap</span>(thread2);<span class="comment">//thread1和 thread2 相互交换</span></span><br><span class="line"></span><br><span class="line">thread1 = std::<span class="built_in">move</span>(thread2)<span class="comment">// thread2交给 thread1 管理，自身变为空值；thread1原本的会直接被终止，不抛出异常</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//函数可以返回一个 std::thread 类型的对象</span></span><br><span class="line">std::thread <span class="built_in">createThread</span>()&#123;</span><br><span class="line">  <span class="comment">//返回的对象必须被初始化</span></span><br><span class="line">  std::thread <span class="built_in">t</span>();</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有关 thread 的一些操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程的标识符</span></span><br><span class="line">std::this_thread::<span class="built_in">get_id</span>();<span class="comment">//获得当前运行线程的 id</span></span><br><span class="line">thread1.<span class="built_in">get_id</span>();<span class="comment">//获得 thread1 的 id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得允许运行的最大线程数量</span></span><br><span class="line"><span class="comment">//注意，这个数量并不是安全的，因为同一时间在多个线程中调用会返回同一个值</span></span><br><span class="line"><span class="comment">//如果按照这个数量来创建线程，往往会超出系统负载</span></span><br><span class="line"><span class="type">int</span> max_thread_num = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>多线程编程中的“异常-安全”</li></ul><h1 id="线程间的共享数据——mutex"><a href="#线程间的共享数据——mutex" class="headerlink" title="线程间的共享数据——mutex"></a>线程间的共享数据——mutex</h1><p>​    问题来源：当多个线程同时访问一个共享的数据时，它只保留刚刚读取时的信息，若读取后数据被更新，线程并不会保证其所使用的数据为最新版本。当多个线程同时要修改一个数据，就会引发一些问题，这叫作条件竞争。<strong>条件竞争是时间敏感的，通常难以在 debug 模式下进行复现</strong></p><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>​    c++中的基本互斥量有三种：<code>std::mutex</code> 、 <code>std::shared_mutex</code>和<code>std::recursive_mutex</code>。互斥量本身不绑定任何一个数据，它相当于标志出一个临界区，使用同一个互斥量的线程不能够进入同一个临界区，而非禁止访问资源。</p><p>​    <code>std::shared_mutex</code> 是一个<strong>读者-写者锁</strong>。用它来保护一个数组的时候，允许在不同的元素上进行读写操作；即他只会保护被写的那一个元素，而非是保护整个数组。</p><p>​    <code>std::recursive_mutex</code>是一个<strong>嵌套锁</strong>。嵌套锁用于并发访问的类上，用于解决成员函数之间的嵌套使用。如一个类中有 A 和 B 两个函数，两个函数都具有独立功能，但 B 依赖于 A 实现，且 A 和 B 都使用了锁。使用嵌套锁可以解决这个问题，但<strong>不推荐</strong>。推荐——将公共部分提取出来作为 private 函数，再设计两套接口来分别调用这个函数。</p><h3 id="使用互斥量"><a href="#使用互斥量" class="headerlink" title="使用互斥量"></a>使用互斥量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;<span class="comment">//不推荐直接对 mutex 进行操作</span></span><br><span class="line">  <span class="comment">//临界区</span></span><br><span class="line">&#125;<span class="comment">//离开作用域时退出临界区</span></span><br></pre></td></tr></table></figure><h3 id="避免指针指向临界区资源"><a href="#避免指针指向临界区资源" class="headerlink" title="避免指针指向临界区资源"></a>避免指针指向临界区资源</h3><p>使用互斥量时，防止有指针指向临界区内的数据，互斥量向底层传递，不向顶层传递</p><p>互斥量可以锁住一个对象本身以及其所用到的所有资源，但是不能够锁住指向这个对象的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *_ptr=&amp;i;<span class="comment">//通过_ptr 可以指向i</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;<span class="comment">//不推荐直接对 mutex 进行操作</span></span><br><span class="line">  <span class="comment">//临界区</span></span><br><span class="line">  i++;</span><br><span class="line">&#125;<span class="comment">//离开作用域时退出临界区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">  *_ptr--;<span class="comment">//虽然 someFunction 中对 i 上锁，但是通过指针仍然可以访问该数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口间的条件竞争"><a href="#接口间的条件竞争" class="headerlink" title="接口间的条件竞争"></a>接口间的条件竞争</h3><p>​    接口间的竞争来源：考虑一个 STL 标准容器，其中的 empty 在调用时测试的可能是一个不空的数组，但是这个值返回时可能会有其他线程更改了数组，导致数组变为空的。</p><p>​    解决方法有几种：</p><ol><li><p>在多线程程序中，尽量避免定义一些描述数据结构“状态”的函数，如 <code>size()、empty()</code>等。</p></li><li><p>将状态函数使用时对整个数据结构加锁（会导致其他线程阻塞，并发度下降）</p></li><li><p>将状态函数与其他功能函数集成在一起，如使用 try_pop，若失败返回一个空变量。</p></li></ol><h3 id="使用互斥量可能造成死锁问题"><a href="#使用互斥量可能造成死锁问题" class="headerlink" title="使用互斥量可能造成死锁问题"></a>使用互斥量可能造成死锁问题</h3><p>​    死锁来源：不同线程尝试进入临界区的顺序不同，锁住互斥量的顺序不同。</p><ul><li><p>按照一定的优先级顺序来声明信号量，确保锁住互斥量的顺序是一致的。</p><p><strong>优先锁住高频率使用的互斥量，从而来降低线程之间的竞争</strong></p></li><li><p>使用 <code>std::lock()</code>来一次性锁住多个互斥量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx1,mtx2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在声明lock 时，相当于向系统一次性申请多个互斥量</span></span><br><span class="line">std::<span class="built_in">lock</span>(mtx1,mtx2);</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1,std::adopt_lock)</span></span>;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2,std::adopt_lock)</span></span>;</span><br><span class="line"><span class="comment">//如果 lock1 或 lock2 发生异常，那么将会自动释放所有互斥量</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>std::scoped_lock&lt;&gt;</code>来一次性锁住多个互斥量，<strong>C++17标准</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx1,mtx2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在声明lock 时，相当于向系统一次性申请多个互斥量</span></span><br><span class="line"><span class="function">std::scoped_lock <span class="title">guard</span><span class="params">(mtx1,mtx2)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>当线程已经进入临界区后，尽量避免调用其他用户提供的代码</p><p><strong>因为其他用户可能在底层使用了锁，可能会造成死锁</strong></p></li><li><p>在多线程环境下，访问有回路的数据结构，如图、双向列表等要规定访问顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个可能会造成死锁的例子</span></span><br><span class="line"><span class="comment">//假设有一个列表 A-B-C</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////thread1 执行功能从 A 结点删除 B</span></span><br><span class="line"><span class="comment">////thread2 执行功能从 B 结点删除 A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////规定互斥量必须从 A 开始按照顺序获取，才不会造成死锁</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="使用层级互斥锁来避免死锁"><a href="#使用层级互斥锁来避免死锁" class="headerlink" title="使用层级互斥锁来避免死锁"></a>使用层级互斥锁来避免死锁</h2><p>​    层次锁：高层次的锁将无法锁住低层次的锁，从而可以按照层级来设计代码，防止层级之间的死锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hierarchical_mutex <span class="title">high_level_mutex</span><span class="params">(<span class="number">10000</span>)</span></span>; <span class="comment">// 1</span></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">low_level_mutex</span><span class="params">(<span class="number">5000</span>)</span></span>; <span class="comment">// 2</span></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">other_mutex</span><span class="params">(<span class="number">6000</span>)</span></span>; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">do_low_level_stuff</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">low_level_func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(low_level_mutex)</span></span>; <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">do_low_level_stuff</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">high_level_stuff</span><span class="params">(<span class="type">int</span> some_param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">high_level_func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(high_level_mutex)</span></span>; <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">high_level_stuff</span>(<span class="built_in">low_level_func</span>()); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">high_level_func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">other_stuff</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">high_level_func</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">do_other_stuff</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_b</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(other_mutex)</span></span>; <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">other_stuff</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock()"></a><code>std::unique_lock()</code></h2><p>这是一个“延边锁”，通常运用在提前声明互斥量，但不直接加锁的情况下（如一个循环中）。<strong>std::unique_lock 开销较大</strong></p><p><strong>将锁声明在外部作用域中，在内部作用域需要不停地进行加锁和解锁</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx,std::defer_lock)</span></span>;<span class="comment">//这里声明了互斥量，但是并没有真正加锁</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">std::<span class="built_in">lock</span>(lk);<span class="comment">//在这里才真正被加锁</span></span><br><span class="line"><span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////std::unique_lock 也可以被传递//////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">getLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx,std::adopt_lock)</span></span>;</span><br><span class="line">  <span class="comment">////这里锁住一些变量</span></span><br><span class="line">  <span class="keyword">return</span> lk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="锁的粒度与线程阻塞"><a href="#锁的粒度与线程阻塞" class="headerlink" title="锁的粒度与线程阻塞"></a>锁的粒度与线程阻塞</h2><p>​    锁的粒度是一个摆手术语，用来描述通过一个锁保护的数据量的大小。</p><ul><li><p>若锁的粒度过大，可能会造成线程的竞争激烈，许多线程因为无法进入临界区而被阻塞，从而大大降低系统的并发性。</p></li><li><p>但过小粒度的锁，会造成锁本身占用系统的资源过大，而且也会造成程序的设计维护问题。</p></li><li><p><strong>只有当一个程序准备好所有资源后，再去请求一个锁，可以明显地降低线程的阻塞</strong></p></li></ul><h2 id="资源初始化——std-call-once"><a href="#资源初始化——std-call-once" class="headerlink" title="资源初始化——std::call_once"></a>资源初始化——<code>std::call_once</code></h2><p>​    资源初始化是一个看似简单，但其实十分复杂的问题，使用<code>std::call_once</code>可以显著降低多线程中资源初始化的风险。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::once_flag resource_flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initCamera</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createCamera</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//注意，这里的使用和 std::thread 类似，函数不能加（），如果是类内函数需要标注</span></span><br><span class="line">std::<span class="built_in">call_once</span>(resource_flag,initCamera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免使用双重锁"><a href="#避免使用双重锁" class="headerlink" title="避免使用双重锁"></a>避免使用双重锁</h2><h1 id="并发同步操作"><a href="#并发同步操作" class="headerlink" title="并发同步操作"></a>并发同步操作</h1><p>​    期望值解决的是线程之间应当如何解决通信问题。使用共享内存区域进行线程通信的方法虽然简单，但是在无形之中阻塞了程序，造成工作效率的下降；并且，使用<code>std::thread</code>是无法进行函数的右值返回的，因而需要<strong>条件变量</strong>和<strong>期望值</strong>来解决线程之间的简单通信问题。</p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>​    STL 中条件变量主要有两种：<code>std::condition_variable</code>以及<code>std::condition_variable_any</code>。后者可以接受任何锁类型，但是开销较大，一般只采用前一种类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function">std::condition_variable cond</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="comment">/////////一系列功能///////////</span></span><br><span class="line">cond.<span class="built_in">notify_one</span>();</span><br><span class="line">  cond.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////等待的地方要和通知的地方实用相同的锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;<span class="comment">//注意，等待这里建议使用 unique_lock，因为解锁更加方便</span></span><br><span class="line">cond.<span class="built_in">wait</span>(lk,[]()&#123;<span class="comment">// 如果不满足后续条件，那么将会解锁 lk</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;)<span class="comment">//只有在接收了通知并且 lambda 表达式返回 true 时才能进入临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><h2 id="期望值std-future"><a href="#期望值std-future" class="headerlink" title="期望值std::future"></a>期望值<code>std::future</code></h2><p>​    期望值用于<strong>仅仅等待一次的情况</strong>；使用<code>std::condition_varivable</code>时，每次尝试进入临界区都会进行等待，这对于<strong>重复调用的函数</strong>会造成较差的性能。</p><p>​    期望值分为唯一期望值<code>std::future&lt;&gt;</code> 以及<code>std::shared_future&lt;&gt;</code>。后者可以被多个线程使用，前者只能被使用一次。<strong>两者都是只能被移动而不能够被拷贝</strong></p><h3 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a><code>std::async</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">someFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里函数名同样也是不能带括号，其他规则同 thread</span></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; future1 = std::<span class="built_in">async</span>(someFuncion，std::launch::async);<span class="comment">//函数必须在该线程上运行</span></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; future2 = std::<span class="built_in">async</span>(someFuncion，std::launch::defered);<span class="comment">//需要结果时才会运行</span></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; future3 = std::<span class="built_in">async</span>(someFuncion，std::launch::defered|std::launch::async);<span class="comment">//由系统选择</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result = future2.<span class="built_in">get</span>();<span class="comment">//使用 get()函数来调取结果，future2 在这里才会被运行</span></span><br></pre></td></tr></table></figure><h3 id="std-packaged-task-lt-gt"><a href="#std-packaged-task-lt-gt" class="headerlink" title="std::packaged_task&lt;&gt;"></a><code>std::packaged_task&lt;&gt;</code></h3><p>​    <code>std::packaged_task&lt;函数类型（函数参数类型）&gt;</code>这是用来打包一个函数任务的，通常用来在主线程将任务打包并将结果期望绑定，再将运行放入子线程中。    </p><p>​    <strong>当打包的任务出现异常时，该异常会被自动传播到主线程去，需要在主线程解决</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////packaged_task仅仅是将一个可执行任务打包，而并没有执行这个任务</span></span><br><span class="line"><span class="comment">////future 相当于一个指针，指向一个 packaged_task 的返回值。</span></span><br><span class="line"><span class="comment">////当使用 future 的时候，线程会等待返回结果（如果没有运行就会一直等待）</span></span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">tsk</span><span class="params">(test)</span></span>;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = tsk.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">////使用 std::move将 packaged_task 放入一个线程中</span></span><br><span class="line"><span class="function">std::thread <span class="title">th</span><span class="params">(std::move(tsk), <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> val = fut.<span class="built_in">get</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Main thread gets value &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">th.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><h3 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a><code>std::promise</code></h3><p>​    <code>std::promise</code>允许用户自由地在子线程和主线程之间<strong>合适的位置来处理异常</strong>。可以实现子线程不抛出异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设这是一个将要单独在一个线程中运行的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">someFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      promise.<span class="built_in">set_value</span>(<span class="number">1</span>);<span class="comment">// 正常运行，将结果送入期望中</span></span><br><span class="line">  &#125;<span class="built_in">catch</span>()&#123;</span><br><span class="line">    promise.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());<span class="comment">//promise 会直接在子线程中对异常进行处理，而非送回到主线程去</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="共享期望-std-shared-future"><a href="#共享期望-std-shared-future" class="headerlink" title="共享期望 std::shared_future"></a>共享期望 std::shared_future</h2><p>​    共享期望允许多个线程共同获取一个结果，如何初始化一个共享期望：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////////////直接绑定//////////////////</span></span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">tsk</span><span class="params">(test)</span></span>;</span><br><span class="line">std::shared_future&lt;<span class="type">int</span>&gt; fut = tsk.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////绑定已有期望///////////////</span></span><br><span class="line">std::shared_future&lt;<span class="type">int</span>&gt; fut = future.<span class="built_in">share</span>();</span><br></pre></td></tr></table></figure><h2 id="限定等待时间"><a href="#限定等待时间" class="headerlink" title="限定等待时间"></a>限定等待时间</h2><p>​    除了按照条件等待，线程之间还可以设置等待时间，用于防止过长的等待而造成的线程阻塞。</p><h3 id="C-中的时钟"><a href="#C-中的时钟" class="headerlink" title="C++中的时钟"></a>C++中的时钟</h3><p>​    C++的时钟库是<code>&lt;chrono&gt;</code>，该库可以调用系统时间（是一个不稳定的时钟：稳定时钟的节拍均匀且不可调整；系统时钟通常可以调整节拍）。</p><p>​    C++时钟量，两个时间点相减表示一个时间段；时间点加减时间段等于时间点，<strong>会发生隐式的类型转换</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定时钟节拍：</span></span><br><span class="line">std::ratio&lt;<span class="number">1</span>,<span class="number">25</span>&gt;<span class="comment">//代表一秒钟有 25 个节拍</span></span><br><span class="line">std::ratio&lt;<span class="number">5</span>,<span class="number">2</span>&gt;<span class="comment">//代表五秒钟有两个节拍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取系统时钟当前的时间</span></span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>()</span><br><span class="line">  </span><br><span class="line"><span class="comment">//如何表示一段时延，第一个参数是数据类型，第二个参数是单位</span></span><br><span class="line">std::chrono::duration&lt;,&gt;</span><br><span class="line">std::chrono::duration&lt;<span class="type">int</span>,std::ratio&lt;<span class="number">60</span>,<span class="number">1</span>&gt;&gt;</span><br><span class="line">std::chrono::<span class="built_in">duration</span>&lt;<span class="type">long</span> <span class="type">long</span>, std::milli&gt;(<span class="number">100</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//使用 std::chrono::时间量来表示时间段</span></span><br><span class="line">std::chrono::<span class="built_in">nanoseconds</span>(<span class="number">15</span>);<span class="comment">//表示15纳秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间变量之间的相互转化</span></span><br><span class="line">std::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">54802</span>)</span></span>;</span><br><span class="line">std::chrono::seconds s = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(ms);</span><br></pre></td></tr></table></figure><h3 id="std-wait-for"><a href="#std-wait-for" class="headerlink" title="std::wait_for"></a><code>std::wait_for</code></h3><p>​    <code>std::wait_for</code>    用来限制等待线程期望值的时间，但实际等待的时间一般会比指定的时间要长，因为等待期间处理机可能会将线程调出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; future1 = std::<span class="built_in">async</span>(someFuncion，std::launch::async);</span><br><span class="line"><span class="comment">//////////////////////////限定线程只等待期望值35ms/////////////////////////////////</span></span><br><span class="line"><span class="keyword">if</span>(future.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>)) == std::future_status::ready)</span><br><span class="line">  future.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 wait_for 可能会返回的结果：</span></span><br><span class="line">std::future_status::ready<span class="comment">//代表等待的线程已经完成，期望值可以被 get</span></span><br><span class="line">std::future_status::deferred<span class="comment">//代表等待的线程被阻滞（没有在运行）</span></span><br><span class="line">std::future_status::timeout<span class="comment">//代表等待的线程运行超时了</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//////////对 condition_variable 使用 wait_for()/////////////</span></span><br><span class="line">std::condition_variable cond;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">cond.<span class="built_in">wait</span>(lk,std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>));</span><br></pre></td></tr></table></figure><h3 id="std-wait-until"><a href="#std-wait-until" class="headerlink" title="std::wait_until"></a><code>std::wait_until</code></h3><p>​    相比于<code>std::wait_for</code>，<code>std::wait_until</code>等待的时间由绝对时间决定；因此搭配时间点加时间段，可以实现等待准确的指定时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; future1 = std::<span class="built_in">async</span>(someFuncion，std::launch::async);</span><br><span class="line"><span class="comment">//////////////////////////限定线程只等待期望值35ms/////////////////////////////////</span></span><br><span class="line"><span class="keyword">if</span>(future.<span class="built_in">wait_for</span>(std::chrono::system_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>)</span><br><span class="line">                   == std::future_status::ready)</span><br><span class="line">  future.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><h3 id="互斥时间锁"><a href="#互斥时间锁" class="headerlink" title="互斥时间锁"></a>互斥时间锁</h3><p>​    互斥时间锁是一种与时间相关联的互斥信号量，其在尝试进入临界区时，会限定一段时间，当限定的时间结束后，仍未进入临界区，将会放弃进入临界区的行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::timed_mutextmtx;</span><br><span class="line">std::recursive_timed_mutexrtmtx;</span><br><span class="line"><span class="comment">//尝试在 35ms 的时间内获进入临界区，返回返回值为 bool 类型</span></span><br><span class="line">tmtx.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>));</span><br><span class="line">rtmtx.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>));</span><br></pre></td></tr></table></figure><h3 id="std-experimental-额外功能"><a href="#std-experimental-额外功能" class="headerlink" title="std::experimental 额外功能"></a>std::experimental 额外功能</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::experimental::when_all<span class="comment">//用来收集多个线程的期望</span></span><br><span class="line"></span><br><span class="line">std::experimental::when_any<span class="comment">//用来收集多个线程中任意一个的期望</span></span><br></pre></td></tr></table></figure><h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p>​    原子操作是指不可被分割的操作；即对于处理机来说，原子操作只有两个状态：未开始、已完成。</p><p>​    原子操作经常被用于指定线程访问的顺序从而实现无锁编程，相较于互斥信号量，占用的系统资源更少；但是相应地编程难度也大大提升。</p><p>​    <strong>原子操作的用法</strong>：</p><ul><li>作为一个通信的标识符，在线程间传递完成状态等信息。</li><li>作为一个模板，在数据结构修改时作为间接容器来存储要 I/O 的数据。<strong>当获得原子变量的权限后，才能进行修改</strong></li></ul><h2 id="C-中的原子类型"><a href="#C-中的原子类型" class="headerlink" title="C++中的原子类型"></a>C++中的原子类型</h2><p>​    C++的标准原子类型定义在头文件<code>&lt;atomic&gt;</code>中，这些所有的操作都是原子的。<strong>但其中的大部分都是使用互斥锁来模拟的（性能比用户使用互斥锁要好很多），只有 std::atomic_flag 是保证无锁的。</strong></p><p>​    <strong>C++中的标准原子类型不能进行拷贝和赋值，没有相关的操作符，但可以隐式转化成对应的内置类型。</strong></p><p>​    C++中的原子类型可以分为 std::atomic_flag 和 std::atomic&lt;&gt;。前者保证无锁，后者通常是有锁的。</p><table><thead><tr><th align="center">原子类型</th><th align="center">相关特化类</th></tr></thead><tbody><tr><td align="center">atomic_bool</td><td align="center">std::atomic<bool></td></tr><tr><td align="center">atomic_char</td><td align="center">std::atomic<char></td></tr><tr><td align="center">atomic_schar</td><td align="center">std::atomic<signed char></td></tr><tr><td align="center">atomic_uchar</td><td align="center">std::atomic<unsigned char></td></tr><tr><td align="center">atomic_int</td><td align="center">std::atomic<int></td></tr><tr><td align="center">atomic_uint</td><td align="center">std::atomic<unsigned int></td></tr><tr><td align="center">atomic_short</td><td align="center">std::atomic<short></td></tr><tr><td align="center">atomic_ushort</td><td align="center">std::atomic<unsigned short></td></tr><tr><td align="center">atomic_long</td><td align="center">std::atomic<long></td></tr><tr><td align="center">atomic_ulong</td><td align="center">std::atomic<unsigned long></td></tr><tr><td align="center">atomic_llong</td><td align="center">std::atomic<long long></td></tr><tr><td align="center">atomic_ullong</td><td align="center">std::atomic<unsigned long long></td></tr><tr><td align="center">atomic_char16_t</td><td align="center">std::atomic<char16_t></td></tr><tr><td align="center">atomic_char32_t</td><td align="center">std::atomic<char32_t></td></tr><tr><td align="center">atomic_wchar_t</td><td align="center">std::atomic<wchar_t></td></tr></tbody></table><h2 id="std-atomic-flag"><a href="#std-atomic-flag" class="headerlink" title="std::atomic_flag"></a><code>std::atomic_flag</code></h2><p>​    <code>std::atomic_flag</code>代表了一个bool 标志，可以在<strong>“设置”</strong>和<strong>“清除”</strong>两个状态之间转换。其初始化的标志位是“清除”状态。它具有两个个成员函数<code>clear()</code>、<code>test_and_set()</code>，前者是一个存储操作，后者是一个“读-改-写”操作。<code>test_and_set()</code>操作意味着，若读取出的值和要设置的值相同则无操作，若不同则设置为新值。</p><p>​    <code>std::atomic_flag</code>对象不能被拷贝和赋值，因为这两种操作会破坏其原子性。<strong>经常被用于实现自旋锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 std::atomic_flag 实现一个自旋锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpinLockMutex</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::atomic_flag flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SpinLockMutex</span>() : <span class="built_in">flag</span>(ATOMIC_FLAG_INIT)&#123;&#125;<span class="comment">//std::atomic_flag的唯一构造方式</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire));<span class="comment">//尝试对std::atomic_flag上锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    flag.<span class="built_in">clear</span>(std::memory_order_release);<span class="comment">//清除锁</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="std-atomic-lt-gt"><a href="#std-atomic-lt-gt" class="headerlink" title="std::atomic&lt;&gt;"></a><code>std::atomic&lt;&gt;</code></h2><p>​    <code>std::atomic&lt;bool&gt;</code>能够自由选择初始化的值，并且可以使用非原子的 bool 类型进行构造，但其具有抽象代价，不保证无锁。     <code>std::atomic&lt;bool&gt;</code>具有三个基本的成员函数：存储操作<code>store()</code>、加载操作<code>load()</code>、“读-改-写”操作<code>exchange()</code>；还具备两个特殊的“比较/交换”操作：<code>compare_exchange_weak()</code>、<code>compare_exchange_strong()</code>。</p><ul><li><strong>“比较/交换”操作</strong>：是原子类型编程的基石，它比较原子变量的当前值和一个期望值。当两值相等时，存储所提供的值；当两值不等时，期望值会被更新为原子变量中的值。<code>compare_exchange_weak()</code>不保证存储操作成功、<code>compare_exchange_strong()</code>保证存储操作成功。</li></ul><p>​    <code>std::atomic&lt;T*&gt;</code>继承了<code>std::atomic&lt;bool&gt;</code>的全部操作，只是返回类型不同；此外还具有“读-改-写”操作<code>fetch_add()</code>和<code>fetch_sub()</code>，用于在存储地址上进行<strong>原子加法和原子减法</strong>。</p><ul><li>除了基本类型外，用户可以用 class来自定义一个原子变量，前提是<strong>必须有拷贝赋值运算符，即不能有虚函数和基类，并且必须使用编译器默认创建的拷贝赋值操作</strong>。</li></ul><p>​    原子类型的操作函数具有两种调用方式，一种是作为原子变量的成员函数使用，另外一种是直接采用非成员函数的调用方式。非成员函数的调用方式通常是在成员函数名前加上“atomic_”前缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员函数版调用</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; aint;</span><br><span class="line">aint.<span class="built_in">load</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//非成员函数版本调用</span></span><br><span class="line">std::<span class="built_in">atomic_load</span>(&amp;atomic_var,new_value);</span><br><span class="line">std::<span class="built_in">atomic_load_explicit</span>(&amp;atomic_var,new_value,std::memory_order_release);<span class="comment">//需要指定内存序</span></span><br></pre></td></tr></table></figure><h2 id="操作排序"><a href="#操作排序" class="headerlink" title="操作排序"></a>操作排序</h2><p>​    利用原子操作可以实现对不同操作的排序，从而实现线程之间的有序，这是依赖于原子操作的同步发生与先行发生的。</p><ul><li><p>同步发生：同步发生只能在原子类型之间进行，即同一原子变量的原子操作具有同步传递性，改变后的状态会立刻传递给任何需要用到该原子变量的线程中去。</p></li><li><p>先行发生：先行发生发生在非原子操作上，且依赖于同步发生。即同步发生的原子操作可以视为一个时间点，在此时间点基础上，若一个操作先于该原子操作，则具有先行性。（A-原子解锁，原子锁-B，那么 A 会先于 B 发生）。</p><p>C++一共具有三种内存模型和六种内存操作，其对应关系如下：</p><ul><li><p><strong>排序一致性序列</strong>，对应memory_order_seq_cst</p></li><li><p><strong>获取-释放序列</strong>，对应 memory_order_consume,memory_order_acquire,memory_order_release,memory_order_acq_rel</p></li><li><p><strong>松散序列</strong>，对应 memory_order_relaxed</p><p><a href="https://blog.csdn.net/wxj1992/article/details/103656486?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.base&spm=1001.2101.3001.4242">对几种内存操作的详细介绍</a></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个简单的原子操作排序，①永远在②前面</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; count;</span><br><span class="line"><span class="comment">///////////thread1/////////////</span></span><br><span class="line"><span class="type">int</span> signal;<span class="comment">//操作顺序①</span></span><br><span class="line">count.<span class="built_in">store</span>(signal,std::memory::release);</span><br><span class="line"><span class="comment">///////////thread2/////////////</span></span><br><span class="line"><span class="type">int</span> received_signal = count.<span class="built_in">load</span>(std::memory::acquire);</span><br><span class="line">std::cout &lt;&lt; received_singal;<span class="comment">//操作顺序②</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><p>​    栅栏对内存序列进行约束，使其无法对任何数据进行修改。栅栏属于全局操作，执行栅栏操作可以影响到线程中的其他原子操作。<strong>利用栅栏操作可以在不依赖原子变量的情况下实现排序</strong>。</p><p>​    <strong>栅栏既可以和栅栏进行同步，也可以和原子操作进行同步</strong>。</p><p>​    栅栏一共分为六种，分别具有不同的效果：</p><table><thead><tr><th align="left">内存序列类型</th><th>栅栏类型</th><th align="center">栅栏效果</th></tr></thead><tbody><tr><td align="left">memory_order_relaxed</td><td>没有任何效果</td><td align="center">无效果</td></tr><tr><td align="left">memory_order_acquire/memory_order_consume</td><td>acquire fence</td><td align="center">阻止loadstore重排和storestore重排</td></tr><tr><td align="left">memory_order_release</td><td>release fence</td><td align="center">阻止loadload重排和loadstore重排</td></tr><tr><td align="left">memory_order_acq_rel</td><td>full fence</td><td align="center">防止loadload、loadstore、storestore重排</td></tr><tr><td align="left">memory_order_seq_cst</td><td>保证有单独全序的full fence</td><td align="center">防止loadload、loadstore、storestore重排</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用栅栏进行同步的实例</span></span><br><span class="line"><span class="function">std::string <span class="title">computation</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">( std::string )</span></span>;</span><br><span class="line"> </span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; arr[<span class="number">3</span>] = &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;<span class="comment">//use atomic data to communicate</span></span><br><span class="line">std::string data[<span class="number">1000</span>] <span class="comment">//non-atomic data</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Thread A, compute 3 values</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadA</span><span class="params">( <span class="type">int</span> v0, <span class="type">int</span> v1, <span class="type">int</span> v2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//assert( 0 &lt;= v0, v1, v2 &lt; 1000 );</span></span><br><span class="line">data[v0] = <span class="built_in">computation</span>(v0);</span><br><span class="line">data[v1] = <span class="built_in">computation</span>(v1);</span><br><span class="line">data[v2] = <span class="built_in">computation</span>(v2);</span><br><span class="line">std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);</span><br><span class="line">std::<span class="built_in">atomic_store_explicit</span>(&amp;arr[<span class="number">0</span>], v0, std::memory_order_relaxed);</span><br><span class="line">std::<span class="built_in">atomic_store_explicit</span>(&amp;arr[<span class="number">1</span>], v1, std::memory_order_relaxed);</span><br><span class="line">std::<span class="built_in">atomic_store_explicit</span>(&amp;arr[<span class="number">2</span>], v2, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Thread B, prints between 0 and 3 values already computed.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> v0 = std::<span class="built_in">atomic_load_explicit</span>(&amp;arr[<span class="number">0</span>], std::memory_order_relaxed);</span><br><span class="line"><span class="type">int</span> v1 = std::<span class="built_in">atomic_load_explicit</span>(&amp;arr[<span class="number">1</span>], std::memory_order_relaxed);</span><br><span class="line"><span class="type">int</span> v2 = std::<span class="built_in">atomic_load_explicit</span>(&amp;arr[<span class="number">2</span>], std::memory_order_relaxed);</span><br><span class="line">std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);</span><br><span class="line"><span class="comment">// v0, v1, v2 might turn out to be -1, some or all of them.</span></span><br><span class="line"><span class="comment">// otherwise it is safe to read the non-atomic data because of the fences:</span></span><br><span class="line"><span class="keyword">if</span>( v0 != <span class="number">-1</span> ) &#123; <span class="built_in">print</span>( data[v0] ); &#125;</span><br><span class="line"><span class="keyword">if</span>( v1 != <span class="number">-1</span> ) &#123; <span class="built_in">print</span>( data[v1] ); &#125;</span><br><span class="line"><span class="keyword">if</span>( v2 != <span class="number">-1</span> ) &#123; <span class="built_in">print</span>( data[v2] ); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于锁的并发数据结构"><a href="#基于锁的并发数据结构" class="headerlink" title="基于锁的并发数据结构"></a>基于锁的并发数据结构</h1><p>​    被用于共享的数据结构需要进行专门设计，否则可能会造成死锁、线程阻塞等一系列问题。以下是并发数据结构的设计目标：</p><ul><li><p>确保无线程能看到修改够数据结构的“不变量”时的状态，即<strong>数据修改对任何线程是原子的</strong></p></li><li><p>小心会引起条件竞争的接口，提供完整操作的函数，而非<strong>操作步骤</strong></p></li><li><p>注意数据结构的行为是否会产生异常，从而确保“不变量”的状态，即<strong>实现“异常-安全”</strong></p></li><li><p>降低死锁概率，限制锁的范围，降低锁的粒度，避免嵌套锁的存在。</p></li><li></li></ul><h1 id="无锁并发数据结构"><a href="#无锁并发数据结构" class="headerlink" title="无锁并发数据结构"></a>无锁并发数据结构</h1><p>​    无锁并发结构基于原子操作，通常是<strong>无阻塞的</strong>，<strong>自旋的</strong>；即处于等待状态下的线程会处于一个空循环load()状态，而不会进入阻塞状态。通常情况下，无锁结构的性能要优于有锁结构。</p><ul><li><strong>并发最大化</strong>：无锁结构可以允许多个不同功能的线程并发地访问数据结构，但不允许具有相同功能的线程同时访问。</li><li><strong>增加鲁棒性</strong>：有锁结构中，若一个线程在获取锁状态下被终止，共享数据结构将被破坏。</li><li><strong>访问线程无限制</strong>：通过操作顺序的约束，理论上无访问线程的限制。</li><li><strong>无死锁问题</strong>：因为没有使用互斥量，故不会发生死锁。</li><li><strong>不正确使用可能会降低整体性能</strong>：乒乓缓存等效应存在，对设计要求很高。不当设计会降低性能。</li></ul><h2 id="需要注意的一些问题"><a href="#需要注意的一些问题" class="headerlink" title="需要注意的一些问题"></a>需要注意的一些问题</h2><ul><li>尽可能使用<code>std::memory_order_seq_cst</code>，该内存序列是总序的，实现比较简单。只有在<strong>该内存序列上完成了所要设计的相关功能后，才考虑使用其他序列进行性能优化</strong></li><li>无锁并发数据结构不能在任何一个线程中删除某一节点，因此<strong>使用智能指针来进行管理</strong></li><li><strong>“ABA 问题”</strong>：数据结构中的值被交换出后，进行了一些修改导致不合法（尤其是），再被交换回数据结构会造成一系列问题。</li><li><strong>识别忙等待和帮助其他线程</strong>：当线程处于等待过程中，可以让其帮助正在工作的线程完成工作。</li></ul><h1 id="并发代码设计"><a href="#并发代码设计" class="headerlink" title="并发代码设计"></a>并发代码设计</h1><p>​    本章主要讲如何从系统的角度来设计并发代码，即如何分配工作使得代码的效率更高。</p><p>​    “可扩展”代码：随着系统的核数增加，代码的性能增加，理想情况下是线性增长的。</p><h2 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h2><p>​    将一个大任务分为几部分，各自单独运行。数据分批次，算法是整体的。<strong>常常用来提升任务运行速度</strong></p><ul><li>递归划分：每个任务线程都有开辟子线程的能力，会短时间内产生大量的线程，每个线程负责完成一小部分工作。</li></ul><h2 id="任务划分"><a href="#任务划分" class="headerlink" title="任务划分"></a>任务划分</h2><p>​    将任务看成几个部分，每个部分分别用一个线程独立完成工作。</p><p>​    <strong>当通过任务类型进行划分时，不应该让各个线程处于完全隔离的状态，而是采用流水线的方式进行并发</strong></p><h2 id="避免共享内存"><a href="#避免共享内存" class="headerlink" title="避免共享内存"></a>避免共享内存</h2><p>​    在多线程环境下使用共享内存可能会造成许多性能问题，<strong>尽量避免线程访问外部数据</strong>，<strong>尽量使用指针访问外部数据</strong></p><ul><li><p><strong>乒乓缓存</strong>：因为每个线程的内部变量是独立的，若有多个线程同时访问一个共享数据结构，会导致该数据结构不停地在每个处理机缓存中拷贝（每个线程都要保留最新状态），大大降低运行效率。</p><p>解决方法：使用互斥量对多行缓存进行保护，提高锁的粒度</p></li><li><p><strong>伪共享</strong>：因为处理器缓存是以行来存储的，若一个内存行的数据被多个线程所使用（数据粒度太小），会大大降低数据访问的速度（因为一个内存行一次只能被一个线程访问）。</p><p>解决方法：内存对齐、数据紧凑</p></li><li><p><strong>休眠造成缓存转移</strong>：当一个使用缓存的线程休眠后，可能被调至其他处理机运行，从而导致缓存的复制。</p><p>解决方法：已经使用缓存区的线程，防止其休眠或被调度</p></li></ul><h2 id="异常-安全"><a href="#异常-安全" class="headerlink" title="异常-安全"></a>异常-安全</h2><p>​    多线程环境下，要求在发生异常的情况下<strong>不抛出异常，保持共享数据结构的安全性</strong>，显然会带来额外的开销。<strong>每个线程必须在退出前处理好所有异常，保证异常不被抛出和传播（特殊情况，如果一个工作线程（不与主线程外交互），可以在其主线程上统一处理异常）</strong></p><p>​    通常，可能出现异常的情况有：</p><ul><li><strong>分配资源</strong>：创建对象，创建指针，开辟内存区域等。</li><li><strong>内存异常</strong>：内存溢出，指针越界等。</li><li><strong>指针异常</strong>：更改指针绑定时失败。</li><li><strong>函数调用</strong>：函数调用时，底层可能会抛出一些异常</li></ul><h1 id="高级线程管理"><a href="#高级线程管理" class="headerlink" title="高级线程管理"></a>高级线程管理</h1><p>​    仅仅采用创建线程对象的方式是难以在线程的整个生命周期对其进行管理的，如果需要对线程进行更加灵活和精细的管理，常常需要引入“线程池”和“中断线程”的方式来进行管理。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>​    <strong>线程池</strong>集中管理相似度较高的一组任务。这些任务被提交到线程池中的任务将并发执行，提交的任务将会挂在任务队列 上。队列中的每一个任务都会被池中的工作线程所获取，当任务执行完成后，再回到线程池中获取下一个任务。</p><p>​    <strong>线程池中的线程并不是直接运行任务函数，而是运行一个从任务队列中调用任务并加以运行的函数，这是为了方便线程池的初始化。</strong></p><p>​    高级线程池通常具备以下几个模块：</p><ul><li><p><strong>共享任务队列</strong>：用户将需要被运行的任务投入到共享任务队列中等待被调用。</p></li><li><p><strong>期望队列</strong>：期望队列与共享任务队列中的任务绑定，用户从此处获取运行结果。</p></li><li><p><strong>线程池</strong>：集中构造、析构和管理的一组线程，在线程空闲时使用 yield 或者尝试任务窃取。</p></li><li><p><strong>本地任务队列</strong>：线程池中的线程将共享任务队列拷贝到本地，避免因任务量过小导致乒乓缓存。</p></li><li><p><strong>任务窃取</strong>：当线程无任务可以运行时，可以尝试从其他线程的本地任务队列中窃取。</p></li></ul><h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>​    <strong>中断线程</strong>是对<code>std::thread</code>的一层封装，允许用户主动地去中断线程，被中断的线程会完成一些<strong>必要工作</strong>后退出。</p><h1 id="并行算法"><a href="#并行算法" class="headerlink" title="并行算法"></a>并行算法</h1><p>​    C++17版本引入了一些并行算法（保证线程安全），建议直接使用。这些并行算法是对之前标准库的重载，用法与函数名相同，<strong>只是引入了一个额外的策略参数（第一个）</strong>，策略参数一共有三种，被定义在<code>&lt;execution&gt;</code>头文件中：</p><ul><li><code>std::execution::seq</code>：要求函数的所有操作都在当前线程下<strong>单线程</strong>完成，<strong>不并行且不并发</strong>。</li><li><code>std::execution::par</code>：在多个线程中执行，并且线程各自具有自己的顺序任务。即<strong>并行但不并发。</strong></li><li><code>std::execution::par_unseq</code>：算法在多个线程中执行，并且线程可以具有并发的多个任务。即<strong>并行和并发。</strong></li></ul><p>​    执行并发算法时，如果算法运行触发了异常机制，且该异常未在调用算法的线程中被捕获，那么算法会自动调用<code>std::terminate</code>来中断。</p><p>​    标准库中的大多数被执行策略重载的算法都在 <code>&lt;algorithm&gt;</code> 和 <code>&lt;numeric&gt;</code>头文件中，目前已经包括：</p><p>​    all_of，any_of， none_of，for_each，for_each_n，find，find_if，find_end，find_first_of，adjacent_find， count，count_if，mismatch，equal，search，search_n，copy，copy_n，copy_if，move， swap_ranges，transform，replace，replace_if，replace_copy，replace_copy_if，fill， fill_n，generate，generate_n，remove，remove_if，remove_copy，remove_copy_if，unique， unique_copy，reverse，reverse_copy，rotate，rotate_copy，is_partitioned，partition， stable_partition，partition_copy，sort，stable_sort，partial_sort，partial_sort_copy， is_sorted，is_sorted_until，nth_element，merge，inplace_merge，includes，set_union， set_intersection，set_difference，set_symmetric_difference，is_heap，is_heap_until， min_element，max_element，minmax_element，lexicographical_compare，reduce， transform_reduce，exclusive_scan，inclusive_scan，transform_exclusive_scan， transform_inclusive_scan和adjacent_difference</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书籍阅读建议</title>
      <link href="/2021/01/01/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB%E5%BB%BA%E8%AE%AE/"/>
      <url>/2021/01/01/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>这里汇总了本人阅读过的一些书籍，大多数都是一些比较经典的书籍。随着技术的发展，其中一些仍然适合阅读，但另外一些可能就显得有些过时。这里根据本人的阅读体会，给出书籍的阅读建议，希望帮助大家排坑，避免花费不必要的时间和精力；比较推荐的书籍名称会加粗处理。</p><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="C-部分"><a href="#C-部分" class="headerlink" title="C++ 部分"></a>C++ 部分</h3><table><thead><tr><th align="center">书籍名称</th><th align="center">简要描述</th><th align="center">建议</th></tr></thead><tbody><tr><td align="center"><strong>C++ Primer</strong></td><td align="center">C++ 初学必看书籍，重量级作品</td><td align="center">纸质书阅读</td></tr><tr><td align="center">Effective C++</td><td align="center">C++ 语言中的一些 trick</td><td align="center">不建议买书，一些内容比较老旧，可以在网络查阅电子书</td></tr><tr><td align="center">More Effective C++</td><td align="center">C++ 语言中的一些 trick</td><td align="center">不建议买书，一些内容比较老旧，可以在网络查阅电子书</td></tr><tr><td align="center"><strong>C++ 并发编程实践</strong></td><td align="center">C++ 多线程编程必看书籍，重量级作品</td><td align="center">必读，并发编程的基础，部分内容较难可以跳过</td></tr><tr><td align="center"><strong>Linux 多线程服务端编程</strong></td><td align="center">C++ 网络编程，Reactor 模式</td><td align="center">需要上手仿写 muduo 网络库，C++网络必学</td></tr><tr><td align="center"><strong>Redis 设计与实现</strong></td><td align="center">数据结构、网络</td><td align="center">redis 的数据结构以及架构还是值得学习的</td></tr></tbody></table><h3 id="Glang-部分"><a href="#Glang-部分" class="headerlink" title="Glang 部分"></a>Glang 部分</h3><table><thead><tr><th align="center">书籍名称</th><th align="center">简要描述</th><th align="center">建议</th></tr></thead><tbody><tr><td align="center"><strong>Go 语言圣经</strong></td><td align="center">Golang 入门</td><td align="center">Golang 入门的选择之一</td></tr><tr><td align="center">Go 语言编程之旅</td><td align="center">Golang 项目：博客、grpc、进程内缓存等</td><td align="center">不建议买书，网络上有内容可以跟做，内容深度不够，章节顺序对初学者来说难以理解</td></tr><tr><td align="center">Docker 源码分析</td><td align="center">Docker 源码以及架构介绍</td><td align="center">不建议，内容非常浅显，只介绍了几个模块，对理解 Docker、Golang 帮助都不大</td></tr></tbody></table><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><table><thead><tr><th align="center">书籍名称</th><th align="center">简要描述</th><th align="center">建议</th></tr></thead><tbody><tr><td align="center"><strong>Redis 设计与实现</strong></td><td align="center">redis 全面剖析</td><td align="center">redis 经典书籍，但缺少 redis 新版本内容</td></tr><tr><td align="center">Redis深度历险：核心原理和应用实践</td><td align="center">redis 应用及原理</td><td align="center">一般，内容比较全面，但介绍不深入，可以作为学习大纲</td></tr><tr><td align="center">深入分布式缓存 从原理到实践</td><td align="center">缓存类应用综述</td><td align="center">redis 部分比较简略</td></tr></tbody></table><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><table><thead><tr><th align="center">书籍名称</th><th align="center">简要描述</th><th align="center">建议</th></tr></thead><tbody><tr><td align="center"><strong>MySQL 必知必会</strong></td><td align="center">MySQL 入门书籍</td><td align="center">入门之选，可以搭配牛客网题目练习</td></tr><tr><td align="center"><strong>MySQL 技术内幕：InnoDB 存储引擎</strong></td><td align="center">MySQL 架构与原理剖析</td><td align="center">非常全面地介绍了 InnoDB 中的一些特性和读写优化，进阶必读，但缺少比较新的特性</td></tr><tr><td align="center">SQL 学习指南</td><td align="center">SQL 入门书籍</td><td align="center">加强版的 MySQL 必知必会</td></tr><tr><td align="center"><strong>SQL 经典实例</strong></td><td align="center">SQL 经典场景</td><td align="center">搭配 Leetcode 题库一起学习</td></tr></tbody></table><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>MongoDB 中应用了一些较新的技术优化点，非常值得学习。</p><p>MongoDB 的书籍还是比较少的，并且由于 MongoDB 早期使用的是 MMAP 引擎而非 WiredTiger，有一些学习资料中的内容已经不适用了。MongoDB 最好的学习方式还是网络博客，例如 MongoDB 官方博客、知乎、腾讯云、阿里云的栏目中都有一些很好的文章。</p><table><thead><tr><th align="center">书籍名称</th><th align="center">简要描述</th><th align="center">建议</th></tr></thead><tbody><tr><td align="center">MongoDB 权威指南</td><td align="center">MongoDB 一本通</td><td align="center">PDF，可以经常查阅</td></tr><tr><td align="center"><strong>MongoDB 核心原理与实践</strong></td><td align="center">对 MongoDB 架构和原理比较深入的一本书</td><td align="center">书中讲述了一些原理，但不够深入，可以搭配网络上的博客一起学习</td></tr></tbody></table><h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><p>etcd 作为 Golang 经典项目，书籍也是比较少的，更多的还是从网络博客上学习。</p><table><thead><tr><th align="center">书籍名称</th><th align="center">简要描述</th><th align="center">建议</th></tr></thead><tbody><tr><td align="center"><strong>etcd 工作笔记：架构分析、优化与最佳实践</strong></td><td align="center">etcd 架构、原理剖析</td><td align="center">etcd 中比较好的书籍，建议阅读，但书比较老，与新版本 etcd 有一定出入，注意甄别</td></tr><tr><td align="center">云原生分布式存储基石：etcd深入解析</td><td align="center">更加综合的，但深度一般</td><td align="center">在 etcd 工作笔记之中选择一本即可</td></tr></tbody></table><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><table><thead><tr><th align="center">书籍名称</th><th align="center">简要描述</th><th align="center">建议</th></tr></thead><tbody><tr><td align="center"><strong>Unix 网络编程 1 ( UNP )</strong></td><td align="center">unix 网络编程</td><td align="center">必读书籍，重点在前几章</td></tr><tr><td align="center">Unix 网络编程 2：进程间通信</td><td align="center">unix 进程通信</td><td align="center">不建议阅读，进程通信还是用 socket 比较多，可以看看信号部分的内容</td></tr><tr><td align="center">计算机网络自顶向下方法</td><td align="center">计算机网络概念</td><td align="center">不清楚计算机网络概念可以读</td></tr><tr><td align="center">图解 HTTP</td><td align="center">HTTP 介绍</td><td align="center">基于 HTTP1.1，初学 HTTP 可以读</td></tr><tr><td align="center">Wireshark 数据包分析实战</td><td align="center">抓包分析</td><td align="center">抓包实战时可以查阅</td></tr></tbody></table><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><table><thead><tr><th align="center">书籍名称</th><th align="center">简要描述</th><th align="center">建议</th></tr></thead><tbody><tr><td align="center">深入分布式缓存 从原理到实践</td><td align="center">未看完</td><td align="center"></td></tr><tr><td align="center"><strong>分布式系统模式</strong></td><td align="center">分布式系统各原理和基础概念介绍</td><td align="center">可以比较全面地学习分布式系统</td></tr></tbody></table><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><table><thead><tr><th align="center">书籍名称</th><th align="center">简要描述</th><th align="center">建议</th></tr></thead><tbody><tr><td align="center">Linux 内核设计与实现</td><td align="center">Linux 内核入门级别</td><td align="center">内容比较全面，根据需要阅读</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
