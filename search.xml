<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux网络部分</title>
      <link href="/2023/01/16/linux%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/"/>
      <url>/2023/01/16/linux%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>之前学习了很多与计算机网络相关的内容，虽然建立起了比较系统的概念，但是这些概念仅仅停留在模型上；而操作系统中究竟是如何对各种协议进行处理的仍然不是特别清楚。</p><h2 id="linux-内核网络模型"><a href="#linux-内核网络模型" class="headerlink" title="linux 内核网络模型"></a>linux 内核网络模型</h2><p>从功能上，linux 内核可以划分为五个部分，分别是：</p><ul><li>进程管理：主要负责 CPU 的访问，进行 CPU 调度；</li><li>内存管理：主要负责控制内存的访问；</li><li>文件系统：主要负责组织文件系统，实现文件操作；</li><li>设备管理：主要负责控制外部设备；</li><li>网络：主要负责管理网络设备，实现网络协议栈。</li></ul><p>linux 内核的网络部分主要具备两个功能：管理网络设备、实现网络协议栈。管理网络设备对应五层协议中的物理层和数据链路层；实现网络协议栈对应五层协议中的网络层和运输层。在 linux 的网络实现体系中，linux 为了抽象与实现相分离，将内核中的网络部分划分为五个层次：</p><ul><li>系统调用接口：用户空间的访问接口，提供网络功能的统一封装。</li><li>协议无关接口：使用 socket 来实现对网络通信的抽象化，实现 TCP 和 UDP 的统一封装。</li><li>网络协议栈：linux 中各种网络协议的具体实现，处理各种网络协议的逻辑。</li><li>设备无关接口：为网络协议栈提供操作物理设备的统一封装。</li><li>设备驱动程序：负责管理物理网络设备的驱动程序。</li></ul><p><img src="/images/linux-network.png" alt="/images/linux-network.png"></p><p>其中，网络协议栈部分包括数据链路层、网络层、传输层。除南北通信外，linux 内核还提供了东西向通信。在协议栈的数据链路层，linux 提供了 bridge hook，用户可以将同一主机上的不同网卡相互桥接，实现在数据链路层的消息转发。在协议栈的网络层，linux 提供了 route 接口，用于实现 ip 包在不同 host ip 之间的传递。</p><p><img src="/images/linux-stack.png" alt="/images/linux-stack.png"></p><p>虽然一台物理主机上可能会有多个网络设备，但是这些网络设备会共用同一个协议。如果想要使主机上的部分进程不与其他进程共享协议栈，那么就必须借助虚拟化技术来实现网络隔离，如虚拟机技术，虚拟容器技术。这些虚拟技术通常是使用虚拟网卡来实现的。</p><h2 id="重要数据结构"><a href="#重要数据结构" class="headerlink" title="重要数据结构"></a>重要数据结构</h2><p>linux 网络部分中最为重要的数据结构有两个抽象<code>net_device</code>、<code>socket</code>和一个缓冲<code>sk_buff</code>。</p><h3 id="net-device"><a href="#net-device" class="headerlink" title="net_device"></a>net_device</h3><p><code>net_device</code>是所有网络设备的抽象描述，为上层协议栈提供统一的接口，主要两个方面的内容：</p><ul><li>网络设备硬件属性：端口地址、驱动函数、中断函数等；</li><li>网络设备配置信息：ip 地址、子网掩码等。</li></ul><p>这一抽象数据结构实现了协议栈和网络设备的隔离，从而使得虚拟网络设备的实现成为可能。</p><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p><code>socket</code> 是对所有传输层协议的抽象，统一了网络 IO 与文件 IO 操作，它主要实现了应用层与系统协议栈的接口统一、网络与文件访问方式的统一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">socket_statestate;</span><br><span class="line"></span><br><span class="line">kmemcheck_bitfield_begin(type);</span><br><span class="line"><span class="type">short</span>type;</span><br><span class="line">kmemcheck_bitfield_end(type);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span> __<span class="title">rcu</span>*<span class="title">wq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>*<span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span>*<span class="title">sk</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span>*<span class="title">ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建 <code>struct socket</code> 的函数 <code>socket(3)</code>不仅仅可以创建常规的 TCP、UDP 套接字，还可以通过控制协议族来创建 ICMP、甚至 ARP 套接字。经过 socket 的统一封装，这些位于不同层次的协议使用相同的接口被用户调用，向用户隐藏了底层系统的复杂度。<code>struct socket</code>的读写同样是使用了统一的接口来封装收发数据，不同的协议会使用不同的函数写入，也就是每一种 <code>struct socket</code> 最终调用的读写函数是不一样的，如 ICMP 协议在写入时使用的是<code>icmp_send</code>，因此不会经过传输层，而是直接从网络层向下进行网络通信流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 IMCP 套接字，SOCK_RAW 表明为原始网络协议</span></span><br><span class="line"><span class="type">int</span> icmp_fd = ::socket(AF_INET,SOCK_RAW,IPPROTO_ICMP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 ARP 套接字，SOCK_PACKET 表明为链路层协议</span></span><br><span class="line"><span class="type">int</span> arp_df = :: socket(AF_PACKET,SOCK_PACKET,htons(ETH_P_ARP));</span><br></pre></td></tr></table></figure><h3 id="sk-buff"><a href="#sk-buff" class="headerlink" title="sk_buff"></a>sk_buff</h3><p><code>sk_buff</code>结构体作用域整个数据包的处理，它承载着网络包的内容。<code>sk_buff</code>结构体的定义比较长，<a href="https://elixir.bootlin.com/linux/v4.4/source/include/linux/skbuff.h#L476">源码</a>不贴出。主要包括以下几个方面的内容：</p><ul><li>用于实现 <code>sk_buff</code>的双向链表的结构；</li><li>数据的各种指针：head、tail、data、end、user_data；</li><li>长度标识：len、head room、tail room；</li><li>协议报头：各网络协议层的报头；</li><li><code>sock*</code>和<code>dev*</code>：指向对应的 sock 结构体，对应的网络设备；</li><li>控制缓存 <code>char cb[40]</code>：避免每层协议都分配内存，用于每一层临时存储信息；</li></ul><p>linux 中，无论是写入还是读取网络包，都需要借助 <code>sk_buff</code>。在初始化阶段，数据并不会写入缓冲区的首部，而是会预留出一段空间，用于报文头的写入。在解析/生成报文的过程中，<code>sk_buff</code>中的 data 会不断移动，指向下一层级报文的开始位置。为了避免每一个层级额外分配内存，每一个<code>sk_buff</code>内部都预留了 40 字节大小的控制缓存，存储临时信息。这种设计能够在报文的解析和生成过程中避免频繁分配内存，大大降低了内存拷贝的需要。</p><p>更加详细的内容可以参考<a href="https://www.cnblogs.com/tzh36/p/5424564.html">博客文章</a>。</p><h2 id="网络包的读取流程"><a href="#网络包的读取流程" class="headerlink" title="网络包的读取流程"></a>网络包的读取流程</h2><p>本章会从读取网络包的视角来分析 linux 网络部分的各个层级的主要工作，以及操作系统预留的一些 hook 可以用于实现的技术。</p><h3 id="网络设备硬中断"><a href="#网络设备硬中断" class="headerlink" title="网络设备硬中断"></a>网络设备硬中断</h3><p>数据帧被网卡接收前，会先检查数据的完整性，对错误数据包直接丢弃。</p><p>网卡内部具有一段内存区域，该内存区域是以 FIFO 形式来访问的，是网卡和驱动程序的共享内存。但是网卡内部是采用直接寻址的方式，并没有使用虚拟内存映射的方法来访问。当网卡中有数据帧到达时，网卡设备会将数据帧内容拷贝到该内存区域，然后向 CPU 发起一个硬中断，通知 CPU 有数据到达。</p><p>CPU 收到硬中断后，会在 skb 缓冲区分配一个 skb 数据结构，然后从网卡中将数据拷贝到 skb 中（因为网卡中的内存区域很小，很容易被占满），更新网卡状态；从数据帧中提出协议等信息，写入 skb 结构体中，然后向操作系统发出一个软中断。<strong>如果网卡的 FIFO 缓冲区或者 OS 中为网卡开辟的缓冲区被占满，那么数据包就会被直接丢弃，这是丢包的原因之一。</strong></p><h3 id="软中断处理入口"><a href="#软中断处理入口" class="headerlink" title="软中断处理入口"></a>软中断处理入口</h3><p>相较于网络设备硬中断，软中断处理是一个很长的流程，它会负责处理 OS 内存中已经到达的网络数据，并最终将其送入到对应的协议栈位置。</p><p>软中断处理会被调度到硬中断发生的 CPU 上，处理逻辑的入口函数是 <code>net_rx_action</code>。该函数的主要逻辑是遍历系统中的网卡设备，执行被网卡驱动注册的 poll 函数。为了限制单次软中断的运行时间，<code>net_rx_action</code>每次运行时都会被设置一个配额和一个截止时间，当完成配额数量或者超时后，即使没有完成所有的事件，函数也会退出，并等待被下一次中断唤醒。</p><p>另一个比较重要的函数是 <code>netif_receive_skb</code>，该函数是 skb 结构体的分发器，负责根据 skb 结构体的信息将其分发到对应的协议栈上，进行不同的处理。值得一提的是，虽然网络层协议目前很少，但为了考虑拓展性，函数中并没有使用分支的方式判断，而是使用了哈希表来进行查询的。<code>netif_receive_skb</code>同样也是<strong>抓包程序、数据链路层桥接等功能的入口。</strong>在提交至上层协议栈前，会首先根据抓包程序设置的过滤器，将符合条件的数据包复制。如 wireshark 中的 capture filter，就直接对应这一过程，如果不对其进行设置，可能会导致系统的性能下降。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pcap逻辑，这里会将数据送入抓包点。</span></span><br><span class="line">list_for_each_entry_rcu(ptype, &amp;ptype_all, <span class="built_in">list</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pt_prev)</span><br><span class="line">      ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">    pt_prev = ptype;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据链路层桥则是虚拟网卡 TAP 的基础，可以在数据链路层将数据包转发给其他虚拟网卡设备，该技术是基于 hook 函数 <code>netif_receive_skb</code> 的。该函数会调用 rx_handler 来实现不同的功能，每一块宿主网卡都只能注册一个 rx_handler，但是网卡和网卡可以使用链路的方式来注册，从而实现一个宿主网卡上挂载多个虚拟网卡。</p><p>linux tc 是在此阶段被处理的，其中<code>__netif_receive_skb_core</code>处理 tc ingress，<code>dev_xmit</code>处理 tc egress。</p><h3 id="网络层处理"><a href="#网络层处理" class="headerlink" title="网络层处理"></a>网络层处理</h3><p>网络层处理主要会对各种协议进行解析和处理，这一阶段的输入是经过解析后的网络层包。不同协议的包入口函数名为 prococolname_rcv，结束函数为 prococolname_rcv_finish。这一层主要进行路由、NAT、防火墙等操作。</p><h4 id="ip-协议"><a href="#ip-协议" class="headerlink" title="ip 协议"></a>ip 协议</h4><p>ip 网络层的入口为<code>ip_rcv</code>，在这一函数中会对包进行检查，如果该 ip 包经过了分割，会首先将多个分片组装。在完成这些预处理工作后，ip 包会经过路由和 netfilter 的处理流程。可见，netfilter 这种内核防火墙并不会对数据包产生复制，利用其来做网络转发性能会远高于 nginx 等应用层代理。具体的处理流程如下图所示：</p><p><img src="/images/697113-20160228211438679-329472687.jpg" alt="img"></p><p>不难看到，ip 协议的处理流程和 iptables 的四链处理流程是一致的。</p><h4 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h4><p>除了 IP 协议，网络层处理还有 ARP 协议、ICMP 协议等，如果这些协议到达网络层后没有更高层次的协议，那么处理就会结束。以 ICMP 协议为例，数据包在到达网络层后会直接在内核态中被处理，不会再进行传递。linux 内核中处理 ICMP 应答的函数是 <code>icmp_rcv()</code>，<a href="https://elixir.bootlin.com/linux/v4.4/source/net/ipv4/icmp.c#L975">源码</a>有 100 行左右，但核心功能比较简单，其主要步骤用文字表述后如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">icmp_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 检验 ICMP 包有效性</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 ICMP 报文类型</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 ICMP 报文消息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 ICMP 报文类型，选择处理函数，应答处理均在内核态运行</span></span><br><span class="line">  success = icmp_pointers[icmph-&gt;type].handler(skb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 结束本次网络包读取</span></span><br><span class="line">  <span class="keyword">if</span> (success)  &#123;</span><br><span class="line">    consume_skb(skb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，函数中会根据报文类型来选择合适的处理函数，处理函数会根据当前系统协议栈的状态来处理 ICMP 请求。即ICMP 的应答报文会在内核态生成，因此 ICMP 报文的读取在网络层就会结束。</p><h3 id="传输层处理"><a href="#传输层处理" class="headerlink" title="传输层处理"></a>传输层处理</h3><p>接收数据包时，传输层处理的主要流程为：解析报文包——( 报文包进入接收队列 )——处理应答。当数据包为用户进程所需时，需要将其加入接收队列，<strong>如果接收队列已满，同样也会导致数据包被丢弃</strong>。</p><h4 id="TCP-部分"><a href="#TCP-部分" class="headerlink" title="TCP 部分"></a>TCP 部分</h4><p>为了控制和管理每个连接，linux 内核中有使用了 TCP_SKB_CB 数据结构来描述 TCP control block，简称 TCB，用于存储单个 tcp 连接的状态。所有的 TCB 以表的形式组织起来，方便查询和修改。TCB 结构只会在 TCP 发送/写入数据、建立/关闭连接时被修改。TCB 主要记录以下部分的内容，<a href="https://elixir.bootlin.com/linux/v4.4/source/include/net/tcp.h#L738">源码</a>较长，这里不贴出：</p><ul><li>连接四元组：TCP 双方 ip、port；</li><li>TCP 状态：SEQ，ACK，连接状态，SACK/FACK 重传等信息；</li><li>进程号：开启 tcp 连接的进程。</li></ul><p>TCP 的所有收发操作都会依据 TCB 的状态来进行调节，而孤儿 socket、RST 包等一些功能也都是基于 TCB 来完成的。如果 ip 层解析后的 tcp 包能够匹配具体的 process，那么就会处理该消息并将内容封装为 tcp_data ，放入 tcp_data 队列中，然后通过 <code>tcp_read</code> 接口来注册 poll、epoll 事件，通知被阻塞的进程。具体的处理流程如下图：</p><p><img src="/images/697113-20160228211142163-1933891846.jpg" alt="697113-20160228211142163-1933891846"></p><p>TCP 中接受消息的处理路径有两条： fast path和 slow path。slow path 是当前 tcp 连接出现异常状况的处理策略，相比 fast path，它需要额外处理紧急指针、乱序数据。tcp 协议栈会使用预测标志的方法来决定使用哪种策略，当满足以下条件时，会使用 fast path：</p><ul><li>无乱序数据和紧急数据</li><li>接收窗口不为 0</li><li>接收缓冲区未耗尽</li></ul><p>当<code>connect</code>系统调用结束、收到第三次握手中 ACK时，tcp 会立刻使用 fast path；当 tcp 从异常中恢复、更新窗口后、可接收缓冲区大小变化时，都会尝试开启 fast path。</p><h4 id="UDP-部分"><a href="#UDP-部分" class="headerlink" title="UDP 部分"></a>UDP 部分</h4><p>由于 UDP 是一个无状态协议，相比于 TCP 协议的处理流程，UDP 协议的处理更加简单。linux 协议栈不需要为 UDP 维护状态机模型，只需要解析包后通知用户进程即可。</p><h2 id="网络包的写入流程"><a href="#网络包的写入流程" class="headerlink" title="网络包的写入流程"></a>网络包的写入流程</h2><p>上一章已经讲述了 linux 网络部分的各个模块内容，本章主要讲述的是写入流程中比较特殊的部分。具体的 write flow 则不再阐述。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>TCP 包发送时必须考虑到丢包的情况，因此需要设立重传机制。linux 内核中为每一个 tcp 连接设置了一个以双向链表形式组织的重传队列，在收到对方的 ACK 前，tcp 包都会被保存在队列中。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层中的写入流程有一个点比较特殊，那就是 IP 包在进行封装时需要使用 ARP 协议来获取 MAC 地址。由于这一步骤需要使用目标 IP 作为输入，破坏了下层协议不依赖上层协议数据的原则，所以才会产生 ARP 协议层次的争议。在 OSI 模型中，将 ARP 定义为数据链路层协议；而在 TCP/IP 模型中则将其定义为网络层协议。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>所有的网络包在数据链路层都会通过<code>dev_queue_xmit</code>进入等待队列，操作系统会定期调用<code>xmit_one</code>函数来发送一个或多个数据包至网络设备，每一个网络设备都具有一个等待队列。该等待队列也是一个 hook，可以由用户进行调控。linux 中系统命令 tc(traffic control) 就是利用该 hook 来实现的。默认情况下，该等待队列是一个 FIFO 队列，用户也可以通过配置来实现更加复杂的功能。</p><p><img src="/images/dev_queue.png" alt="/images/dev_quue.png"></p><p>linux 内核在进行入队和出队操作时，使用了两个函数指针，实现了队列的抽象化。在 linux tc 实现中，允许一个抽象队列以树状组织，形成一个队列树。队列树的根节点和非叶子结点是抽象队列基类，不具备任何队列功能，但是具有两个过滤器，用于入队和出队的选择与过滤功能。每一个叶子结点都会维护一个队列实例，可以是 FIFO 队列、随机队列、优先级队列等中的一种。当链路层包需要入队时，会从根节点以入队过滤器指定的策略对链路层包进行分流，最终经过策略选择入队到某一个叶子结点的队列中。当需要出队时，则会根据过滤选择器中设置的优先级选择一个或多个链路层出队。</p><p>默认情况下， 抽象队列中根节点过滤器不设置任何规则，等待队列只设置了一个 FIFO 队列，即不实现任何功能。tc 命令中的队列规程，类别，过滤器其实就分别对应了等待队列实例，等待队列实例的类别，过滤器规则。</p><h2 id="虚拟网络设备"><a href="#虚拟网络设备" class="headerlink" title="虚拟网络设备"></a>虚拟网络设备</h2><p>linux 中许多种类的虚拟网络设备，常见的有 IFB、TUN/TAP、VETH 等，他们都是通过统一的 <code>netif_receive_skb</code> hook 函数来实现的。所有的虚拟网络设备都工作在数据链路层，可以选择与主机共享协议栈，或者选择使用虚拟技术实现新的协议栈。</p><h3 id="Loopback-Interface"><a href="#Loopback-Interface" class="headerlink" title="Loopback Interface"></a>Loopback Interface</h3><p>Loopback Interface 是一个特殊的虚拟网卡，一般作为 lo 网卡挂载在 ip 127.0.0.1上。Loopback Interface 同样工作在数据链路层，发送到虚拟网卡的数据需要先经过传输层和网络层。网卡的 ip 输出函数会直接串联到 ip 输入函数中，中间没有任何缓存。</p><h3 id="IFB"><a href="#IFB" class="headerlink" title="IFB"></a>IFB</h3><p>IFB（中介功能块设备）是IMQ（中介队列设备）的继任者，也是最简单的虚拟网卡，它以 bridge 的形式与其他网卡连接在一起，它不改变数据包的流向。IFB 网卡的设计初衷是为了拓展 linux tc 的功能。</p><p>使用方法可以参考<a href="https://blog.csdn.net/dog250/article/details/40680765">博客</a>。</p><h3 id="TUN-TAP"><a href="#TUN-TAP" class="headerlink" title="TUN/TAP"></a>TUN/TAP</h3><p>TAP/TUN是Linux内核实现的一对虚拟网络设备，TAP工作在二层，TUN工作在三层，Linux内核通过TAP/TUN设备向绑定该设备的用户空间程序发送数据，反之，用户空间程序也可以像操作硬件网络设备那样，通过TAP/TUN设备发送数据。</p><h3 id="VETH"><a href="#VETH" class="headerlink" title="VETH"></a>VETH</h3><p>VETH 网卡是成对出现的，一对 VETH 网卡可以使用两套不同的协议栈，通常用于网络协议栈的隔离。VETH 网卡可以与物理网卡或其他虚拟网卡进行桥接，通过路由规则就可以实现网路的隔离。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 编译相关内容的记录</title>
      <link href="/2023/01/14/go-%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/01/14/go-%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>本文记录学习到的一些与 go 语言编译相关的内容。</p><h2 id="编译速度"><a href="#编译速度" class="headerlink" title="编译速度"></a>编译速度</h2><p>go 是编译速度比较快的语言之一，主要有以下几个原因，<a href="https://qastack.cn/programming/2976630/how-does-go-compile-so-quickly">参考链接</a>：</p><ul><li>语法较为简单，不允许重载，不需要复杂的语义分析</li><li>使用包管理，而非头文件形式，避免了解析头文件</li><li>不使用虚拟机，编译时不需要加载 VM</li><li>大部分包都使用静态链接的方式</li><li>优化器更为简单，编译期优化较少，同时导致性能一定程度上下降，<a href="https://zhuanlan.zhihu.com/p/550270332">参考链接</a></li></ul><h2 id="编译缓存"><a href="#编译缓存" class="headerlink" title="编译缓存"></a>编译缓存</h2><p>在 C/C++ 中，大型项目的构建往往需要依赖 make 和 CMake 工具来提供编译缓存，以实现增量编译的功能。在 golang 中，从 1.10  版本后编译器支持了编译缓存的功能，可以进行增量构建。编译过程中的缓存文件将会被存放在环境路径 GOCACHE 下。此外，go test 也支持在特定条件下缓存 test 结果，从而加快执行测试的速度。</p><h3 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h3><p><strong>go 语言的增量编译是以 package 为单位的</strong>，一个 package 内任意一个文件的变更都会导致整个 package 以及依赖该 package 的所有 package重新编译 。但是，golang 的文件修改判别依据相比 C/C++ 体系更加合理。在 qt5 中，使用 qmake 进行增量编译时，依赖于文件的修改时间戳，如果只是对文件进行了格式调整，也会导致项目重新编译。而在 golang 中，文件修改的判别依据是文件内容是否改变，<strong>只修改文件的行数、增加注释、删除后恢复内容都不会导致package 重新编译</strong>。</p><p>在 GOCACHE 路径下，执行 tree 命令，可以得到如下输出（截取部分）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go-build % tree</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">├── 00</span><br><span class="line">│   ├── 000d954e953e73d70b0fa00ceaf3c68f3adbb5164e5381754493a4e592ad714f-a</span><br><span class="line">│   └── 0068e9620015a00b938707781ad8b56fdd86fe4a09eeb7802d874bd041f5ad79-a</span><br><span class="line">├── 01</span><br><span class="line">│   ├── 0107518e42b66ffb35a353ffd437cb2a6f448b07ad8fceba401e7bc1692c17e3-d</span><br><span class="line">│   ├── 01126d3106b1aee39e975dcd10a2ac64f170d28ca14b37c8c5e7cec7817e60fd-a</span><br><span class="line">...</span><br><span class="line">└── trim.txt</span><br></pre></td></tr></table></figure><p>可以看到，golang 中使用了内容摘要算法来组织存储，每一个目录下存储的文件名前两位字符都对应着文件夹名称。在编译过程中，go 编译器会将编译后 package 的 .a 文件求取 64 位摘要值，并将其名称命名为”摘要值-a” 的形式，并存储在摘要值前两位对应的文件夹下。</p><h3 id="go-test-缓存"><a href="#go-test-缓存" class="headerlink" title="go test 缓存"></a>go test 缓存</h3><p>在go 1.10中，go test 同样可以被缓存介入，不过需要满足一定的条件，go release note 中给出了缓存介入条件：</p><ul><li>本次测试的执行程序以及命令行（及参数）与之前的一次test运行匹配；</li><li>上次测试执行时的文件和环境变量在本次没有发生变化；</li><li>测试结果是成功的；</li><li>以package list mode运行测试；</li><li>go test的命令行参数使用”-cpu, -list, -parallel, -run, -short和 -v”的一个子集时。</li></ul><p>其中 package list mode 是指运行某个 package 的测试程序，而不是以当前目录为参数。</p><h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>go build 工具链是支持交叉编译的，在不直接调用 C 代码的情况下，可以直接使用 go build 命令来完成交叉编译。在使用交叉编译时，需要通过变更 GO ENV 来控制编译输出。常用的环境变量如下：</p><ul><li>CGO_ENABLE：关闭 CGO 选项，需要关闭，因为交叉编译不支持 CGO；</li><li>GOOS：编译的目标操作系统，如 linux、darwin、windows；</li><li>GOARCH：编译的架构，如 386、amd64、arm。</li></ul><p>交叉编译示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">x86_64 linux</span></span><br><span class="line">CGO_ENABLED=0 </span><br><span class="line">GOOS=linux </span><br><span class="line">GOARCH=amd64 </span><br><span class="line">go build main.go</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">x86_64 Windows</span></span><br><span class="line">CGO_ENABLED=0</span><br><span class="line">GOOS=windows </span><br><span class="line">GOARCH=amd64 </span><br><span class="line">go build main.go</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arm Macos</span></span><br><span class="line">CGO_ENABLED=0 </span><br><span class="line">GOOS=darwin </span><br><span class="line">GOARCH=arm </span><br><span class="line">go build main.go</span><br></pre></td></tr></table></figure><p>如果在项目中依赖了 C 代码，则不能够使用 go build 工具来实现交叉编译，需要要借助第三方工具 xgo。</p><h2 id="编译期赋值"><a href="#编译期赋值" class="headerlink" title="编译期赋值"></a>编译期赋值</h2><p>go 语言可以实现在编译时对变量赋值，以完成在代码中增加版本等信息。该功能需要借助 -ldflags 选项。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">  <span class="keyword">var</span> version = <span class="string">&quot;v0.0.0&quot;</span></span><br><span class="line">  buildTime <span class="type">string</span></span><br><span class="line">  buildVersion <span class="type">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>直接使用 -ldflags 选项即可，不需要再借助 flag parse。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go build -ldflags \ </span><br><span class="line">&quot;-X main.version=v0.0.1 -X main.dateTime=`date +%Y-%m-%d,%H:%M:%S` -X main.gitTag=`git tag`&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出值</span></span><br><span class="line">version is: v0.0.1</span><br><span class="line">dateTime is: 2023-01-14,22:18:54</span><br><span class="line">gitTag is: v0.0.0-beta</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是通过将值写入符号表来完成的，符号表用来存储程序中的标识符（即常量和变量的类型、值等相关数据）。go 语言编译期过程可以简化理解为：在编译期将部分的变量的值修改，相当于改变了变量的默认值。</p><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>go 语言中不支持 define，但是可以依赖<code>build tags</code>或文件后缀的方式来实现不同平台的条件编译。</p><h3 id="build-tags"><a href="#build-tags" class="headerlink" title="build tags"></a>build tags</h3><p>build tags 是一种特殊的注释，它必须位于 package 声明的上方，并且后跟一个空行。当一个包被编译时，编译器会根据构建标签的内容来判断该包是否需要编译。</p><p>build tags 可以指定以下内容：</p><ul><li>操作系统，环境变量中<code>GOOS</code>的值；</li><li>操作系统的架构，环境变量中<code>GOARCH</code>的值；</li><li>使用的编译器，<code>gc</code>或者<code>gccgo</code>；</li><li>是否开启CGO，<code>cgo</code>；</li><li>golang版本号， 如<code>go1.1</code>；</li><li>其它自定义标签，通过<code>go build -tags</code>指定的值。</li></ul><p>以下为 build tags 的一个例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build linux darwin</span></span><br><span class="line"><span class="comment">// +build x86</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> os</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>build tags 需要遵循以下原则：</p><ul><li>每一行注释以<code>+build</code>开始；</li><li>每个选项由数字和字母组成，如果开头为<code>!</code>代表反义；</li><li>选项之间相隔<code>&#39; &#39;</code>代表或关系，选项之间相隔<code>,</code>代表与关系；</li><li>不同行注释代表与关系</li></ul><p>上面示例中代表在 linux 或 darwin 平台且架构为 x86 的情况下才会编译。</p><h3 id="文件名后缀"><a href="#文件名后缀" class="headerlink" title="文件名后缀"></a>文件名后缀</h3><p>类似测试文件的 <code>_test</code>后缀，go 语言中也可以通过添加后缀的方式来实现条件编译。文件名后缀的命名方式为：<code>filename(_$GOOS)(_$GOARCH).go</code>。其中 GOOS 如果出现，必须排列在 GOARCH 前面。</p><p>文件名后缀只能够实现在特定条件下进行编译，而不能实现在特定条件下取消编译。</p><h2 id="Go-Plugin"><a href="#Go-Plugin" class="headerlink" title="Go Plugin"></a>Go Plugin</h2><p>参考<a href="https://www.easemob.com/news/6987">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kfifo 优雅的无锁队列实现</title>
      <link href="/2023/01/13/kfifo-%E4%BC%98%E9%9B%85%E7%9A%84%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/01/13/kfifo-%E4%BC%98%E9%9B%85%E7%9A%84%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>kfifo 是 linux kernel 中一个简介优雅的无锁 ring_buffer 实现，能够保证在单线程写入和读线程读取场景下的线程安全。kfifo 的实现中使用了许多比较特殊的操作，值得进行学习。</p><h2 id="kfifo-数据结构"><a href="#kfifo-数据结构" class="headerlink" title="kfifo 数据结构"></a>kfifo 数据结构</h2><p>kfifo 的数据结构非常简单，只有缓冲区指针及大小、读取写入偏移量，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> &#123;</span></span><br><span class="line">  <span class="comment">// 写入 offeset</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>in;</span><br><span class="line">  <span class="comment">// 读取 offset</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>out;</span><br><span class="line">  <span class="comment">// 缓冲区大小</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>size;</span><br><span class="line">  <span class="comment">// 缓冲区指针</span></span><br><span class="line">  <span class="type">void</span>*buffer;</span><br><span class="line">  <span class="comment">// 自旋锁，新版本已经移出</span></span><br><span class="line">  <span class="type">spinlock_t</span> *lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>kfifo 实现巧妙之处主要有三点：</p><ul><li>通过位运算判断 2 的幂以及向上取整为 2 的幂；</li><li>不进行模运算，而是利用溢出来实现读写偏移量计算；</li><li>使用内存屏障来保障单消费者、单生产者的无锁并发访问。</li></ul><h2 id="位运算部分"><a href="#位运算部分" class="headerlink" title="位运算部分"></a>位运算部分</h2><p>kfifo struct 中，要求缓冲区大小必须为 2 的幂，这是为了更加高效地判断计算出当前偏移量对应的内存位置。在 kfifo 初始化阶段，通过两个巧妙的位运算解决了判断 2 的幂以及向上取整为 2 的幂两个问题。</p><h3 id="判断一个数是否为-2-的幂"><a href="#判断一个数是否为-2-的幂" class="headerlink" title="判断一个数是否为 2 的幂"></a>判断一个数是否为 2 的幂</h3><p>在二进制存储中，如果一个数 n 是 2 的幂，那么这个数可以表示为 100···，除最高位外全部为 0。同样地，n-1 就可以表示为 0111…，除最高位外全部为 1。可以观察到 n 和 n-1 在二进制中，每一位都是相反的，因此 <code>n &amp; (n - 1) == 1</code>。可以根据这种操作来利用位运算更快地判断一个数是否为 2 的幂。linux kernel 中的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">is_power_of_2</span><span class="params">(<span class="type">uint32_t</span> n)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (n != <span class="number">0</span> &amp;&amp; ((n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将一个数取整为-2-的幂"><a href="#将一个数取整为-2-的幂" class="headerlink" title="将一个数取整为 2 的幂"></a>将一个数取整为 2 的幂</h3><p>linux kernel 中的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求大于一个数的 2 的幂次数</span></span><br><span class="line"><span class="type">static</span> __inline__ <span class="type">int</span> <span class="title function_">generic_fls</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">  <span class="type">int</span> r = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 x 是否为 0</span></span><br><span class="line">  <span class="keyword">if</span> (!x)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 判断最高八位是否有 1</span></span><br><span class="line">  <span class="keyword">if</span> (!(x &amp; <span class="number">0xffff0000</span>u)) &#123; </span><br><span class="line">    <span class="comment">// 如果没有 1，则左移</span></span><br><span class="line">    x &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">    r -= <span class="number">16</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 若上一次有 1，由于没有左移，因此是判断最高四位是否有 1</span></span><br><span class="line">  <span class="comment">// 若上一次没有 1，判断的则是后八位中的前四位</span></span><br><span class="line">  <span class="keyword">if</span> (!(x &amp; <span class="number">0xff000000</span>u)) &#123;</span><br><span class="line">    x &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">    r -= <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(x &amp; <span class="number">0xf0000000</span>u)) &#123;</span><br><span class="line">    x &lt;&lt;= <span class="number">4</span>;</span><br><span class="line">    r -= <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(x &amp; <span class="number">0xc0000000</span>u)) &#123;</span><br><span class="line">    x &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">    r -= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(x &amp; <span class="number">0x80000000</span>u)) &#123;</span><br><span class="line">    x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    r -= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求大于一个数的 2 的幂</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> __attribute_const__ <span class="title function_">roundup_pow_of_two</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1UL</span> &lt;&lt; generic_fls(x - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这本质上是利用二分查找的原理，使用状态机的一种实现。主要的巧妙之处是利用了左移操作将每一次二分查找的分支进行了合并，使得代码变得更为简洁。</p><h2 id="利用溢出实现读写偏移量计算"><a href="#利用溢出实现读写偏移量计算" class="headerlink" title="利用溢出实现读写偏移量计算"></a>利用溢出实现读写偏移量计算</h2><p>对一个数取模，从而使其保持在一定范围内，是常见的操作数组、缓冲区等长度固定数据结构的操作。但相对来说，取模的运算速度会相对较慢。kfifo 为了实现更快的偏移量计算，并没有使用取模操作，而是使用位运算使长度溢出来实现的。</p><p>以写入为例，该部分的核心代码可以简化为（将部分进行了聚合处理）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __kfifo_get(<span class="keyword">struct</span> kfifo *fifo,</span><br><span class="line">                         <span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> l;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以写入的最大长度，由于 fifo-&gt;in 只会增长，即使有线程写入</span></span><br><span class="line">  <span class="comment">// 也只会导致可读区域变大，因此 len 是安全的</span></span><br><span class="line">  len = min(len, fifo-&gt;in - fifo-&gt;out);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内存屏障</span></span><br><span class="line">  smp_mb();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读当前位置到缓冲区末尾的数据</span></span><br><span class="line">  l = min(len, fifo-&gt;size - (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)));</span><br><span class="line">  <span class="built_in">memcpy</span>(buffer, fifo-&gt;buffer + (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)), l);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从缓冲区头读取剩余数据</span></span><br><span class="line">  <span class="built_in">memcpy</span>(buffer + l, fifo-&gt;buffer, len - l);</span><br><span class="line"></span><br><span class="line">  fifo-&gt;out += len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先忽略内存屏障，这里用到了几个小技巧。由于写入和读取的偏移量 <code>kfifo-&gt;in</code> 和 <code>kfifio-&gt;out</code> 都是无符号整形，即使 <code>kfifo-&gt;in</code>因为过大而发生了溢出，也能够保持<code>kfifo-&gt;in - kfifio-&gt;out &lt;= kfifo-&gt;size</code>。 因为 unsigned long类型的加减是回环的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m 是 unsigned long 最大值</span></span><br><span class="line">m := <span class="type">uint64</span>(<span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">println</span>(m + <span class="number">5</span> - m)<span class="comment">// 输出为 5</span></span><br></pre></td></tr></table></figure><p>另外一个比较巧妙的地方是，没有使用取模来计算偏移量，而是修改为了位运算的方式，这依赖于 kfifo 的缓冲区大小限定为 2 的幂。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统取模方式</span></span><br><span class="line"><span class="type">int</span> offset = kfifo-&gt;in % kfifo-&gt;size</span><br><span class="line"> </span><br><span class="line"><span class="comment">// kfifo 取模方式</span></span><br><span class="line"><span class="type">int</span> offset = kfifo-&gt;in &amp; (kfifo-&gt;size - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在二进制中，kfifo-&gt;size 可以表示为 1000···，那么 kfifo-&gt;size - 1 就可以表示为 0111···；同样地，kfifo-&gt;in 也可以分解为 offset + n2，其中 n2 是 kfifo-&gt;size的倍数，offset 是 kfifo-&gt;in % kfifo-&gt;size。由于 n2 是 kfifo-&gt;size 倍数，所以其数据只分布在大于 kfifo-&gt;size 位数的部分，因此只需要截取 kfifo-&gt;in 小于 kfifo-&gt;size 位数的部分，就可以得到 offset。观察到，kfifo-&gt;size - 1在每一个小于 kfifo-&gt;size 的位上的值均为 1，那么只要进行运算 kfifo-&gt;in % kfifo-&gt;size ，超出 kfifo-&gt;size 位数的部分会被截去，而小于 kfifo-&gt;size 位数的部分会被保留，即得到 offset。</p><p>还有一个比较巧妙的点是没有使用 if 进行判断，直接使用了两个memcpy。这里是直接利用 memcpy 的第三个参数进行了控制，当第一次 memcpy 完全拷贝时，第二次 memcpy 将不进行任何操作。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>在计算机操作系统中，一个读线程和一个写线程同时操作一个变量时不需要进行加锁的。在 kfifo 中，读操作与写操作分别只会更新 kfifo-&gt;out 和 kfifo-&gt;in，因此不会出现并发问题。</p><p>但是，参考《C++并发编程实践》第 123 页：“无论对象是怎么样的类型，对象都会存储在一个或多个内存位置上。每个内存位置不是标量类型的对象，就是标量类 型的子对象，比如，unsigned short、my_class*或序列中的相邻位域。当使用位域时就需要注意：虽然相邻位域 中是不同的对象，但仍视其为相同的内存位置。如图5.1所示，将一个struct分解为多个对象，并且展示了每个对象 的内存位置。”如下图，bf1 和 bf2 被保存在相同的位置。</p><p><img src="/images/image-20230113062116997.png" alt="image-20230113062116997"></p><p>这种情况下，bf1 和 bf2 可能会有多个副本分别存储在不同 CPU 的 Cache 中，如果线程 th1 写入 bf1 的同时线程 th2 读取bf2，那么 th2 可能会读取到在 CPU Cache 中的过期数据。由于 kfifo 中的成员都是基本类型，它们很有可能会被存储在相同的内存位置，因此需要引入内存屏障来保证以下写入顺序：</p><ul><li>kfifo-&gt;data 写入数据；</li><li>更新 kfifo-&gt;in 值。</li></ul><p>这也就是读取和写入操作中<code>  smp_mb()</code>的作用，用于强制保证内存的更新是全局的。</p><h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h2><ul><li>头文件：<a href="https://github.com/torvalds/linux/blob/master/include/linux/kfence.h">https://github.com/torvalds/linux/blob/master/include/linux/kfence.h</a></li><li>源文件：<a href="https://github.com/torvalds/linux/blob/master/lib/kfifo.c">https://github.com/torvalds/linux/blob/master/lib/kfifo.c</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Context 与超时控制</title>
      <link href="/2023/01/12/Context-%E4%B8%8E%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/"/>
      <url>/2023/01/12/Context-%E4%B8%8E%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Context-与超时控制"><a href="#Context-与超时控制" class="headerlink" title="Context 与超时控制"></a>Context 与超时控制</h1><p>Context 是 go 语言中监控与控制 goroutine 的一种方式，它可以在协程之间进行信息的传递，从而控制 goroutine 的行为。在一定程度上，可以将 context 看作包含一部分输入参数的 channel。与 channel 不同的是，channel 的传递并不是递归的，当一个 goroutine 调用的 goroutine 再次调用了 goroutine，简单使用 channel 进行退出通知是非常麻烦的；而使用 context 则能很轻松地使用递归的 goroutine 控制。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>context 在 go 语言中是一个接口，在此基础上可以衍生出不同的类型的 context，sdk 中提供了六种方法来获取不同类型的 context 以适用于不同的场景，可以概括为：</p><ul><li>两个接口：context、canceler</li><li>四种实现：emptyCtx、cancelCtx、timerCtx、valueCtx</li><li>六个方法：Background、TODO、WithCancel、WithDeadline、WithTimeout、WithValue</li></ul><h3 id="两个接口"><a href="#两个接口" class="headerlink" title="两个接口"></a>两个接口</h3><p>在 go sdk 中，context 和 canceler 接口定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 返回 context 的截止时间</span></span><br><span class="line">  Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">  <span class="comment">// 返回只读 channel，用于接收 context 是否完成</span></span><br><span class="line">  Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 返回 context 被取消的原因</span></span><br><span class="line">  Err() <span class="type">error</span></span><br><span class="line">  <span class="comment">// 返回 key 对应的 value</span></span><br><span class="line">  Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 取消方法</span></span><br><span class="line">  cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">  <span class="comment">// 返回只读 channel</span></span><br><span class="line">  Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这两种接口的基础上，sdk 实现了四种不同的基础 context，用户同样可以利用这些 context 来自行实现。</p><h3 id="四种实现"><a href="#四种实现" class="headerlink" title="四种实现"></a>四种实现</h3><p>在 context 和 canceler 接口的基础上，go sdk 包含了四种基础 context 实现。</p><h4 id="emptyCtx"><a href="#emptyCtx" class="headerlink" title="emptyCtx"></a>emptyCtx</h4><p>emptyCtx 的所有方法均为空方法，主要用于作为基础上下文，并衍生出其他上下文。由于 goroutine 的调用是树状的，因此 context 的组织形式也是树状的，一颗 context 树，其根节点应当是一个 emptyCtx 类型。</p><p>sdk 提供了 Background 和 TODO 两种 emptyCtx，两者互为别名，只是在语义上有所不同：</p><ul><li>context.Background 是上下文的默认值，所有其他的上下文都应该从它衍生出来；</li><li>context.TODO 应该仅在不确定应该使用哪种上下文时使用；</li></ul><p>一般情况下，会在一个模块的 main goroutine 使用 Background context；当想从一个叶 context 节点从派生出一个新的 context 叶时，可以选择使用 TODO。</p><h4 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h4><p>cancelCtx 是一个具备取消功能的 context，在父 goroutine 中可以使用 cancel 函数来通知 goroutine 进行取消。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父 goroutine 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parent</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取 context</span></span><br><span class="line">  ctx, cancel := context.WithCancel(context.Background(), time.Millisecond*<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    children(ctx)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知取消</span></span><br><span class="line">  cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">children</span><span class="params">(c *context.Context)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span>&#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;- c.Done():</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cancelCtx 可以用于用户交互等场景的控制，自由度比较高。</p><h4 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h4><p>timerCtx 主要通过两种方法来获得：WithDeadline、WithTimeout。不同之处就是一个是明确截止时间，一个是明确运行时间，使用方法与 cancelCtx 非常相似，也同样提供了 cancel 接口，用户可以手动进行取消，或等待设置的时间到期后自动取消。</p><p>timerCtx 是通过 timer.AfterFunc 来实现的，核心代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 设置定时器，当定时器到期后，自动调用取消函数</span></span><br><span class="line">    c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h4><p>valueCtx 提供了在不同 goroutine 之间利用 context 进行值传递的功能，可以使用 context 来进行链路追踪。valueCtx 只能够将值传递给子 goroutine，而不能够实现反向操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父 goroutine 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parent</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取 context</span></span><br><span class="line">  ctx := context.WithValue(context.Background(), <span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    children(ctx)</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">children</span><span class="params">(c *context.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 在子 goroutine 中获取值</span></span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;context key:&quot;</span>,c.Value(<span class="string">&quot;key&quot;</span>).(<span class="type">string</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不同-context-的混合使用"><a href="#不同-context-的混合使用" class="headerlink" title="不同 context 的混合使用"></a>不同 context 的混合使用</h3><p>用户可以将 sdk 中提供的六种方法混合使用，来构造较为复杂的 context，利用使用带有超时控制的值 context：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取超时</span></span><br><span class="line">withTimeout, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 加入值传递</span></span><br><span class="line">ctx := context.WithValue(withTimeout, <span class="string">&quot;traceId&quot;</span>, <span class="string">&quot;id12345&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Context-使用场景"><a href="#Context-使用场景" class="headerlink" title="Context 使用场景"></a>Context 使用场景</h2><p>context 可以很轻松地完成消息在 goroutine 中的传递，但是不能够直接完成对 goroutine 的控制，而是需要用户自行完成接收通知的逻辑，也就是这是一种侵入式比较强的消息传递方式。但由于这是在 go sdk 中提供的一种标准控制方式，所以其应用场景非常广，一些开源的工具包中基本上都提供了包含 context 的实现，使用起来会相对简单。</p><p>一般情况下，在下一级逻辑中，需要使用定时器和 select 来完成对 context 超时的读取，或者是使用 context 中的截止时间，不使用ctx.Done 函数完成超时控制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mongo-driver session.go</span></span><br><span class="line"><span class="comment">// 不使用 ctx.Done() 完成控制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// timeout 定时事件为 context deadline</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-timeout.C:</span><br><span class="line">    <span class="keyword">return</span> res, err</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// default 自旋，防止被阻塞</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> res, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论哪一种方式，使用 context 来完成超时控制都是需要使用 for - select 循环来处理的，对于网络 IO、信号阻塞等对 CPU 占用比较少的情景，使用 context 是非常合适的。但是如果使用 context 来处理一些比较重型的任务，就显得不是特别合适，因为不能够直接在任务中去执行检查。这种情况下，可以考虑使用状态机来将任务进行分解，每一个阶段来完成后检查一次是否超时。</p><h2 id="另一种超时控制"><a href="#另一种超时控制" class="headerlink" title="另一种超时控制"></a>另一种超时控制</h2><p>使用 context 进行超时控制是侵入式的，可能会破坏代码逻辑，增加维护的难度。最主要的是，当需要调用的代码并没有提供 context 接口时，无法使用 context 来完成控制逻辑。<strong>这种情况下，是无法完成对 goroutine 的调度的，只能够完成在逻辑上的退出，即上一层逻辑提前完成并放任下一层逻辑继续运行直至退出</strong>。这种情况下，可以使用 goroutine 来完成非侵入式的超时控制。gin-contrib 中的 timeout 中间件就是一个很好的例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码截自 gin-contrib/timeout@v0.0.3/timeout.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(opts ...Option)</span></span> gin.HandlerFunc &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开辟缓冲区，存储下一层逻辑返回值</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 goroutine 处理下一层逻辑</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理下一层逻辑中抛出的 panic</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        panicChan &lt;- p</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 处理下一层逻辑</span></span><br><span class="line">    t.handler(c)</span><br><span class="line">    <span class="comment">// 等待下一层逻辑完成</span></span><br><span class="line">    finish &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 处理下一层逻辑抛出的 panic</span></span><br><span class="line">    <span class="keyword">case</span> p := &lt;-panicChan:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 处理下一层逻辑完成</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-finish:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 default 返回值和 error:timeout 返回</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理超时</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(t.timeout):</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用下一层逻辑的返回值返回</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，源码中并没有去调度下一层逻辑的 goroutine，而是在超时后直接使用 default 值并抛出一个错误来完成退出。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这两种方法显然都不是特别完美，但是 goroutine 的调度机制决定了，一个 goroutine 只能够自行退出。这种调度方式是最符合 goroutine 的使用逻辑的，一个 goroutine 内必须是一个完整的状态机来处理逻辑，直接 abort 一个 goroutine 会大大增加状态的不确定性，这是一个非常危险的操作。</p><p>timeout 本身就是非常危险的，如果在操作一个有状态的程序，无法通过 timeout 来确定程序的状态。因此，需要避免在不需要进行用户交互的代码层级使用超时错误，并避免超时错误传递到数据库层级。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 中的 IO 操作</title>
      <link href="/2023/01/10/go-%E4%B8%AD%E7%9A%84-IO-%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/01/10/go-%E4%B8%AD%E7%9A%84-IO-%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="go-中的-IO-操作"><a href="#go-中的-IO-操作" class="headerlink" title="go 中的 IO 操作"></a>go 中的 IO 操作</h1><p>go 语言的官方库中对所有的文件描述符都做了统一的封装，无论是 socket 文件还是普通文件，都包含了<code>poll.FD</code>数据结构，并被 pollDesc 统一管理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通文件描述符</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">  pfd         poll.FD</span><br><span class="line">  name        <span class="type">string</span></span><br><span class="line">  dirinfo     *dirInfo <span class="comment">// nil unless directory being read</span></span><br><span class="line">  nonblock    <span class="type">bool</span>     <span class="comment">// whether we set nonblocking mode</span></span><br><span class="line">  stdoutOrErr <span class="type">bool</span>     <span class="comment">// whether this is stdout or stderr</span></span><br><span class="line">  appendMode  <span class="type">bool</span>     <span class="comment">// whether file is opened for appending</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket 描述符</span></span><br><span class="line"><span class="keyword">type</span> netFD <span class="keyword">struct</span> &#123;</span><br><span class="line">  pfd poll.FD</span><br><span class="line"></span><br><span class="line">  <span class="comment">// immutable until Close</span></span><br><span class="line">  family      <span class="type">int</span></span><br><span class="line">  sotype      <span class="type">int</span></span><br><span class="line">  isConnected <span class="type">bool</span> <span class="comment">// handshake completed or use of association with peer</span></span><br><span class="line">  net         <span class="type">string</span></span><br><span class="line">  laddr       Addr</span><br><span class="line">  raddr       Addr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种文件类型的读写操作都会最终调用 <code>poll.FD</code>的读写函数，以文件描述符的读操作为例，最终会调用以下函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read implements io.Reader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 检查、加锁、准备操作</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 忽略 EINTR 错误，并尝试进行读取</span></span><br><span class="line">    n, err := ignoringEINTRIO(syscall.Read, fd.Sysfd, p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      n = <span class="number">0</span></span><br><span class="line">      <span class="comment">// 如果读取失败，错误为 EAGAIN，且 fd 被注册到了多路复用管理器中</span></span><br><span class="line">      <span class="comment">// 主动进入阻塞状态，并等待被唤醒</span></span><br><span class="line">      <span class="keyword">if</span> err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() &#123;</span><br><span class="line">        <span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    err = fd.eofError(n, err)</span><br><span class="line">    <span class="keyword">return</span> n, err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数处理读取的主要逻辑为：尝试非阻塞读取——如果读取成功则返回/读取失败则进入阻塞。该函数的处理逻辑其实已经对普通文件和 socket 文件进行了分流，普通文件的读写通常是不会进入阻塞状态的，通常会在第一次读取时返回。而 socket 类型的文件描述符，在尝试读取失败后，会进入到 <code>fd.pd.waitRead(fd.isFile)</code>，最终调用<code>runtime_pollWait</code> 函数，将当前 goroutine 的标识为更改为阻塞状态。</p><p>go 语言中，虽然 IO 底层使用了非阻塞的多路复用，但最终提交给用户是阻塞调用的模式。非阻塞多路复用只是为了给 goroutine 提供调度——当一个协程发现自身不能满足执行条件时，得以能够主动修改自身状态，使自身进入到协程的阻塞状态，而不是被操作系统进行线程调度，使线程进入阻塞。用户态的阻塞 IO 是为了配合 goroutine 的调度机制和 go 语言的编程逻辑，即采用多个 goroutine 来处理并行的请求。这样程序在编写过程中就只要考虑请求的执行顺序，如果执行过程中遇到条件不满足的情况，直接进入阻塞并等待被唤醒。</p><p>如果需要在 go 中使用非阻塞 IO，那么可能就需要抛弃官方库所构建出的高层次抽象，这其实更像是在写 C/C++程序。go 语言在 package unix 中提供了比较底层的 unix 标准函数封装，用户可以在此基础上自行搭建非阻塞 IO 模型来满足特定场景下的需求。</p><p>如果需要调用底层的 package unix，一定要将 fd 设置为非阻塞的方式。因为操作系统的是无法感知到 goroutine 的，如果使用阻塞操作，可能会导致 M 被操作系统调度，导致无法进行 G 调度，导致 goroutine 正常切换调度收到影响。fd 的非阻塞已经在 package unix 中封装完毕，为了与 unix 函数保持一致，unix 包中的函数都没有自动设置为非阻塞状态，需要用户手动设置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非常经典的设置非阻塞，简直跟 C++ 一模一样</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetNonblock</span><span class="params">(fd <span class="type">int</span>, nonblocking <span class="type">bool</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">  flag, err := fcntl(fd, F_GETFL, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> nonblocking &#123;</span><br><span class="line">    flag |= O_NONBLOCK</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    flag &amp;= ^O_NONBLOCK</span><br><span class="line">  &#125;</span><br><span class="line">  _, err = fcntl(fd, F_SETFL, flag)</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>channel 与 select 的一些记录</title>
      <link href="/2023/01/10/channel-%E4%B8%8E-select-%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/01/10/channel-%E4%B8%8E-select-%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="channel-与-select-的一些记录"><a href="#channel-与-select-的一些记录" class="headerlink" title="channel 与 select 的一些记录"></a>channel 与 select 的一些记录</h1><p>本篇文章用于记录本人学习到的与 channel 与 select 有关的一些知识。</p><h2 id="CSP-并发模型"><a href="#CSP-并发模型" class="headerlink" title="CSP 并发模型"></a>CSP 并发模型</h2><p>CSP 并发模型是指“不要通过共享内存来通信，而应该通过通信来共享内存”。go 语言的并发模型是基于 CSP 模型的，这得益于完备的 go、channel、select 体系。这一模型的核心思想是尽量降低程序模块之间的耦合度，尽可能地将每一个模块封装为状态机的形式，在不同的模块之间通过数据或标志位的传递来改变状态机的行为，并尽可能降低不同模块之间的临界竞争。</p><p>在 C++程序中，线程之间的通信大多数场景也是遵循这一思想的。大部分线程之间会选择使用队列、原子标志位、期望值来进行同步，而不是多个线程同时去并发访问同一数据结构。毕竟无锁数据结构的设计非常复杂，并且可以设计为无锁形式的数据结构非常有限；而采取加锁的形式来保证线程安全可能会因为竞争而带来比较严重的性能问题。</p><p>C++的并发编程中，简单的控制同步可以直接使用原子量来完成，数据类型的传递可以使用队列来完成。但是，如果状态机中的某个状态具有多个分支，可能就需要使用多个原子量、或者使用多态类型的队列，在实际编程过程中可能会比较繁琐。而 go 语言中的 select 语句可以很好地实现信号的多路复用，使得一个程序的模块可以更加轻松地使用复杂的状态机。这也是为什么 goroutine 并没有提供外界退出的方式，而是必须从自身的逻辑中退出。go 语言的编程逻辑中，更希望每一个 goroutine 中封装的是一个完成的状态机，每一个 goroutine 都是一个独立的模块，从而实现程序不同模块间的低耦合。</p><p>如果进程内的所有线程/协程之间传递数据都使用FIFO 队列，可能会出现较多的内存拷贝。一种更好的方式是针对大对象，通过指针的方式来转移对象的所属权，使程序的不同模块用流水线的方式工作。</p><p>CSP 并发模型，更多地还是在描述程序不同模块之间如何去进行信息交换。在程序模块的内部，为了高性能可以尝试使用一些更加底层的方法来进行更加复杂的操作，但是最好不要将这种复杂度传递给模块之外，否则程序将会变得难以维护。</p><h2 id="hchan"><a href="#hchan" class="headerlink" title="hchan"></a>hchan</h2><p>go 语言中 channel 底层使用的是 hchan 结构体，它本质上是一个有锁的环形缓冲区，hchan 数据结构如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有缓冲时，存储相关信息</span></span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// 循环数组中的元素数量</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// 循环数组的长度</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 指向底层循环数组的指针</span></span><br><span class="line">    elemsize <span class="type">uint16</span> <span class="comment">//能够收发元素的大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    closed   <span class="type">uint32</span>   <span class="comment">//channel是否关闭的标志</span></span><br><span class="line">    elemtype *_type <span class="comment">//channel中的元素类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读写游标</span></span><br><span class="line">    sendx    <span class="type">uint</span>   <span class="comment">// 下一次发送数据的下标位置</span></span><br><span class="line">    recvx    <span class="type">uint</span>   <span class="comment">// 下一次读取数据的下标位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于处理读写阻塞</span></span><br><span class="line">    recvq    waitq  <span class="comment">// 读等待队列</span></span><br><span class="line">    sendq    waitq  <span class="comment">// 写等待队列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lock mutex <span class="comment">//互斥锁，保证读写channel时不存在并发竞争问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 hchan 中的 ring_buffer 缓冲区有数据，那么读写操作无特殊之处。若 hchan 中缓冲区为空，并且接收到一个读操作，或者 hchan 中缓冲区已满，但是接收到一个写操作；那么就会将该操作注册到 waitq 结构体中，waitq 结构体底层是一个 sudog 链表，存储了阻塞 goroutine 的相关调度信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始G结构。相当于g_id</span></span><br><span class="line">    g *g</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待链表上的指针</span></span><br><span class="line">    next *sudog</span><br><span class="line">    prev *sudog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所属的channel，相当于channel_id</span></span><br><span class="line">    c    *hchan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sudog 是注册在一个具体的 hchan 上的，这是因为一个 goroutine 可能会因为不同的 channel 阻塞，因此每一个 hchan 都必须要保留能够查询到阻塞 goroutine 的指针。</p><p>通过上述结构体的分析，goroutine 因为 channel 而陷入阻塞，是会主动让出执行权的。而唤醒操作则由另外一个操作 channel 的 goroutine 负责。</p><h2 id="channel-的并发读写"><a href="#channel-的并发读写" class="headerlink" title="channel 的并发读写"></a>channel 的并发读写</h2><p>一般的互斥量性能都会随着并发量的增长而迅速下降；channel 虽然是一个有锁的数据结构，但是因为底层做了特殊的优化，即使由大量的 goroutine 进行并发操作也不会造成性能的严重下降，只会发生 ns 级别的改变。</p><p>另外，由于涉及到 GC 的问题，所有数据结构在经过 channel 进行传递时都会发生一次复制。因此，可以尽量尝试使用指针来传递比较复杂的数据结构，防止内存复制损耗过多时间。</p><h2 id="select-的阻塞与唤醒"><a href="#select-的阻塞与唤醒" class="headerlink" title="select 的阻塞与唤醒"></a>select 的阻塞与唤醒</h2><p>在早期的版本中，select 语句是由后台 goroutine 轮询来实现的，当分支过多的情况下性能会比较差。在最新版本中，已经针对 select 语句进行了优化，采取了被动调度的方式进行唤醒。</p><p>select 语句的执行逻辑大致可以分为三步：</p><ul><li>判断当前是否有就绪 channel，并随机选择一个分支执行操作</li><li>若无就绪 channel，将 goroutine 信息注册到各个 channel 分支，进入阻塞</li><li>被唤醒时检测就绪 channel，随机选择一个分支操作</li></ul><p>这意味着，一个 for - select 循环在一直满足就绪条件下是可以不断执行的，直到运行被抢占。</p><p>当一个 goroutine 中的 select 语句中并没有可满足的条件时，runtime.selectgo 函数会根据不同分支的 poller 顺序来选择被唤醒时的轮询顺序（每一次完成选择后会重新将该顺序打乱，保证随机选择分支）；还需要根据 channel 的内存指针顺序来依次加锁，以防止死锁。完成上述操作后，goroutine 会进入阻塞状态，等待自身的 G 结构被其他 goroutine 因发送 channel 而状态改变为 _Grunnable，也就是进入 select 阻塞后的 goroutine 只能够被 goroutine 调度器唤醒，而不会主动尝试运行。当 goroutine 被唤醒时，会将所有的 channel 加锁，并且释放所有的 sudog 结构体。</p><p>由于 select 语句在进入阻塞和被唤醒时都需要对所有 channel 加锁，这里会有一定的性能损耗。</p><p>select 语句是一个多分支语句，只能够随机选择一个 channel 运行。但是 go 语言中，sudog 的节点的移出是由解除阻塞的一方负责的，如果不加以控制，就可能会出现多个分支注册的 sudog 同时被多个协程删除的情况，这样就会造成channel 消息的丢失。为了防止这一情况，select 语句注册的 sudog 会做出特殊的标记处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/chan.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *waitq)</span></span> dequeue() *sudog &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是链表删除的逻辑，进入函数前已经对 hchan 加锁</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if a goroutine was put on this queue because of a</span></span><br><span class="line">    <span class="comment">// select, there is a small window between the goroutine</span></span><br><span class="line">    <span class="comment">// being woken up by a different case and it grabbing the</span></span><br><span class="line">    <span class="comment">// channel locks. Once it has the lock</span></span><br><span class="line">    <span class="comment">// it removes itself from the queue, so we won&#x27;t see it after that.</span></span><br><span class="line">    <span class="comment">// We use a flag in the G struct to tell us when someone</span></span><br><span class="line">    <span class="comment">// else has won the race to signal this goroutine but the goroutine</span></span><br><span class="line">    <span class="comment">// hasn&#x27;t removed itself from the queue yet.</span></span><br><span class="line">    <span class="keyword">if</span> sgp.isSelect &amp;&amp; !atomic.Cas(&amp;sgp.g.selectDone, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sgp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果发现取出的 sudog 结构体是由 select 语句注册的，那么会使用 CAS 语句将 selectDone 标志位设置为 1。虽然在进入 dequeue 函数前已经对 hchan 加锁，但是这里的 selectDone 标志位也被注册到了其他 hchan 结构体中，可能会发生 concurrency unsafe。如果成功修改标志位，代表本次操作是第一个通知 select 的操作，此时才会进行数据拷贝；如果修改失败，那么会将忽略本次操作，并且再一次尝试取出 sudog。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gnet 与 net 网络库性能对比</title>
      <link href="/2023/01/09/gnet-%E4%B8%8E-net-%E7%BD%91%E7%BB%9C%E5%BA%93%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
      <url>/2023/01/09/gnet-%E4%B8%8E-net-%E7%BD%91%E7%BB%9C%E5%BA%93%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h1 id="gnet-与-net-网络库性能对比"><a href="#gnet-与-net-网络库性能对比" class="headerlink" title="gnet 与 net 网络库性能对比"></a>gnet 与 net 网络库性能对比</h1><p>在使用 go 语音进行网络编程时，由于 net.Conn.Read 提供的是阻塞读，通常需要将每一个客户端连接放在一个协程中处理，这种方式虽然比较简单，但是会带来一定的性能损耗。</p><h2 id="测试背景"><a href="#测试背景" class="headerlink" title="测试背景"></a>测试背景</h2><p>在使用 go 语言仿写 redis 服务器时，我尝试使用了三种不同的基础架构：</p><ol><li>每一个客户端开启协程负责协议解析、命令执行、消息写回，数据库采用读写锁；</li><li>每一个客户端开启协程负责协议解析，等待事务协程完成命令执行后，再由客户端协程写入消息，协程使用 channel 通信；</li><li>使用 gnet 网络库，采用传统单线程 reactor 模式。</li></ol><p>经过 redis-benchmark 的性能测试，在双核四线程的 CPU 上，这三者的并发量以及 redis-server 的并发量分别如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-server</span> </span><br><span class="line">Summary:</span><br><span class="line">  throughput summary: 76982.29 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.387     0.152     0.351     0.655     0.799     1.511</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式 1，单独设置事务协程</span></span><br><span class="line">Summary:</span><br><span class="line">  throughput summary: 46289.86 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.611     0.048     0.551     0.919     1.999     3.711</span><br><span class="line">        </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式 2，不单独设置事务协程</span></span><br><span class="line">Summary:     </span><br><span class="line">  throughput summary: 42680.32 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.620     0.048     0.599     0.863     1.279     4.871</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式 3，使用 gnet 网络库</span></span><br><span class="line">Summary:</span><br><span class="line">  throughput summary: 67977.26 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.590     0.120     0.543     1.079     1.439     2.335</span><br></pre></td></tr></table></figure><p>很显然，使用 gnet 网络库的并发量要远远高于使用原生的 go 语言网络库，并发量基本上可以达到 redis-server 的 90%左右，考虑到 go 语言中的 GC 机制，这是一个非常不错的并发量。</p><h2 id="火焰图分析"><a href="#火焰图分析" class="headerlink" title="火焰图分析"></a>火焰图分析</h2><p>使用 pprof 工具分别对这三种方式进行分析。</p><h3 id="单独设置事务协程"><a href="#单独设置事务协程" class="headerlink" title="单独设置事务协程"></a>单独设置事务协程</h3><p>在单独设置事务协程时，火焰图如下。可以看到事务的执行时间只占总时间片的 5%左右，其余的 CPU 时间片主要是用于网络 IO 以及 runtime 调度协程。</p><p><img src="/images/pprof-1.png" alt="pprof-1"></p><h3 id="不单独设置事务协程"><a href="#不单独设置事务协程" class="headerlink" title="不单独设置事务协程"></a>不单独设置事务协程</h3><p>在不单独设置事务协程时，火焰图如下，大部分的 CPU 时间片也是用于网络 IO 以及 runtime 调度协程。不过注意到，不单独设置事务协程时，runtime 进行协程调度的时间片要略高。</p><p><img src="/images/pprof-2.png" alt="pprof-2"></p><h3 id="使用-gnet"><a href="#使用-gnet" class="headerlink" title="使用 gnet"></a>使用 gnet</h3><p>在使用 gnet 网络库后，根据火焰图可以看到，原本占据约 1/3 CPU 时间片的协程调度部分消失了，这是 gnet 性能比 net 网络库要高的根本原因。</p><p><img src="/images/pprof-3.png" alt="pprof-3"></p><h2 id="三种模式的分析对比"><a href="#三种模式的分析对比" class="headerlink" title="三种模式的分析对比"></a>三种模式的分析对比</h2><p>无论是否单独设置事务协程，基于 net 架构的系统都只能有一个协程来进行数据库的读写，事务的执行效率其实是类似的。</p><p>在单独设置事务协程的情况下，由于事务协程通常是可以连续执行，不会主动进入阻塞状态，能够在一定程度上减少 goroutine 的调度次数，这一点也能够反应在火焰图中。不过单独设置事务协程的情况下，需要使用 channel 在协程之间进行消息传递，这也会在一定程度上造成性能的损耗。在不单独设置事务协程的情况下，协程可能会因为等待数据库锁而进行阻塞状态，当协程数量比较大时可能竞争会比较严重，比较依赖于锁的性能。</p><p>在少核环境下，根据测试，单独设置事务协程可能会更具有优势。</p><p>使用 gnet 网络库更像是在处理传统的 C/C++ 网络编程，因为不需要 goroutine 的调度，性能确实会比 net 的方式要高出一截。但是同样的，使用 gnet 意味着无法使用 go 语言的一些特性。并且，本次测试的程序，其事务流程都非常简单，事务的执行时间非常短，程序的性能更加程度上取决于网络架构。当服务器的事务执行较为复杂，或者是需要等待系统中其他模块的响应时，事务的执行时间会变长。由于 gent 更像是一个原生的 reactor 模式，单次的读事件如果长时间阻塞就会严重影响整个网络部分的性能。这种情况下，使用 gnet 带来的性能提升就没有那么高，并且可能需要对网络部分进行单独的模块封装，这样会增加系统的复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 goroutine 模拟 redis IO 模型</title>
      <link href="/2022/12/27/%E4%BD%BF%E7%94%A8%20goroutine%20%E6%A8%A1%E6%8B%9F%20redis%20IO%20%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/12/27/%E4%BD%BF%E7%94%A8%20goroutine%20%E6%A8%A1%E6%8B%9F%20redis%20IO%20%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-goroutine-模拟-redis-IO-模型"><a href="#使用-goroutine-模拟-redis-IO-模型" class="headerlink" title="使用 goroutine 模拟 redis IO 模型"></a>使用 goroutine 模拟 redis IO 模型</h1><p>在 redis 6.0 之后，redis 引入了 IO 线程的概念，但是并没有改变原有的单线程执行事务的模式。这是因为网络 IO 和协议解析在一次请求耗时中的占比是非常大的。使用单线程的模型可以简化应用层数据结构的设计，从而使代码更加便于维护。</p><p>而 go 语言中，同样可以利用 goroutine 和 channel 来模拟 redis 的请求处理方式，使用单一事务协程和多个协议解析协程的方式来处理客户端请求。这种处理方式不仅能够借助 go 语言的特点，还能够结合传统 reactor 事务模式的特点，使得代码更易于维护。这种模式下，网络 IO 可以分为 Accept Loop, IO Loop, Event Loop，分别完成建立新连接，解析客户端命令，处理客户端请求的功能。</p><h2 id="抽象客户端连接"><a href="#抽象客户端连接" class="headerlink" title="抽象客户端连接"></a>抽象客户端连接</h2><p>由于 goroutine 不具备传统线程的特点，不能够直接从外部来改变协程的状态。可以将每一个客户端连接所对应的协程抽象为一个 Client Struct，也就是一个 Context 进行管理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">  event *Request             <span class="comment">// 解析后的命令</span></span><br><span class="line">  raw []<span class="type">byte</span>               <span class="comment">// 解析前的命令</span></span><br><span class="line">  res <span class="keyword">chan</span> *Response <span class="comment">// 回包</span></span><br><span class="line"></span><br><span class="line">  cnn   net.Conn  <span class="comment">// 连接实例</span></span><br><span class="line">  id    uuid.UUID <span class="comment">// Cli 编号</span></span><br><span class="line">  tp    time.Time <span class="comment">// 通信时间戳</span></span><br><span class="line"></span><br><span class="line">  status ClientStatus  <span class="comment">// 状态 0 等待连接 1 正常 -1 退出 -2 异常</span></span><br><span class="line">  exit   <span class="type">bool</span> <span class="comment">// 退出标志</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(c net.Conn)</span></span> *Client &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个 <code>Client Struct</code> 都对应了一个 <code>net.Conn</code> 实例，并运行在一个单独的 goroutine 上。结构体内部存储与该连接相关的所有信息，当不同循环之间需要通信时，可以使用 <code>chan *Client</code> 进行通信，减少数据的拷贝。</p><h2 id="Accept-Loop"><a href="#Accept-Loop" class="headerlink" title="Accept Loop"></a>Accept Loop</h2><p>Accept Loop 主要执行 reactor 模型中 Acceptor 对象的功能，监听被动套接字，新连接抽象为<code>Client Struct</code>，并开启协程来处理读写请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理新连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AcceptLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> !quit&#123;</span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立一个新的 Client 实例</span></span><br><span class="line">    newCli := NewClient(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启协程处理 IO 请求</span></span><br><span class="line">    <span class="keyword">go</span> IOLoop(newCli)<span class="comment">// 这里也可以使用协程池的方式，一个协程绑定多个客户端连接</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="IO-Loop"><a href="#IO-Loop" class="headerlink" title="IO Loop"></a>IO Loop</h2><p>IO Loop 主要负责处理 socket 的读写，客户端请求的解析工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IOLoop</span><span class="params">(cli *Client)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> !cli.exit &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读请求</span></span><br><span class="line">    cli.cnn.Read(cli.raw[rd:])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析请求</span></span><br><span class="line">    parseRequest(cli.raw,cli.event)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 channel 发送通知</span></span><br><span class="line">    events &lt;- cli</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 Event Loop 执行</span></span><br><span class="line">    cli.cnn.Write( &lt;-cli.res) </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知 Event Loop 释放相关记录</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>Event Loop 处理 IO Loop 发送的活跃事件以及定时事件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EventLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> !quit&#123;</span><br><span class="line">    timer := time.NewTimer(time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行时间事件</span></span><br><span class="line">      execTimeEvent()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> cli := &lt;-events:</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行 IO 时间</span></span><br><span class="line">      eventRes := executeIOEvent(cli.event)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通知阻塞的客户端</span></span><br><span class="line">      cli.res &lt;- eventRes</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行退出事件</span></span><br><span class="line">  executeShutdownEvents()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>事件流程较为清晰，事件的处理并不存在并发。</li><li>可以减少应用层临界资源的竞争。</li><li>可以保证所有事件是串行执行的。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>使用管道传递主业务数据，会造成一定的性能损耗。</li><li>该模式不适合单个事件执行时间过长的场景。</li></ul><h3 id="redis-场景下的对比"><a href="#redis-场景下的对比" class="headerlink" title="redis 场景下的对比"></a>redis 场景下的对比</h3><p>在保证协议解析部分，数据库部分（除读写锁）相同的情况下，测试直接使用 goroutine 解析并执行命令（使用读写锁保证互斥）、使用单独的 goroutine 执行命令、redis-server 三者性能。redis-benchmark，测试环境为 MacOS Ventura 13.0，8 G 内存，双核四线程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用单独 goroutine 串行执行命令</span></span><br><span class="line">Summary:</span><br><span class="line">  throughput summary: 45289.86 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.611     0.048     0.551     0.919     1.999     3.711</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接使用 goroutine 解析并执行命令</span></span><br><span class="line">Summary:     </span><br><span class="line">  throughput summary: 42680.32 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.620     0.048     0.599     0.863     1.279     4.871</span><br><span class="line">        </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-server</span> </span><br><span class="line">Summary:</span><br><span class="line">  throughput summary: 76982.29 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.387     0.152     0.351     0.655     0.799     1.511</span><br></pre></td></tr></table></figure><p>经过多次对比，使用单独 goroutine 串行执行命令时，每秒钟执行的命令数比直接使用 goroutine 解析并执行命令多 3000 次左右，并且后者并没有执行 aof 刷盘、更新服务器状态等时间事件。而 redis-server 的每秒请求数保持在 76000 左右，远远高于 go 语言版本。</p><h2 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h2><p>使用 pprof 工具获取压力测试阶段的调用图。可以看到，syscall.read 和 syscall.write 占据了绝大多数的 CPU 时间片，网络 IO 是主要的性能瓶颈。</p><p><img src="/images/image-20230108035814657.png" alt="image-20230108035814657"></p><p>经过查阅资料，go 官方的 net 库性能较差，尝试选用 gnet 网络库更换 net 库。更换后，进行同样的测试，性能有较大的提升。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 gnet 网络库</span></span><br><span class="line">Summary:</span><br><span class="line">  throughput summary: 64977.26 requests per second</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.590     0.120     0.543     1.079     1.439     2.335</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 暴露部分私有接口</title>
      <link href="/2022/12/27/C++-%E6%9A%B4%E9%9C%B2%E9%83%A8%E5%88%86%E7%A7%81%E6%9C%89%E6%8E%A5%E5%8F%A3/"/>
      <url>/2022/12/27/C++-%E6%9A%B4%E9%9C%B2%E9%83%A8%E5%88%86%E7%A7%81%E6%9C%89%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="C-暴露部分私有接口"><a href="#C-暴露部分私有接口" class="headerlink" title="C++ 暴露部分私有接口"></a>C++ 暴露部分私有接口</h1><p>C++ 中可以通过桥接类的方式来暴露类的一部分接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exposure</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hidden</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Exposure</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要隐藏的接口</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hidden</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exposure</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露 foo 接口 和 bar 接口</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> impl_-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> impl_-&gt;<span class="built_in">bar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Hidden *impl_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 防止头文件暴露私有变量</title>
      <link href="/2022/12/27/C++-%E9%98%B2%E6%AD%A2%E5%A4%B4%E6%96%87%E4%BB%B6%E6%9A%B4%E9%9C%B2%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F/"/>
      <url>/2022/12/27/C++-%E9%98%B2%E6%AD%A2%E5%A4%B4%E6%96%87%E4%BB%B6%E6%9A%B4%E9%9C%B2%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="C-防止头文件暴露私有变量"><a href="#C-防止头文件暴露私有变量" class="headerlink" title="C++ 防止头文件暴露私有变量"></a>C++ 防止头文件暴露私有变量</h1><p>C++ 中可以通过嵌套类的形式防止成员私有变量暴露在头文件里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exposure</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Exposure</span>();</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">interface</span><span class="params">(<span class="type">int</span> foo)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Impl</span>;</span><br><span class="line">  std::unique_ptr&lt;Impl&gt; impl_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exposure</span>::Impl &#123;</span><br><span class="line">  <span class="comment">// 具体实现</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">interfaceImpl</span><span class="params">(<span class="type">int</span> foo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exposure::<span class="built_in">Exposure</span>() : <span class="built_in">impl_</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;())&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Exposure::interface</span><span class="params">(<span class="type">int</span> foo)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;impl_-&gt;<span class="built_in">interfaceImpl</span>(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BSON结构分析</title>
      <link href="/2022/12/27/BSON%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/2022/12/27/BSON%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="BSON-结构分析"><a href="#BSON-结构分析" class="headerlink" title="BSON 结构分析"></a>BSON 结构分析</h1><h2 id="BSON-简介"><a href="#BSON-简介" class="headerlink" title="BSON 简介"></a>BSON 简介</h2><p>BSON 全称是 Binary JSON, 和 JSON 很像，但是采用二进制格式进行存储。相比 JSON 有以下优势：</p><ul><li><strong>访问速度更快。</strong>BSON 会存储 Value 的类型，相比于明文存储，不需要进行字符串类型到其他类型的转换操作。以整型 12345678 为例，JSON 需要将字符串转成整型，而 BSON 中存储了整型类型标志，并用 4 个字节直接存储了整型值；</li><li><strong>存储空间更低。</strong>还是以整型 12345678 为例，JSON 采用明文存储的方式需要 8 个字节，但是 BSON 对于 Int32 的值统一采用 4 字节存储，Long 和 Double 采用 8 字节存储。 当然这里说存储空间更低也分具体情况，比如对于小整型，BSON 消耗的空间反而更高；</li><li><strong>数据类型更丰富。</strong>BSON 相比 JSON，增加了 BinData，TimeStamp，ObjectID，Decimal128 等类型。</li></ul><h2 id="BSON-存储格式"><a href="#BSON-存储格式" class="headerlink" title="BSON 存储格式"></a>BSON 存储格式</h2><p>一条最简单的 BSON 文档，从前向后可以拆解成以下几个部分：</p><ol><li>文档的总长度， 占 4 个字节；</li><li>Value 类型，参考<a href="https://github.com/mongodb/mongo/blob/r4.2.21/src/mongo/bson/bsontypes.h#L59-L110">代码定义</a>，占 1 个字节；</li><li>Key 的 String 表示形式（Key 只能 String 类型），长度不固定，以 ‘\0’ 结尾，占 len(Key)+1 个字节；</li><li>Value 的二进制存储，比如 Int32 占 4 字节，Long 和 Double 占 8 个字节等；</li><li>文档以 ‘\0’ 结尾，也就是在遍历 BSON 到末尾时，常见的 EOO(End Of Object)，占 1 个字节；</li></ol><h2 id="紧凑格式的缺点"><a href="#紧凑格式的缺点" class="headerlink" title="紧凑格式的缺点"></a>紧凑格式的缺点</h2><p>BSON 的存储格式非常紧凑，不同的键值对之间是无间隔存储。因此，修改 BSON 中的某一字段意味着需要组织处一个新的 BSON 对象。如果增加、删除或者修改了某个字段，要生成新 BSON 文档，而非在原有 BSON 文档上原地修改。</p><p>在使用 MongoDB 时，可以使用 JSON 格式来暂时存储数据以便在不同的程序模块之间传递。当数据需要插入 MongoDB 时，再将数据封存，转换为 BSON 格式。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 复制集同步过程</title>
      <link href="/2022/12/26/MongoDB-%E5%A4%8D%E5%88%B6%E9%9B%86%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/12/26/MongoDB-%E5%A4%8D%E5%88%B6%E9%9B%86%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB-复制集同步过程"><a href="#MongoDB-复制集同步过程" class="headerlink" title="MongoDB 复制集同步过程"></a>MongoDB 复制集同步过程</h1><p>MongoDB Replica Set 是一种基于分布式选举和复制状态机的高可用架构，这一套模式虽然与 paxos、raft 协议非常相似，但实质上差异却非常大。raft 协议中，所有事务的提交都是线性的，所有节点会进行同步提交，因此可以保持很高的数据一致性，但是写性能会比较差；而 MongoDB 的复制集则是一种异步复制+选举算法的结合，通过调节事务的提交时间来完成数据一致性的保证。</p><h2 id="基于-Oplog-的数据同步机制"><a href="#基于-Oplog-的数据同步机制" class="headerlink" title="基于 Oplog 的数据同步机制"></a>基于 Oplog 的数据同步机制</h2><p>与 raft 协议类似，MongoDB 中也是采用复制状态机的模式来进行数据复制，在 MongoDB 中用于节点同步的日志类型称为 Oplog。Oplog 其实并不是一种日志文件，而是 WiredTiger 中一个特殊的 Collection，这种特殊的模式使得 MongoDB 中应用层日志、数据、索引实际上是作为一个事务整体写入的。这种设计能够有效地规避应用层日志与数据库日志不相同的问题，这个问题在 MySQL 中有所体现，并且困惑了开发者相当长一段时间。对比 etcd 的实现，可以认为 etcd 是按照 raft 状态机的模式，在 raft 节点之上构建一个数据库；而 MongoDB 其实仍然是一个传统的数据库同步模式，是一个基于数据库引擎的复制模式，这是两者之间的核心差异。</p><h2 id="Oplog-的异步复制"><a href="#Oplog-的异步复制" class="headerlink" title="Oplog 的异步复制"></a>Oplog 的异步复制</h2><p>经过上一小节的讨论，MongoDB 的复制机制并不是 etcd 的模式，而是类似 MySQL 主从复制的模式。这样就能够更加轻松地理解为什么 Oplog 采取的一种异步复制的模式。</p><img src="/images/20jq7bq4ya.png" alt="20jq7bq4ya" style="zoom: 67%;" /><p>Oplog 的异步复制是由从节点发起的，每一个从节点都会有一个特殊的线程用于从主节点拉取 Oplog，我们这里称之为拉取线程。当拉取线程只负责完成 Oplog 的复制，并写入到本地的 Collection 中，当写入完成后拉取线程就会继续向主节点请求下一批 Oplog。拉取线程在拉取 Oplog 过程中不会发生任何的阻塞。</p><p>Oplog 的重放是由重放线程来完成的，根据设置 MongoDB 中可以存在多个重放线程来加快复制速度，默认的重放线程为 16 个。重放线程实际上是在模拟客户端的请求向数据库发送命令完成数据的复制。回放线程尽量累积大量数据才回放（批量并发执行效率高）。但是如果oplog比较少，会提前返回。但是极端情况下，可能会有最多阻塞1秒的情况。</p><p>当重放线程完成重放后，会直接通知主节点自身的当前版本。心跳与版本上报是两个不同的过程，因为心跳周期两秒的间隔时间过长，如果使用心跳上报会导致客户端请求长时间被阻塞。心跳只用于无请求时的保活操作。</p><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p>MongoDB 中的选举与 raft 算法也有着一定的区别。raft 算法中由于客户端请求必须到达多数节点才能够提交，因此在选举过程中需要考虑数据一致性的问题，防止数据回滚。而 MongoDB 中，客户端操作并不会因为未到达多数节点而提交失败，只会发生超时错误（超时错误不会导致回滚），因此 MongoDB 中的选举算法主要考虑如何更快地选择数据更多更新的节点，并且尽量保证不丢失数据。</p><p>MongoDB 选举机制中比较特殊的地方在于：当选举完成后，新选举的主节点会要求所有的从节点发送自身的最近数据，并且取这些数据的并集作为集群视图，raft 协议中则是直接按照主节点的状态机作为新视图。这点不同主要是考虑到每个从节点进行 Oplog 重放的顺序可能不同，虽然 Oplog 的拉取是严格按照次数的，但是在重放过程中由于使用了多线程重放，可能会有一部分线程阻塞，发生事务提交的重排。</p><h2 id="网络分区的风险"><a href="#网络分区的风险" class="headerlink" title="网络分区的风险"></a>网络分区的风险</h2><p>当 MongoDB 复制集集群中发生主节点网络分区时，虽然集群中已经完成了选举，但主节点在当前的心跳周期仍然可以处理客户端的请求。</p><p>如果客户端的写入请求为 w:1，那么在这种情况下仍然是可以成功写入的，并且客户端并不会得到写入超时的通知，即客户端视角下无法得知异常发生，无法采取相关的异常处理操作。当主节点网络恢复后，这部分时间内发生的写请求会发生回滚，回滚的数据会被写入到回滚文件中，必须要人工进行数据维护。如果不使用高于 w:majority 的写入等级，就需要承受数据发生回滚的风险。</p><p>发生网络分区时，客户端的读请求会因为不同的  Read Peference 而发生不同的处理。在约一个心跳周期的时间范围内，MongoDB 只能够保证采取相同Read Concern 和 Read Peference 的读请求保持正确的读顺序。当Read Concern 和 Read Peference 不同时，可能会出现读请求R1读到主节点的过期数据，读请求R2 读到其他节点的正常数据，当 R2 时间早于 R1 时就会出现读操作的不安全性。 最好对相同的 Collection 采取相同的读设置来获取更一致的视图。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 无锁 Write FLow</title>
      <link href="/2022/12/26/MongoDB%20%E6%97%A0%E9%94%81Write%20FLow/"/>
      <url>/2022/12/26/MongoDB%20%E6%97%A0%E9%94%81Write%20FLow/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB-无锁-Write-FLow"><a href="#MongoDB-无锁-Write-FLow" class="headerlink" title="MongoDB 无锁 Write FLow"></a>MongoDB 无锁 Write FLow</h1><h2 id="同一-key-的无锁读写"><a href="#同一-key-的无锁读写" class="headerlink" title="同一 key 的无锁读写"></a>同一 key 的无锁读写</h2><p>MongoDB 的一个 B+树索引中具有三个数据结构来存储键值对数据：</p><ul><li>WT_ROW 数组，存储原本 Check Point 时刻的值。</li><li>WT_UPDATE 跳跃表数组，存储已有键值对的更新值。</li><li>WT_INSERT_HEAD 跳跃表数组，存储新插入键值对的更新值。</li></ul><p>MongoDB 中所有的写操作并不会直接修改原有的内存位置，而是将新数据写入到B+树索引节点中的跳跃表中。结合惰性删除机制，跳跃表是可以做到无锁读写的。</p><p>但是这种设计会使得读取的流程较长，因为要查询数据需要依次搜索WT_UPDATE，WT_ROW和WT_INSERT_HEAD 这三个数据结构，当插入数据过多时，跳跃表的搜索性能是要比 WT_ROW 的有序数组结构差的。</p><h2 id="Check-Point-技术"><a href="#Check-Point-技术" class="headerlink" title="Check Point 技术"></a>Check Point 技术</h2><p>MongoDB 中会定期对 B+ 树进行整理，防止插入数据过多，影响读取性能，Check Point 技术会定期整理内存和硬盘中的 B+树结构。</p><p>当一次 Check Point 发生后，MongoDB 将会新建一个 B+树，所有的写入操作会被转移到新的 B+树中。而所有的刷盘以及分裂操作只会影响到旧的 B+ 树。具体过程比较复杂，可以参考《MongoDB 核心原理与实践》。</p><h2 id="变长-Page-减少-B-树节点分裂"><a href="#变长-Page-减少-B-树节点分裂" class="headerlink" title="变长 Page 减少 B+ 树节点分裂"></a>变长 Page 减少 B+ 树节点分裂</h2><p>MongoDB 中的索引部分使用的是 B+ 树这种数据结构，一般来说 B+ 树在节点分裂的过程中是无法做到无锁的，但是 WiredTiger 基于变长 Page 的技术来避免 B+ 树分裂时加锁。</p><p>在数据库系统中，B+树在硬盘中的页面大小通常是硬盘扇区的大小，这主要是考虑到硬盘读写的原子性，防止破坏 B+树节点的内部结构。因为这种考虑，B+树的硬盘节点通常都比较小。而比较小的 B+树节点可能就意味着需要经常进行分裂操作来保持 B+树的平衡性。</p><p>MongoDB 的 B+ 树在内存中和在硬盘中的 page 大小是不相同的，内存中的 page 大小要远远大于硬盘中的 page 大小。当内存中的 B+树 page 需要刷盘时，会将内存 page 分裂为多个硬盘 page 写入到硬盘中，这就是变长 Page 技术。变长 Page 技术能够减少 B+ 树的持久化次数，还能够尽量避免 B+ 树因为插入而导致的分裂。引入了变长 Page 技术后，MongoDB 中索引 B+ 树的节点分裂会被转移到 reconcile 和 eviction 过程中，从而避免了在 Write Flow 中出现索引变更的情况。</p><h2 id="插入过多时小粒度分裂"><a href="#插入过多时小粒度分裂" class="headerlink" title="插入过多时小粒度分裂"></a>插入过多时小粒度分裂</h2><p>仅仅依靠变长 Page 还不能够解决所有的问题，如果在某一时刻发生大量的写入操作，导致一个B+树节点在短时间内就达到了内存 page 的上限，这种情况下依旧需要发生 B+树节点的分裂。</p><p>由于 MongoDB 中所有新插入的节点都是存在于 WT_INSERT_HEAD 跳跃表数组中的，当B+树节点因为插入数量过多需要分裂时，会将WT_INSERT_HEAD 中的最后一个跳跃表复制到新的节点中（MongoDB 中的主键值基本上是自增的，最后一个跳跃表中的节点在大部分情况下是最多的）。这种小粒度的分裂能够避免对B+树进行大面积修改。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptables 转发规则</title>
      <link href="/2022/12/26/iptables%20%E8%BD%AC%E5%8F%91%E8%A7%84%E5%88%99/"/>
      <url>/2022/12/26/iptables%20%E8%BD%AC%E5%8F%91%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Iptables-转发规则"><a href="#Iptables-转发规则" class="headerlink" title="Iptables 转发规则"></a>Iptables 转发规则</h1><p>iptables 是 linux 中的防火墙模块，用于网络包的过滤与转发，一共可以分为五链四表。</p><p><img src="/images/BD5561C0-D097-4A4F-BF4F-146FA15C46D7.jpg" alt="image">￼</p><h3 id="iptbles-的匹配规则"><a href="#iptbles-的匹配规则" class="headerlink" title="iptbles 的匹配规则"></a>iptbles 的匹配规则</h3><p>一台主机中，可能会具有多个网卡，这些网卡会有不同的网络地址，但是所有网卡会共用同一个 iptables 匹配规则，也会共用宿主机的路由转发规则。</p><p><strong>在路由选择中，只有最终判断为本地地址，如 127.0.0.1，本机的网卡地址的网络包才会被转发到 INPUT</strong>，而 docker 虚拟网卡上挂载的地址，则会被转发到虚拟网卡上，而不是直接进入INPUT 链中。注意，虚拟网卡上的转发是不经过 iptables 的，一个网络包到达 docker0 网卡后只会经过网卡的转发规则，直接被转发到对应的进程中。在进入 docker 进程后，使用的 iptables 规则和宿主机 iptables 规则是不相同的。</p><p>外部的流量在PREROUTING 链进行 DNAT 后，会根据目的网络地址来判断是否能够匹配本地路由地址，否则将会被转发到 FORWARD 链中。</p><p>内部的流量流出时，会直接根据目的地址判断是否为本地流量，如果是本地流量则不经过 OUTPUT 链，直接被转发到 INPUT 链中。<strong>这意味着 localhost 与 127.0.0.1 这两个地址是不会经过任何的DNAT 的。</strong>如果目的地址不是本机地址，那么会经过 OUTPUT 和 POSTROUTING链进行 DNAT 和 SNAT，这时候会再次通过路由表判断流量的地址转发到具体的网卡上。</p><h3 id="不容易理解的地方"><a href="#不容易理解的地方" class="headerlink" title="不容易理解的地方"></a>不容易理解的地方</h3><p>如果一个主机挂载了一个 docker0 网卡，那么 iptables 的转发规则就会稍微有些难以理解。</p><ul><li>172.0.0.x 网段不是本机的 ip 地址，因此在路由选择中不会转发给 INPUT，而是会转发给 FORWARD，然后经过 POSTROUTING，然后转发给 docker0 网卡，docker0 网卡会根据目的 ip 地址将网络包转发给虚拟机，注意此时的虚拟机收到网络包后已经不与宿主机使用同一个 iptables。</li><li>localhost 和 127.0.0.1 会经过路由选择后直接转发给 INPUT，不能够经过任何的 DNAT 修改，因此针对 localhost 的转发都是无效的。</li><li>DNAT 和 SNAT 是具有记忆性的。如果一次 tcp 中，宿主机给出流量做了 DNAT，那么收到这个 tcp 的回包时，将会自动进行反操作，因此 docker 中的虚拟容器只需要一次 DNAT 就可以访问外界流量了。</li></ul><h3 id="如何做-NAT-转换"><a href="#如何做-NAT-转换" class="headerlink" title="如何做 NAT 转换"></a>如何做 NAT 转换</h3><p>1、首先需要开启端口转发<br>2、<code> sudo iptables -t nat -A PREROUTING -d x.x.x.x -p tcp -dport x -j DNAT --to-destinaton x.x.x.x:x</code></p><p>3、<code> sudo iptables -t nat -A POSTROUTING -d x.x.x.x -p tcp -dport x -j SNAT --to-source x.x.x.x</code></p><p>4、需要在 FORWARD 链中放行流量，例如</p><p><code>sudo iptables -A FORWARD  -i eth0 -o eth0 -j ACCEPT</code></p><p>5、如果只需要在本主机进行端口转换，则应该使用重定向来代替</p><p><code>sudo iptables -t nat -A PREROUTING -d 127.0.0.1 -dport x -j REDIRECT to-ports x</code></p><h3 id="利用-string模块完成应用层过滤"><a href="#利用-string模块完成应用层过滤" class="headerlink" title="利用 string模块完成应用层过滤"></a>利用 string模块完成应用层过滤</h3><p>iptables 的 string 模块可以将网络包中的关键词进行匹配，从而实现禁止访问某些 url，禁止访问某些内容，或者禁止回复某些内容的效果。具体代码如下：</p><p><code>sudo iptables -t filter INPUT -m string --algo bm --string &#39;sf&#39; -j DROP</code></p><p>但是，iptables 不能够确定字符串出现的位置，因此可能会出现误伤的情况。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s proxy 网络模型</title>
      <link href="/2022/12/25/k8s-proxy-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/12/25/k8s-proxy-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="k8s-proxy-网络模型"><a href="#k8s-proxy-网络模型" class="headerlink" title="k8s proxy 网络模型"></a>k8s proxy 网络模型</h1><h3 id="iptables-模式"><a href="#iptables-模式" class="headerlink" title="iptables 模式"></a>iptables 模式</h3><p><img src="/images/DF43002E-5DBE-415E-94FB-6505B66D850A.jpg" alt="image">￼</p><p>注意，所有的k8s 标记只分为两种，一种是需要转发的标记0x400，一种是需要丢弃的标记0x800。前者会最终在 POST 中被转发。</p><p>下面解释一下为什么会有需要丢弃的数据包。由于规则链的建立并不是原子性的，所以可能会出现一种情况，规则链建立一半时，已经有相关的数据包到达了——这是一个非常危险的情况，可能会导致一些未定义的行为。因此，在规则正在建立的过程中，需要将相关数据包标记为 0x800，并最终丢弃掉。也就是 0x800 是用于标识规则链是否完全建立的。</p><p>另外一种情况是按照用户的需求，对一些虚拟容器进行隔离操作。</p><h3 id="iptables-clusterIP访问模式"><a href="#iptables-clusterIP访问模式" class="headerlink" title="iptables - clusterIP访问模式"></a>iptables - clusterIP访问模式</h3><p>这种访问模式一般是用于访问启动了多个实例的服务，并且需要进行负载均衡。客户端访问的链路可以表示为：</p><p>PREROUTING -&gt; KUBE-SERVICE -&gt; KUBE-SVC-SERV -&gt; KUBE-SEP-POD</p><p>​    所有外部流量都会被 KUBE-SERVICE 链截获，并检查是否有流量是流向某一clusterIP的，并将流量传递给对应的 KUBE-SVC-SERV。KUBE-SVC-SERV 根据设置的负载均衡算法，将流量转发给对应的 KUBE-SEP-POD 链，并最终在该链中进行 DNAT 处理。</p><h3 id="iptables-NodePort-访问模式"><a href="#iptables-NodePort-访问模式" class="headerlink" title="iptables - NodePort 访问模式"></a>iptables - NodePort 访问模式</h3><p>这种方式通常用来访问单独启动的服务实例。客户端的访问链路可以表示为：</p><p>PREROUTING -&gt; KUBE-SERVICE -&gt; KUBE-NODEPORTS -&gt; KUBE-SVC-XXX -&gt; KUBE-SEP-XXX</p><p>单独启动的服务实例会单独注册在 KUBE-SERVICE链中，当clusterIP匹配完成后，才会进行 NodePort 规则匹配。<strong>使用 nodePort 方式来访问一个容器，其转发链路要更长，因此性能要稍差。</strong></p><h3 id="ipvs-模式"><a href="#ipvs-模式" class="headerlink" title="ipvs 模式"></a>ipvs 模式</h3><p><img src="/images/71E894A0-C367-4B4F-A7DE-FF0275149CD4.jpg" alt="image">￼<br>ipvs 因为继承了 lvs 模块，所以其实是更加简单的。只需要在流量入口处进行流量区分和标记就可以。客户端进行访问的链路可以表示为：</p><p>PREROUTING -&gt; KUBE-SERVICES -&gt; KUBE-CLUSTER-IP -&gt; INPUT -&gt; KUBE-FIREWALL -&gt; POSTROUTING</p><p>或者为：</p><p>PREROUTING –&gt; KUBE-SERVICES –&gt; KUBE-NODE-PORT –&gt; INPUT –&gt; KUBE-FIREWALL –&gt; POSTROUTING</p><ul><li>KUBE-SERVICES 链负责劫持所有的流量，进行粗删选，根据主机所设置的网段号来初步判断流量目标是否是k8s 服务。</li><li>KUBE-CLUSTER-IP 负责第二次筛选，将网段正确的流量匹配ipset集合，如果通过集合，则标记为0x2000，如果失败则标记为0x4000。</li><li>如果 KUBE-SERVICES 链没有通过筛选，则进入 KUBE-NODE-PORT 链中，判断是否是单独开启的服务实例。</li><li>INPUT 与 KUBE-FIREWALL：判断是否有标记为 0x4000 的流量，如果有，直接丢弃。</li><li>IPVS 与 POSTROUTING：将通过匹配的流量通过 nat 的方式转发到负载均衡算法计算后的地址。使用 nat 是因为可以很好地进行端口映射，这样会使得调度机制更加灵活，</li></ul>]]></content>
      
      
      <categories>
          
          <category> 云技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ipvs </tag>
            
            <tag> iptables </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 网络模型</title>
      <link href="/2022/12/25/Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/12/25/Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-网络模型"><a href="#Docker-网络模型" class="headerlink" title="Docker 网络模型"></a>Docker 网络模型</h1><p>Docker 容器为了实现网络隔离，可以看作连接在不同虚拟网卡上的主机。网络隔离的基本需求是不同虚拟主机直接网络不能够互通，虚拟主机可以访问外部设备，而外部设备不能够直接访问虚拟主机，只能够通过端口来访问。</p><h3 id="根据链来分"><a href="#根据链来分" class="headerlink" title="根据链来分"></a>根据链来分</h3><ul><li>FORWARD 拦截所有非本地流量，所有 docker 流量都被包含在这里。下图，ISO 是隔离不同网桥之间的互相访问。由于已经过滤掉了不同隔离网络之间的访问，所以 docker 链中是接受所有外界的流量到 docker 网卡中。再往下两条是允许虚拟网卡流量流向主机外部和网卡本身。<br><img src="/images/25044E49-54B6-443E-AD9D-28A50BA05F43.jpg" alt="image">￼</li><li>OUTPUT 和PREROUTING链则是截获所有本地非容器流量，他们都公用 DOCKER 链，如果发现是要访问host:port，将其 DNAT 到对应的容器地址。<br><img src="/images/46722EDA-E303-4193-BA0E-FFF224792801.jpg" alt="image">￼</li><li>POSTROUTING 链是将所有容器访问主机外的流量，伪装成本地流量。<br><img src="/images/FCF35C50-9952-49CA-8613-306460E4EE80.jpg" alt="image">￼</li></ul><h3 id="单机网桥模式"><a href="#单机网桥模式" class="headerlink" title="单机网桥模式"></a>单机网桥模式</h3><p>单机网桥模式是没有指定任何网络选项的容器，假设容器的虚拟 ip 为 172.10.0.x，由于该网段宿主机并没有暴露给外界，因此外界无法访问容器。但有一种例外情况，就是外界主机通过修改路由表强行将 172.10.0.x 的流量转发给宿主机。这样流量在到达宿主机后是可以匹配到一条路由规则的，从而实现外界流量访问虚拟容器。</p><p>容器内部的出流量在宿主机的 POST 链做了 MASQUERADE 处理，所以可以访问外界。假设容器的虚拟 ip 为 172.10.0.x，容器所有的出流量都会经过宿主机的 OUTPUT 和 POSTROUTING 链后选择合适的网卡进行转发。根据 docker 设置的 iptables 规则，所有出流量在 POSTROUTING 链经过 MASQUERADE 的 SNAT 伪装成为宿主机流量。tcp 回路的时候，宿主机会发现该数据包经历过 SNAT 规则转发，自动将回包的地址修改为 172.10.0.x，经过本地的路由规则转发到 docker0 网桥后就可以发送给对应的虚拟容器。</p><h3 id="网桥模式"><a href="#网桥模式" class="headerlink" title="网桥模式"></a>网桥模式</h3><p>网桥模式即使用 -p 选项进行端口映射来启动的容器。单机网桥模式会复用主机端的端口，外部流量通过宿主机的 ip 地址加对应的端口号来访问虚拟容器。因此流量只要是到达主机的对应端口，就默认一定是访问主机端的服务。只用端口来判断流量是否走向 docker 容器就可以了。</p><ul><li>外部流量入：外部流量需要走 PREROUTING-FORWARD-POSTROUTIN 链，外部流量的网卡是除了docker自带的网卡之外的所有网卡。所以这些流量都需要在 PREROUTING 做 DNAT 处理，将流量的目的地址修改为 docker 容器的网段。</li><li>经过 DNAT 后，宿主机发现流量流向地址不是本地应用，转发到 FORWARD 和 POSTROUTING，并且根据路由表转发到容器对应的虚拟网卡里面。</li><li>内部流量出：docker 容器出流量也是宿主机应用出流量，所以会从 docker 虚拟网卡发送到 OUTPUT 链，需要在 OUTPUT 链中进行 MASQUERADE 将发送到外部的流量全部 SNAT 为宿主机的地址；此外，还要将发送给本机暴露出的端口也进行 SNAT 处理，即自访问。</li><li>不同网桥之间的隔离操作：一个网桥发送给其他网桥的流量不会 SNAT 和 DNAT，会被直接发送到虚拟网卡上。虚拟网卡的入链同样会走 PRE 链，检测到是虚拟网卡流量，直接不进行操作。放行到 FORWARD，检测到不同网桥之间的相互访问，由 ISO1 截获，由 ISO2 丢弃。</li><li>用户安全性操作：所有外部流量在截获前，都会被DOCKER-USER 链截获，用户需要将自己的链接入 DOCKER-USER 链中。</li></ul><p>网桥模式中，主要是通过匹配端口号来实现外部流量的转发的，内部流量的流出过程与单机网桥模式是相同的。除此此外，网桥模式下还需要对不同 docker 网络段之间的流量进行隔离操作，防止没有连接的两个虚拟网络段之间相互通信。</p><h3 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h3><p>对于使用了 network 选项启动的容器，docker 会自动使用 127.0.0.11 来创建一个 DNS 服务器，所有 docker 创建出的进程会使用该地址作为默认的 DNS 服务器。并且每一个服务名都会作为一个域名进行注册。该内嵌的 DNS 服务器会根据容器的网段地址来进行选择性查询，从而来实现不同网络驱动之间的域名隔离。</p><h3 id="ROUTING-MESH模式"><a href="#ROUTING-MESH模式" class="headerlink" title="ROUTING MESH模式"></a>ROUTING MESH模式</h3><p>该模式的意思是，从任何一个宿主机上暴露端口访问，都可以被负载均衡到任一台宿主机的容器上。</p><p><img src="/images/F0FC6715-47DA-4E75-AB35-A856B43431AA3.jpg" alt="image">￼</p><ul><li>外部流量入口：所有的外部流量都会被 PREROUTING 中的 DOCKER-INGRESS 链截获。如果流量目标端口是一个使用 overlay 网络模式的容器，那么该流量会被捕获到 172.18.0.2 容器中。</li><li>ingress-sbox：用来进行第二步iptables 流量控制。这里是通过mark+ipvs的方式来完成的，ipvs 的 vip 被绑定到overlay-bridge上。FORWARD 和 INPUT 链都会对不同端口数据包进行不同的标记，当数据包通过 INPUT 进入ipvs的vip 时，根据不同的标记进行负载均衡。</li><li>目标容器：直接对流量进行处理。</li><li>容器流量出口：vxlan 流量出来经过容器后，会经重定向发送到挂在宿主机的虚拟网卡。此时，网卡会被 OUTPUT链截获，如果发现是发送给 overlay 网络的流量，则会被 DNAT 到 ingress-box中。注意，docker_gwbridge 没有做外部 DNAT，无法被外部访问。</li><li>以上是实现了overlay网络与普通网络流量之间的隔离。这个隔离是使用一个容器来完成的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 云技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> ipvs </tag>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis与限流算法</title>
      <link href="/2022/12/25/redis%E4%B8%8E%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
      <url>/2022/12/25/redis%E4%B8%8E%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="redis与限流算法"><a href="#redis与限流算法" class="headerlink" title="redis与限流算法"></a>redis与限流算法</h1><p>由于 Web 应用在部署时，常常使用多网关，微服务的组织形式，因此经常需要在进程间进行数据交换，从而达到更好的限流效果。由于限流算法中的数据具有很强的时效性，并且不需要较高的安全性，使用 redis 组件来实现限流算法是一个很好的选择。</p><p>常见的限流算法一共有四种：固定窗口，滑动窗口，桶漏算法，令牌桶。这些算法具有一定的复杂度，需要借助 redis 中的 lua 脚本来实现。</p><h2 id="固定窗口"><a href="#固定窗口" class="headerlink" title="固定窗口"></a>固定窗口</h2><p>每个请求到达时，检查是否具有窗口存在，如果无窗口存在，则将创建窗口并且设置过期时间、允许通过的流量。此后，每一个请求到达时，如果窗口存在，都将流量-1，如果不能够完成操作，则需要等待。优点是性能比较好，实现简单，缺点是精度不够高，这个适合作为每一个用户的限流次数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- Check whether a single user reaches the traffic limit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;exists&quot;</span>,key) == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&quot;set&quot;</span>,key,<span class="number">10</span>,<span class="string">&quot;EX&quot;</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> count = <span class="built_in">tonumber</span>(redis.call(<span class="string">&quot;decr&quot;</span>,key))</span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口是固定窗口的一种优化，它将窗口改变为一个链表，如将一分钟划分为 6 段，每一段代表十秒钟。每个请求到达时，先检查所有窗口是否过期，如果过期则删除窗口，并且检查最后一个窗口的创建时间，如果窗口超过 10s，那么在其后面写入多个窗口，并在最后一个窗口处写入值。滑动窗口同样适合作为每一个用户的限流算法。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--获取KEY</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">--获取ARGV内的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 缓存时间</span></span><br><span class="line"><span class="keyword">local</span> expire = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 当前时间</span></span><br><span class="line"><span class="keyword">local</span> currentMs = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="comment">-- 最大次数</span></span><br><span class="line"><span class="keyword">local</span> count = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"><span class="comment">--窗口开始时间</span></span><br><span class="line"><span class="keyword">local</span> windowStartMs = currentMs - expire * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">--获取key的次数</span></span><br><span class="line"><span class="keyword">local</span> current = redis.call(<span class="string">&#x27;zcount&#x27;</span>, key, windowStartMs, currentMs)</span><br><span class="line"></span><br><span class="line"><span class="comment">--如果key的次数存在且大于预设值直接返回当前key的次数</span></span><br><span class="line"><span class="keyword">if</span> current <span class="keyword">and</span> <span class="built_in">tonumber</span>(current) &gt;= count <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tonumber</span>(current);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清除所有过期成员</span></span><br><span class="line">redis.call(<span class="string">&quot;ZREMRANGEBYSCORE&quot;</span>, key, <span class="number">0</span>, windowStartMs);</span><br><span class="line"><span class="comment">-- 添加当前成员</span></span><br><span class="line">redis.call(<span class="string">&quot;zadd&quot;</span>, key, <span class="built_in">tostring</span>(currentMs), currentMs);</span><br><span class="line">redis.call(<span class="string">&quot;expire&quot;</span>, key, expire);</span><br><span class="line"></span><br><span class="line"><span class="comment">--返回key的次数</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">tonumber</span>(current)</span><br></pre></td></tr></table></figure><h2 id="桶漏算法"><a href="#桶漏算法" class="headerlink" title="桶漏算法"></a>桶漏算法</h2><p>记录每一个请求，并且将其放入缓冲区中，缓冲区具有上限，如果超出缓冲区则直接拒绝。每隔设置的时间间隔，会从缓冲区中选取设置数量的请求进行处理。优点是请求处理非常平滑，缺点是不能够应对突发请求。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 1 代表成功，0 代表失败</span></span><br><span class="line"><span class="keyword">local</span> capacity = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">local</span> acquire = <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>])</span><br><span class="line"><span class="keyword">local</span> water = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;hget&#x27;</span>, KEYS[<span class="number">1</span>] , KEYS[<span class="number">2</span>]) <span class="keyword">or</span> <span class="number">0</span>) </span><br><span class="line"><span class="keyword">local</span> <span class="built_in">time</span> = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;hget&#x27;</span>, KEYS[<span class="number">1</span>] , KEYS[<span class="number">3</span>]) <span class="keyword">or</span> now) </span><br><span class="line">water = <span class="built_in">math</span>.<span class="built_in">max</span>(<span class="number">0</span>, water - (now - <span class="built_in">time</span>) * rate)</span><br><span class="line">redis.call(<span class="string">&#x27;hset&#x27;</span> , KEYS[<span class="number">1</span>] ,KEYS[<span class="number">3</span>] , now)</span><br><span class="line"><span class="keyword">if</span> (water + acquire &lt;= capacity) <span class="keyword">then</span></span><br><span class="line">  redis.call(<span class="string">&#x27;hset&#x27;</span> , KEYS[<span class="number">1</span>] , KEYS[<span class="number">2</span>] , water + acquire)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><p>桶漏算法的相反操作。每隔一段时间，将名额放入缓冲区中，名额具有上限，每一个请求需要拿到一个名额，否则会被拒绝处理。令牌桶算法允许的瞬时压力是桶上限+ 定时刷新名额，持续压力是定时刷新的名额。允许一定突发压力出现。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- @param key 令牌的唯一标识</span></span><br><span class="line"><span class="comment">--- @param permits  请求令牌数量</span></span><br><span class="line"><span class="comment">--- @param curr_mill_second 当前时间</span></span><br><span class="line"><span class="comment">--- 0 没有令牌桶配置；-1 表示取令牌失败，也就是桶里没有令牌；1 表示取令牌成功</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">acquire</span><span class="params">(key,  permits, curr_mill_second)</span></span></span><br><span class="line">    <span class="keyword">local</span> local_key =  key <span class="comment">--- 令牌桶key ,使用 .. 进行字符串连接</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tonumber</span>(redis.<span class="built_in">pcall</span>(<span class="string">&quot;EXISTS&quot;</span>, local_key)) &lt; <span class="number">1</span> <span class="keyword">then</span> <span class="comment">--- 未配置令牌桶</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">--- 令牌桶内数据：</span></span><br><span class="line">    <span class="comment">---             last_mill_second  最后一次放入令牌时间</span></span><br><span class="line">    <span class="comment">---             curr_permits  当前桶内令牌</span></span><br><span class="line">    <span class="comment">---             max_permits   桶内令牌最大数量</span></span><br><span class="line">    <span class="comment">---             rate  令牌放置速度</span></span><br><span class="line">    <span class="keyword">local</span> rate_limit_info = redis.<span class="built_in">pcall</span>(<span class="string">&quot;HMGET&quot;</span>, local_key, <span class="string">&quot;last_mill_second&quot;</span>, <span class="string">&quot;curr_permits&quot;</span>, <span class="string">&quot;max_permits&quot;</span>, <span class="string">&quot;rate&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> last_mill_second = rate_limit_info[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">local</span> curr_permits = <span class="built_in">tonumber</span>(rate_limit_info[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">local</span> max_permits = <span class="built_in">tonumber</span>(rate_limit_info[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">local</span> rate = rate_limit_info[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">--- 标识没有配置令牌桶</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(max_permits) == <span class="string">&#x27;boolean&#x27;</span> <span class="keyword">or</span> max_permits == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">   <span class="comment">--- 若令牌桶参数没有配置，则返回0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(rate) == <span class="string">&#x27;boolean&#x27;</span> <span class="keyword">or</span> rate == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> local_curr_permits = max_permits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">--- 令牌桶刚刚创建，上一次获取令牌的毫秒数为空</span></span><br><span class="line">    <span class="comment">--- 根据和上一次向桶里添加令牌的时间和当前时间差，触发式往桶里添加令牌，并且更新上一次向桶里添加令牌的时间</span></span><br><span class="line">    <span class="comment">--- 如果向桶里添加的令牌数不足一个，则不更新上一次向桶里添加令牌的时间</span></span><br><span class="line">    <span class="comment">--- ~=号在Lua脚本的含义就是不等于!=</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">type</span>(last_mill_second) ~= <span class="string">&#x27;boolean&#x27;</span>  <span class="keyword">and</span> last_mill_second ~= <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span>(curr_mill_second - last_mill_second &lt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="comment">--- 生成令牌操作</span></span><br><span class="line">        <span class="keyword">local</span> reverse_permits = <span class="built_in">math</span>.<span class="built_in">floor</span>(((curr_mill_second - last_mill_second) / <span class="number">1000</span>) * rate) <span class="comment">--- 最关键代码：根据时间差计算令牌数量并匀速的放入令牌</span></span><br><span class="line">        <span class="keyword">local</span> expect_curr_permits = reverse_permits + curr_permits;</span><br><span class="line">        local_curr_permits = <span class="built_in">math</span>.<span class="built_in">min</span>(expect_curr_permits, max_permits);  <span class="comment">--- 如果期望令牌数大于桶容量，则设为桶容量</span></span><br><span class="line">        <span class="comment">--- 大于0表示这段时间产生令牌，则更新最新令牌放入时间</span></span><br><span class="line">        <span class="keyword">if</span> (reverse_permits &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            redis.<span class="built_in">pcall</span>(<span class="string">&quot;HSET&quot;</span>, local_key, <span class="string">&quot;last_mill_second&quot;</span>, curr_mill_second)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        redis.<span class="built_in">pcall</span>(<span class="string">&quot;HSET&quot;</span>, local_key, <span class="string">&quot;last_mill_second&quot;</span>, curr_mill_second)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="comment">--- 取出令牌操作</span></span><br><span class="line">    <span class="keyword">local</span> result = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> (local_curr_permits - permits &gt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        redis.<span class="built_in">pcall</span>(<span class="string">&quot;HSET&quot;</span>, local_key, <span class="string">&quot;curr_permits&quot;</span>, local_curr_permits - permits)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        redis.<span class="built_in">pcall</span>(<span class="string">&quot;HSET&quot;</span>, local_key, <span class="string">&quot;curr_permits&quot;</span>, local_curr_permits)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="四种算法对比"><a href="#四种算法对比" class="headerlink" title="四种算法对比"></a>四种算法对比</h2><ul><li><p>固定窗口：不需要定时维护，实现非常简单，单个用户限流</p></li><li><p>滑动窗口：可以在用户请求线程中维护，精度需求较高的单个用户限流</p></li><li><p>桶漏算法：一般用于保护数据库等后端系统不会被突发压力击溃。</p></li><li><p>令牌桶：一般用于统一网关的限流，允许合理范围内应对突发压力。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 两次挥手？记录一次抓包异常</title>
      <link href="/2022/12/25/TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B%E2%80%94%E2%80%94%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%8A%93%E5%8C%85%E5%BC%82%E5%B8%B8/"/>
      <url>/2022/12/25/TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B%E2%80%94%E2%80%94%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%8A%93%E5%8C%85%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-两次挥手？记录一次抓包异常"><a href="#TCP-两次挥手？记录一次抓包异常" class="headerlink" title="TCP 两次挥手？记录一次抓包异常"></a>TCP 两次挥手？记录一次抓包异常</h1><h2 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h2><p>我们都知道，正常的 TCP 关闭连接时是需要发生四次挥手的。但是在 wireshark 的一次抓包过程中，我却偶然发现了有一个 tcp 连接只发生了两次挥手，即客户端发送了 FIN 报文，并且收到了服务端的 ACK 报文，但是服务端却没有继续发送 FIN 报文，本次异常断开的抓包结果如下，图中的 192.168.10.1 是某经过系统刷机的路由器：</p><p><img src="/images/image-20221225152318823.png" alt="img"></p><p>这其实是由于服务端在收到客户端的关闭请求后，并没有使用系统调用 shutdown 或者 close 来对 tcp 通道进行关闭，导致这时的 tcp 连接变成了一个半双工的状态，即服务端仍然保持写入状态（虽然并没有数据需要写入)。这里可能是路由器的 http 服务中忘记对客户端连接进行关闭所导致的一次 tcp 异常断开。</p><h2 id="孤儿-socket-在-tcp-挥手的作用"><a href="#孤儿-socket-在-tcp-挥手的作用" class="headerlink" title="孤儿 socket 在 tcp 挥手的作用"></a>孤儿 socket 在 tcp 挥手的作用</h2><p>在本次的 tcp 连接断开异常后，如果服务端还有数据需要写入，但是此时客户端中的浏览器已经关闭，这种情况下操作系统是如何处理的呢？</p><p>这里需要提到一个概念：孤儿 socket。这是 socket 的一个特殊的状态，该状态下用户进程不再继续对 socket 持有，不进行写入和读取操作，但是 socket 仍未完成 tcp 的四次挥手，这时系统栈中仍然会保留该 socket 的资源来进行 tcp 挥手操作。孤儿 socket 的引入就是为了解决 tcp 连接不能够正常断开的情况的。在孤儿 socket 的引入后，一次 tcp 挥手的流程可以分为不同的情况：</p><p>不优雅的 tcp 关闭（一）：客户端直接调用 close</p><ul><li>客户端需要关闭连接时，直接使用 close 系统调用，发送一个 FIN 报文，此后 socket 资源栈全部由系统负责（孤儿 socket）。</li><li>服务端接收到 FIN 报文，并回复 ACK 报文，若此时服务端无数据需要写入，则再发送一个 FIN，接收到 ACK 后 socket 正常释放。</li><li>若服务端接收到 FIN 报文后，仍然需要写入数据，由于对端已经全双工关闭，无法接受到数据，此时对端的操作系统协议栈在收到数据后会给服务端发送 RST 报文，提醒对端协议栈进行关闭。此时进程继续写入数据会收到一个 EOF 提醒，进程必须放弃写入，否则继续写入将会收到一个 SIGPIPE 信号。</li></ul><p>不优雅的 tcp 关闭（二）：客户端进程崩溃</p><ul><li>客户端进程崩溃会导致服务端进程不会收到任何 FIN 报文，此时的客户端 socket 同样是一个孤儿 socket。</li><li>客户端进程崩溃的情况下，系统的协议栈会自动给对方发送 RST 报文来重置连接。</li></ul><p>优雅的 tcp 关闭：使用 shutdown 进行关闭</p><ul><li>客户端需要关闭连接时，使用 shutdown 关闭写入端，使 tcp 成为半双工状态，向对方发送 FIN 报文。</li><li>服务端接收到 FIN 报文，回复 ACK 报文，在完成写入后使用 close 或 shutdown 系统调用关闭连接，发送 FIN 报文。</li><li>客户端接收到 FIN 报文并且回复一个 ACK 报文。</li></ul><h2 id="HTTP-重定向"><a href="#HTTP-重定向" class="headerlink" title="HTTP 重定向"></a>HTTP 重定向</h2><p>如果仔细看上述的抓包结果，可以注意到当客户端收到一个 HTTP 302 报文后，客户端会主动关闭 tcp 连接，并且重启一个新的 tcp 连接来访问重定向后的 url。这是因为重定向后的结果可能在一个新的 host 下，所以旧连接不一定可用，重新启动一个 tcp 连接更加安全。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> tcp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>首页</title>
      <link href="/2022/12/25/%E9%A6%96%E9%A1%B5/"/>
      <url>/2022/12/25/%E9%A6%96%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p>欢迎访问我的个人博客，博客主要记录本人日常学习内容，并且提供本人所写工程的文档。</p><h2 id="工程文档链接"><a href="#工程文档链接" class="headerlink" title="工程文档链接"></a>工程文档链接</h2><ul><li><p>MVCC：一个基于跳跃表的进程内并发读写数据结构。 <a href="https://github.com/tangrc99/MVCC">github仓库</a> <a href="https://tangrc99.github.io/MVCC">项目文档链接</a></p></li><li><p>Gossip：一个基于 gossip 协议的分布式信息交互组件。<a href="https://github.com/tangrc99/Gossip">github仓库</a> <a href="https://tangrc99.github.io/Gossip">项目文档链接</a></p></li><li><p>MLog：一个仿照 WiredTiger 日志系统的玩具项目。<a href="https://github.com/tangrc99/MLog">github仓库</a> <a href="https://tangrc99.github.io/MLog">项目文档链接</a></p></li><li><p>TinySwarm：一个轻量级的分布式调度系统。 <a href="https://github.com/tangrc99/TinySwarm">github仓库</a> <a href="https://tangrc99.github.io/TinySwarm">项目文档链接</a></p></li><li><p>MemTable：使用 go 语言仿写的 redis 服务器。  <a href="https://github.com/tangrc99/MemTable">github仓库</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis 为什么那么快</title>
      <link href="/2022/12/23/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB/"/>
      <url>/2022/12/23/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-为什么那么快"><a href="#Redis-为什么那么快" class="headerlink" title="Redis 为什么那么快"></a>Redis 为什么那么快</h1><p>Redis 的速度为什么那么快？这个问题有点过于宽泛了，必须要确定 redis 的比较对象才方便进行比较。对比传统的硬盘数据库来说，redis 的读写操作大部分都只发生在内存中，不需要昂贵的硬盘 IO；对比较为新型的 NoSQL 数据库而言，这些数据库如 MongoDB 虽然也大量利用了内存缓存，但相比之下，redis 单索引、不保证数据安全性的特点使得 redis 的读写 flow 更加短，因此能够取得更好的效果；相比于同类型的缓存服务，如 memcached，redis 的速度其实并没有太大的优势，这是 redis 的单线程事务模型带来的缺点。</p><h2 id="高效的数据结构"><a href="#高效的数据结构" class="headerlink" title="高效的数据结构"></a>高效的数据结构</h2><p>redis 是一个基于内存的数据库，因而可以使用更加高效灵活的数据结构——哈希表。由于哈希表的查询时间复杂度为 O(1)，在千万级别的数据量下，单次查询性能仍然能够保持在 us 级别。</p><h2 id="高效的网络-IO-模型"><a href="#高效的网络-IO-模型" class="headerlink" title="高效的网络 IO 模型"></a>高效的网络 IO 模型</h2><p>最新版本的 redis 中，网络 IO 线程与事件处理线程是分离的，是一个非标准的 reactor 模式。这种非标准的设计主要是考虑了复杂度问题，如果使用多线程进行事务处理需要付出高昂的工程代价，并且只能够获得大概 8%左右的性能提升（参考 memcached 与 redis 的性能测试对比）。</p><p>在引入多线程 IO 后，仍然只有主线程是负责 epoll 的逻辑的，流程可以简述如下：</p><p>1、主线程负责接收建立连接请求，获取 socket 放入全局等待读处理队列<br>2、主线程处理完读事件之后，通过 RR(Round Robin) 将这些连接分配给这些 IO 线程<br>3、主线程阻塞等待 IO 线程读取 socket 完毕<br>4、主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行<br>5、主线程阻塞等待 IO 线程将数据回写 socket 完毕<br>6、解除绑定，清空等待队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> 有可读 socket&#123;</span><br><span class="line">    平均分配 socket 给 IO 线程组</span><br><span class="line">  &#125;</span><br><span class="line">  等待所有 IO 线程组读取完成</span><br><span class="line">  </span><br><span class="line">  按照次序执行所有的 IO 请求</span><br><span class="line">    </span><br><span class="line">  等待所有 IO 线程组写入完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO 线程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  </span><br><span class="line">  等待主线程分配 IO 读事件</span><br><span class="line">  </span><br><span class="line">  通知主线程读取完成（原子操作）</span><br><span class="line">    </span><br><span class="line">  等待主线程分配 IO 读事件</span><br><span class="line">  </span><br><span class="line">  通知主线程写入完成（原子操作）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis 这里的 IO 事件是按组进行的，主线程会阻塞等待一组中所有的 IO 事件读或者写完成。这里主要是为了防止事件乱序执行，否则可以等待单个 IO 完成后就执行任务。由于 IO 过程非常快，所以这里的性能损耗基本可以忽略不计。</p><h2 id="成熟的事件调度机制"><a href="#成熟的事件调度机制" class="headerlink" title="成熟的事件调度机制"></a>成熟的事件调度机制</h2><p>redis 的事件主要可以分为 IO 事件、定时事件、后台线程事件这三种，主循环只负责处理 IO 事件和定时事件，这两种事件的处理速度较快因而可以放在一起处理。</p><p>在 redis 的主循环处理流程伪代码可以表示如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">最大等待时间 = 最近定时任务 - 当前时间</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 有IO事件可以处理 &#123;</span><br><span class="line"><span class="keyword">if</span> IO为轻量级任务</span><br><span class="line">    处理 IO 事件</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    放入后台线程处理</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">休眠最大等待时间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 有定时任务可以处理</span><br><span class="line">处理定时任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我接触到 redis 比较早，在初学时比较困惑，为什么这种循环处理的逻辑能够保证客户端请求的高效处理，并且如何保证定时任务及时处理的。</p><p>首先说明如何保证定时任务的处理。在主循环处理流程中，IO 事件即客户端请求事件是优先处理的，并不保证定时事件一定能够及时处理，但是这种延迟是非常细微的。以 <code>std::unordered_map</code> 为例，在 1000W 级别的数据中，平均的单条读取时间是 1us 级别的，因此单个 IO 事件即使是计算了读取和写入 socket 所耗费的时间，通常也是不足 1ms 的，只会是 10 us 级别。在这种操作速度的数量级下，即使是同一时间到达万级请求，也不会对定时任务造成秒级别的延迟，这是完全可以接受的。另外，受限于物理机器的网卡速度、协议栈复制速度等因素，一次主循环中并不会到达过多的请求。因此，完全不必担心定时任务会因为短时间内出现大量 IO 请求而延迟较大。</p><p>既然用户 IO 请求不会过多影响定时任务的触发时机，那么定时任务显然也不会影响到 IO 事件的处理。redis 中的定时任务基本上可以分为以下几种：</p><ul><li>过期键的删除操作</li><li>更新服务器状态</li><li>清理过期和失效的客户端</li><li>尝试开始持久化操作</li><li>与其他服务器同步消息</li></ul><p>redis 中这些定时任务的执行时间通常更短，因为任务所查询的数据量级是远远小于 redis 数据库的数据量级的，并且 redis 内部具有计时机制来主动防止定时任务消耗过多时间。这些定时任务会每隔 100ms 执行一次，每次的总执行时间在 ms 级别，不会对客户端请求造成很大的延迟。</p><p>归根结底，redis 采用的这种事件循环调度机制，是考虑到单个事件的执行时间非常短，这主要还是由于所有的操作都只与内存进行交互，现代计算机的内存速度是非常快的。</p><h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><p>redis 中比较重量级的事件会考虑放入到后台线程中来完成，防止主循环的单次循环时间过长，使客户端请求延迟增加。会放入到后台线程中的事件主要有：</p><ul><li>大键的惰性删除</li><li>AOF 持久化刷盘</li><li>关闭 file descriptor</li></ul><p>这些事件在执行过程中，可能产生的耗时是毫秒级别的，与其他的事件的时间相差过大，直接在主线程中执行可能会造成循环时间过长。</p><p>redis 中是通过队列的方式来实现主线程与后台线程之间的任务分配的，以上三个事件都有各自的队列，这是为了防止某一个类型的后台任务过多，从而阻塞了其他种类任务的执行。每次后台线程选择任务执行时会采用一定的策略公平公正地对三种任务执行，防止某一种事件过长时间无法执行。</p><h2 id="合适的高可用架构"><a href="#合适的高可用架构" class="headerlink" title="合适的高可用架构"></a>合适的高可用架构</h2><p>redis 官方提供了哨兵模式的高可用架构，这是一个比较松散的高可用方案。相比于 etcd、MongoDB 中的高可用实现，redis 的哨兵模式会舍弃一部分的数据安全性来换取更高的性能。</p><p>哨兵模式其本质上是一个能够自动切换节点的主从复制结构。同其他数据库的主从复制结构类似，redis 中的主从复制也是异步复制的过程。异步复制的好处是性能较高，不会过多影响主节点的吞吐量，这正是 redis 所需要的，但缺点就是会带来数据延迟，当主节点下线可能会造成一部分数据的丢失。但由于 redis 所存储的数据本身不需要过高的安全性，所以 redis 完全可以舍弃一部分安全性来换取更高的吞吐量。并且这种因主节点下线造成的数据丢失数量是非常少的。</p><p>如果引入 raft、paxos 等选举算法，虽然能够保证更高的可用性，但是会造成非常严重的性能劣化。想象一下，引入这些选举算法，所有的客户端请求相当于是一个 2pc，需要引入主节点-从节点的通信延迟、从节点提交的延迟，这里性能可能会折半甚至更低。这就是为什么 redis 并没有引入选举算法——一切为了性能。</p><p>哨兵模式的高可用体现在，故障自动恢复的容灾而不是数据一致性的保障。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>etcd 设计亮点与工程优化</title>
      <link href="/2022/12/13/ETCD%20%E8%AE%BE%E8%AE%A1%E4%BA%AE%E7%82%B9%E4%B8%8E%E5%B7%A5%E7%A8%8B%E4%BC%98%E5%8C%96/"/>
      <url>/2022/12/13/ETCD%20%E8%AE%BE%E8%AE%A1%E4%BA%AE%E7%82%B9%E4%B8%8E%E5%B7%A5%E7%A8%8B%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="etcd-设计亮点与工程优化"><a href="#etcd-设计亮点与工程优化" class="headerlink" title="etcd 设计亮点与工程优化"></a>etcd 设计亮点与工程优化</h1><h2 id="raft-协议"><a href="#raft-协议" class="headerlink" title="raft 协议"></a>raft 协议</h2><p>根据 MIT6.824 的讲解，在原生的 raft 协议中，所有的读写操作都是完全串行的，虽然能够保证读写的线性一致性，但是性能非常差，必须要经过工程上的优化才能够获得比较好的性能。</p><h3 id="ReadIndex-解决读操作落盘问题"><a href="#ReadIndex-解决读操作落盘问题" class="headerlink" title="ReadIndex 解决读操作落盘问题"></a>ReadIndex 解决读操作落盘问题</h3><p>为了避免网络分区问题出现时，旧主仍然在为客户端提供读服务，在最初的 raft 协议中，读操作也同样需要通过 raft log 落盘，以此来保证网络分区问题出现时，旧主停止所有的读写服务。由于原生 raft 协议中操作是串行化的，每一个读操作都需要进行落盘显然会使得读性能很低，必须要作出一定的优化。</p><p>ReadIndex 是 raft 论文作者所提出的一种优化方法，核心的思想有两点，一是 Leader 在处理客户端请求时必须要确认自己仍然是 Leader ，二是读请求只能够看到已经到达大多数节点的数据。在 ReadIndex 实现下，每一次读请求返回时，Leader 需要向每一个从节点发送心跳来确认自身状态，并且更新当前的数据可见区域。这种处理相比于原生的 raft 协议，仍然需要向所有的节点发送 rpc，但是避免了读操作的落盘，但是读操作仍然会导致与从节点的通信。每当一个写操作被从节点成功写入 entry，都会向主节点发送一个通知来更新状态。只有被提交到大多数节点中的请求，才会对读操作可见。</p><p>事实上，并不需要每一次读操作都进行一次心跳包请求，只需要每隔一段时间进行心跳包请求即可。这样可以节约网络带宽，但是会造成部分读操作等待，可能会造成一定的读延迟。在 etcd 的实现中，主节点会定期询问并更新当前集群的最低水位，这样可以确保最低水位之前的读操作都是可以提交的。</p><h3 id="noop-解决-Stale-Read-问题"><a href="#noop-解决-Stale-Read-问题" class="headerlink" title="noop 解决 Stale Read 问题"></a>noop 解决 Stale Read 问题</h3><p>Stale Read 是由幽灵复现问题带来的，即一个主节点在任期中的最后几条 log 并没有及时响应，下一轮选举中，另一节点当选并且没有写入数据后下线，第三轮选举中，最初的主节点又成功当选。这样会导致某几个记录在第二轮选举中无法被查询到，但是却能够在第三轮选举周期中被查询到。这显然是违反了线性一致的。</p><p>在 raft 协议中，为了避免幽灵复现问题，使用了 Noop 机制。每一个新主在完成选举后必须 commit 一条空记录，该记录带有最新的任期，才能够处理读操作。当 Noop 成功提交后，由于旧主是不具备最新任期日志的，所以无法再一次当选，因此不会出现幽灵复现问题。</p><h3 id="PreCandidate-避免不必要选举"><a href="#PreCandidate-避免不必要选举" class="headerlink" title="PreCandidate 避免不必要选举"></a>PreCandidate 避免不必要选举</h3><p>考虑以下一种状况：如果某个 raft 节点由于网络故障无法收到其他节点的网络包，那么它将会一直处于 Candidate 状态。由于无法选举成功，每一次选举失败都会导致 Term 自加，一段时间后，该节点的 Term 号会比较大。这时，如果网络突然恢复将会发生一轮选举。但是由于该节点的日志是过时的，并不会选举成功，相当于进行了一次不必要的选举。</p><p>为了解决这种问题，etcd 在三种 raft 状态之外还引入了 PreCandidate 状态。从节点心跳超时并不会直接进入 Candidate 状态，而是进入 PreCandidate 状态，并且发送 rpc 询问其他节点自身是否可以获得投票（预选举），只有询问结果超过半数时才会进入 Candidate 状态。如果从节点在 PreCandidate 状态进行预选举失败，将会退回到原有的状态。PreCandidate 状态的节点，仍然与 Follower 状态节点保持相同的选举机制，可以给其他投票。</p><p>PreCandidate 的引入不仅能够解决上述网络分区带来的选举问题，还能够加速正常选举的收敛——较慢的节点并不会真正参加选举，只能够进行投票，从而使能够成功选主的节点有更大概率获得半数以上投票。</p><h3 id="Batch-与-Pipeline-加快读写进程"><a href="#Batch-与-Pipeline-加快读写进程" class="headerlink" title="Batch 与 Pipeline 加快读写进程"></a>Batch 与 Pipeline 加快读写进程</h3><p>由于对每一条 Log Entry 都进行刷盘会导致效率较低，etcd 中会将同一时刻到达的写请求批量发送给从节点，从节点也会批量对 log 进行刷盘操作，这种实现在避免事务进行等待的前提下实现了日志的批量刷盘。</p><p>但是单纯使用 Batch 优化是不够的，如果单个 Batch 比较大，可能从节点会分批次进行持久化处理，这可能会导致某些小事务被阻塞无法提交。所以，在从节点提交状态时，并不会使用 Batch 的模式，而是使用 Pipeline 的模式，每次存在新的已提交日志就会返回主节点结果。</p><h3 id="对比-MongoDB-中的实现"><a href="#对比-MongoDB-中的实现" class="headerlink" title="对比 MongoDB 中的实现"></a>对比 MongoDB 中的实现</h3><p>MongoDB 的设计目标更多地考虑了高性能的问题，对数据的线性一致性有着较多的取舍，也正是这些原因 MongoDB 并不适合数据安全性要求较高的场景。</p><ul><li>网络分区下读问题：MongoDB 中的实现并不能够保证在双主状态下读到最新的数据，因为 MongoDB 的读取流程只会检查主节点当前的提交水位，而不会检查主节点租约是否有效。当网络分区问题发生时，旧主将会在一个心跳包的时间内继续进行工作，在该心跳包内读取到的数据可能已经被更新，即使采用 r : majority 选项也不能够保证读到的是最新数据。（不确定）</li><li>网络分区下写问题：MongoDB 中的实现可以保证 w : majority 写入安全，需要人工来保证 w : 1 级别的写入安全。当网络分区出现并恢复后，旧主会作为从节点工作，其中不一致的数据将会被写入到回滚文件中，具体如何操作需要由用户决定。参考链接：<a href="https://www.mongodb.com/docs/manual/core/replica-set-rollbacks/">https://www.mongodb.com/docs/manual/core/replica-set-rollbacks/</a></li><li>选举机制：由于 MongoDB 的 w : n 机制存在，其实并不能够保证数据一定会被写入到大多数节点上。所以 MongoDB 在 raft 选举的基础上增加了反对票选项，被投反对票的节点大概率是无法当选的，这是为了保证拥有最新数据的节点当选。</li><li>选举后的数据状态问题：MongoDB 中选举成功后，新主并不会直接按照自身的状态来确认当前状态，而是会要求其他节点发送与自身不一致的数据，然后再根据具体情况来判断是否保留。这同样是因为 w : n 机制的存在。</li><li><strong>写入超时</strong>：这是 MongoDB 中一个非常特殊的错误。如果在一段时间内无法达到规定的写入要求，会返回这个错误。该错误不会对写入内容进行直接回滚，因为该内容可能能够提交成功。客户端需要使用特殊的机制来判断发生该错误后，是否写入成功。</li></ul><p>通过对比，etcd 通过牺牲读性能获取了线性读，而 MongoDB 则正好相反，这是因为二者的定位不同。另外，在 MongoDB 的实现中，选举通常需要耗费更长的时间，通常情况下在 5s 左右，这种牺牲是为了保证写入的灵活性。</p><h2 id="数据库部分"><a href="#数据库部分" class="headerlink" title="数据库部分"></a>数据库部分</h2><h3 id="MVCC——-内存数据库变为硬盘数据库反而变快了？"><a href="#MVCC——-内存数据库变为硬盘数据库反而变快了？" class="headerlink" title="MVCC—— 内存数据库变为硬盘数据库反而变快了？"></a>MVCC—— 内存数据库变为硬盘数据库反而变快了？</h3><p>在 etcd v2 中使用的是内存数据库，而在 etcd v3 中使用的是硬盘数据库，但是后者的性能反而比前者更好，这是由于 MVCC 的引入。首先需要思考一个问题，raft 协议中所有操作都是串行提交的，为什么还会需要读写并发控制？原因有以下几点：</p><ul><li>通过对raft协议优化，读操作并不会写状态机，从而实现了读操作与写操作的并行。</li><li>虽然写 raft log 时是串行的，但是当 raft 状态机更新后，写入到数据库时仍然可能是并发的。</li><li>etcd 中的 watch 机制需要保存每一个键值对的历史版本，多个读操作可能会并发到达</li></ul><p>因此，MVCC 机制不仅可以解决并发问题，还很好地契合了 etcd 的应用场景。由于 MVCC 版本链表可能较大，不太适合直接存储在内存中，因而从内存数据库切换到了硬盘数据库。虽然单个的读写操作性能降低了，但是却允许了更多操作并发，因而整体性能反而是上升的。</p><p>在 etcd 中，MVCC 机制中每一个键值对都有一个 revision。revision 结构体包含两个部分：全局唯一事务号、事务内部编号。这种实现方法同其他的数据库类似。</p><h3 id="读操作等待"><a href="#读操作等待" class="headerlink" title="读操作等待"></a>读操作等待</h3><p>etcd 中并非所有读请求都会被立即处理，而是有可能会被阻塞一段时间。例如当一个线性读请求到达从节点，版本号为 v2，而当前从节点的提交版本号为 v1，且 v1&lt; v2，那么该读请求就会一直阻塞直到版本号到达 v2。这里发生的阻塞等待是为了保证线性读：如果一个客户端发送了两次读请求，并且两个读请求被分派到了两个从节点上，因为两个从节点的提交速度并不一样，如果不采取上述的策略就可能会发生更新的读请求反而读到了更旧版本的数据。</p><p>为了保证线性读，etcd 中<strong>写操作会阻塞该操作后的所有读操作</strong>。如果没有写操作发生，那么任何时刻 etcd 的读操作都不需要阻塞；如果有写操作发生，由于 etcd 的写操作是批量提交的，那么读操作就需要阻塞等待一个周期后才能够完成。</p><p>虽然这种等待看起来比较愚蠢，但是却能够简单有效地保证线性读的特性，结合 etcd 其他部分的优化，实际的性能并没有想象中差。如果需要避免读操作的等待，可以关闭线性读的选项，通过降低安全性来提升读取的性能。及时是关闭了线性读，etcd 的读安全性仍然是高于大于部分分布式数据库的。</p><h3 id="事务批量提交"><a href="#事务批量提交" class="headerlink" title="事务批量提交"></a>事务批量提交</h3><p>数据库中的事务批量提交是建立在 raft 层中 Batch 优化的基础上的。raft 层的 Batch 优化使得数据库写入的并发压力提高了。而提升数据库写入吞吐量的一个经典优化就是批量提交。当一个写事务完成 raft 层的复制后，并不会被立刻插入到 boltDB 中，而是会写入缓冲区中然后等待一定的时间或者使用其他 trigger 触发后。被写入缓冲区的操作会合并成为一整个事务插入事务库。这种优化使得在某一时刻基本上是不存在写操作之间的并发的，因此 MVCC 的统一事务管理器并不会存在版本号的竞争问题。而 MVCC 中比较困难的优化就是版本号的竞争问题，etcd 这里的事务批量提交的优化非常巧妙。</p><h3 id="读写缓冲区"><a href="#读写缓冲区" class="headerlink" title="读写缓冲区"></a>读写缓冲区</h3><p>在 etcd v3.2 版本中引入了读写缓冲区和读写锁机制来改善读写性能。这里改善主要是针对 etcd v3.1 版本中读操作与读操作也无法并发，但实际上经过优化后的版本还是具有一定的问题，该问题最终在 v3.4 版本引入的完全并发读解决。</p><h3 id="完全并发读"><a href="#完全并发读" class="headerlink" title="完全并发读"></a>完全并发读</h3><p>完全并发读是 etcd v3.4 中引入的优化，该优化主要是为了解决 boltdb 中事务锁和读写锁粒度过粗的问题。首先介绍完全并发读要解决的问题：</p><p>由于 etcd 默认是线性读，需要避免不可重复读和幻读的影响。在 etcd 最初的实现中，读写操作是通过读写锁来控制的，这是一种不太适合 etcd 使用场景的实现——etcd 中的所有读操作都是范围查询的，并且经常面临着较为 expensive 的读事务。如果一个读事务跨越了多个写事务批量提交的时间点，就会导致大量的写请求堆压，最终在长事务结束时全部提交，增加了读写锁的竞争压力，导致 etcd 的性能在某个时间点急剧下降。参考 <a href="https://www.cnblogs.com/alisystemsoftware/p/11555426.html">https://www.cnblogs.com/alisystemsoftware/p/11555426.html</a></p><p>完全并发读包含以下几个核心点，按照个人的理解其实就是多缓冲区加惰性刷盘：</p><ul><li>取消读写锁，已经开始的读写操作并不会相互阻塞。</li><li>使用快照机制 concurrentReadTxn 作为读视图</li></ul><p>这两条核心思想其实需要解决的核心问题就是如何寻找一个合适的时机将写操作持久化到数据库中，etcd 中的实现使用的是经典的多缓冲区加滑动窗口的机制。我们将已经落盘的数据版本视为 v1，每次需要写事务需要提交的版本为 v2、v3… vn。当写事务持久化数据时，并不直接刷盘，而是先写 WAL，然后将数据放入到一个缓冲区链表中，确保数据不会丢失。</p><p><strong>由于 etcd 中读写操作的特性</strong>，写操作开始前已经发送的读操作不会依赖该写操作的数据，而依赖该写操作数据的读操作必须等待该写操作完成后才会开始。因此，每次写操作进行提交时，可以先写入到缓冲区链表的尾部，并且将之前的部分全部持久化到硬盘中；这样就可以保证在任何一个时刻的读操作视角都是正确的。而在内存中的缓冲区应该都具有一个引用计数，当链表首段的引用计数为 0 时，才会执行内存释放的操作。这样就避免了写操作阻塞等待当前读操作完成。</p><p>当读操作发生时，需要从缓冲区链表的尾部（最新版本）拷贝一个副本，副本的引用计数加一，假设获得的缓冲区版本为 vn。读操作读数据时，会首先从缓冲区中查找，若无记录才会到落盘的数据中查找。这样，已经更新的数据在读操作中的视图是最新的。当读操作结束时，检查当前的引用计数，如果引用计数为 0，则缓冲区数据可以允许被释放。</p><p>当然，具体的执行逻辑要比上述流程稍微复杂。加入完全并发读机制后，写操作只需要等待所有读操作完成缓冲区的拷贝后就可以执行，大大减少了写提交的延迟。</p><h2 id="应用层部分"><a href="#应用层部分" class="headerlink" title="应用层部分"></a>应用层部分</h2><h3 id="双索引-Watch"><a href="#双索引-Watch" class="headerlink" title="双索引 Watch"></a>双索引 Watch</h3><p>参考链接 <a href="https://www.alicharles.com/article/etcd/etcd-watch/">https://www.alicharles.com/article/etcd/etcd-watch/</a></p><p>etcd 中的 watcher 分类两种，一种是精确到具体键值对的 Key Watcher，另外一种是监听某个范围的 Range Watcher。etcd 中建立了哈希表和红黑树两种索引来实现对不同类别 watcher 的查找。Key Watcher 可以直接使用哈希表进行匹配，而 Range Watcher 则需要对红黑树进行一次带记忆的深度优先搜索。当写事务完成修改时，会分别查找两种索引中是否具有满足匹配的 watcher。如果具备则会将信息发送到该 watcher 对应的 channel 中。</p><h3 id="Watch-推送机制"><a href="#Watch-推送机制" class="headerlink" title="Watch 推送机制"></a>Watch 推送机制</h3><p>由于 etcd 中所有写事务会被聚合为一个大事务完成，事务在执行 PUT 操作时，由 <code>notify</code> 方法同步推送。理想情况下，这些更新会被grpc 双向流立即发送给客户端。但实际上，由于网络、客户端程序阻塞、服务端事件堆积等问题，可能会造成部分 Watcher 无法及时消费最新消息，造成了消息异常和堆积的问题。</p><p>为了处理推送 Watch 消息的异常和堆积问题，etcd 中将 Watcher 分为三类：synced watcher，unsynced watcher，victim wathcer。参考 <a href="https://www.lixueduan.com/posts/etcd/13-watch-analyze-1/">https://www.lixueduan.com/posts/etcd/13-watch-analyze-1/</a></p><ul><li>synced watcher：状态正常，不存在历史消息未消费，可以随时等待新消息到来。</li><li>unsynced watcher: 状态正常，存在历史消息未消费，等待数据推送同步。</li><li>victim wathcer：状态不正常，存在历史消息未消费，因 channel 阻塞导致。</li></ul><p>etcd 并不会为 unsynced watcher 在内存中保留一个缓冲区来记录所有未发送的消息，这是考虑到 etcd 中的 watcher 可能会非常多，并且该 watcher 可能是一个 range watcher，如果未每一个 watcher 保留相应的历史消息缓冲，将会占用大量的内存。当 unsynced watcher 需要历史数据时，需要开启一个读事务，并且查询数据库，这是一个非常 expensive 的操作。因此，etcd 会每 100ms 将 unsynced watcher 分组合并后，<strong>通过一次遍历取出多个 watcher 需要的值</strong>。</p><p>而 victim watcher 则是由于 go 中的 channel 缓冲区已满而无法正常发送消息给 rpc stream，etcd 会将无法发送的那一条消息缓存，等待再一次发送。 这里的主要考虑如下：victim watcher 是一个异常状态，etcd 必须<strong>尽快完成消息重发防止 victim watcher 变更为 unsynced watcher</strong>，否则遍历数据库将会非常 expensive。因此，etcd 每 10ms 就会开始一次 victim watcher 的清理工作。</p><table><thead><tr><th>Watcher 类别</th><th>消息情况</th><th>处理机制</th><th>产生原因</th><th>备注</th></tr></thead><tbody><tr><td>synced watcher</td><td>不存在历史消息</td><td>等待新消息到来，直接推送</td><td>正常状态</td><td></td></tr><tr><td>unsynced watcher</td><td>存在历史消息</td><td>等待 syncWatchersLoop 调度，<strong>按组</strong>遍历数据库查找历史消息，并一次性全部推送给客户端，调度周期 100ms</td><td>客户端指定历史版本，或 victim watcher 阻塞过久</td><td>由于需要遍历数据库，核心思想是尽量等待有足够多的 watcher 一次遍历数据库拿出全部的历史值</td></tr><tr><td>victim wathcer</td><td>存在历史消息</td><td>等待 syncVitctimssLoop 调度，重新发送缓存的消息，调度周期 10ms</td><td>channel 缓冲区已满，无法正常推送消息</td><td>为了防止 victim watcher 阻塞过久，变成 unsynced watcher，必须尽快完成消息的重发</td></tr></tbody></table><h3 id="租约机制"><a href="#租约机制" class="headerlink" title="租约机制"></a>租约机制</h3><p>etcd v3 中键值对的过期时间具有两种模式，一种是使用客户端租约，另外一种是直接使用键值对 TTL。客户端租约存储采用的数据结构是堆实现的优先队列。客户端租约的模式能够解决键值对规模过大时过期键值对无法及时处理的问题，是一种广泛采用的处理模式。</p><p>单机的租约机制实现较为简单，但 etcd 是一个高可用、强一致系统，如何保证租约在不同节点之间的转移是需要关注的重点问题。在早期版本中，etcd 所采取是实现为：主节点只在租约导致数据发生变更时通知从节点，即只有租约创建和失效的时候才会与从节点进行同步。由于从节点并不会收到续约的通知，因此并不会主动进行淘汰操作。当选举发生时，新主将会自动给所有的租约进行续期。但如果网络波动很严重，导致不断选举，可能会造成租约无法过期的情况。</p><p>在新版本中，etcd 做出了以下两点优化，但是由于对性能影响较大，仍然处于实验阶段：</p><ul><li>定期同步租约信息给从节点</li><li>每次租约更新时，同步信息给从节点</li></ul><p>以上的两点优化，都是将租约信息也加入到了 raft 状态机里面，所以可能会对性能造成一定影响。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> etcd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 与 MySQL 的一些读写优化</title>
      <link href="/2022/12/01/MongoDB%20%E4%B8%8E%20MySQL/"/>
      <url>/2022/12/01/MongoDB%20%E4%B8%8E%20MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB-与-MySQL-的一些读写优化"><a href="#MongoDB-与-MySQL-的一些读写优化" class="headerlink" title="MongoDB 与 MySQL 的一些读写优化"></a>MongoDB 与 MySQL 的一些读写优化</h1><p>MongoDB 与 MySQL 的设计都是通用数据库的模式，但是从结果上来看，MongoDB 的写入性能要优于 MySQL，而 MySQL 的读取性能是优于 MongoDB 的，MongoDB 的事务隔离等级较 MySQL 要低，MongoDB 的设计是面向分布式数据库，其应用层日志的设计更加有新意。</p><h2 id="读取链路的优化"><a href="#读取链路的优化" class="headerlink" title="读取链路的优化"></a>读取链路的优化</h2><p>​    由于 MongoDB 大量数据和索引是常驻内存的，所以性能是会比 MySQL 高很多的。MongoDB 的设计中牺牲了一定的读取性能来换取更高的写入性能。而 MySQL 大量数据是常驻在内存中的，因此做了较多的优化来换取更高的读取性能。</p><h3 id="MySQL-读取链路优化"><a href="#MySQL-读取链路优化" class="headerlink" title="MySQL 读取链路优化"></a>MySQL 读取链路优化</h3><p>​    MySQL 在读取链路的优化主要有查询缓存、页缓存、自适应哈希索引、CheckPoint、覆盖索引、MRR 优化、ICP 优化</p><h4 id="MRR-优化"><a href="#MRR-优化" class="headerlink" title="MRR 优化"></a>MRR 优化</h4><p>​    需要查询时，先根据辅助索引将 WHERE 语句中所有符合条件的主键值放入缓冲区，在缓冲区进行排序后查询。这样可以将随机 IO 转化为顺序 IO。</p><h4 id="ICP-优化"><a href="#ICP-优化" class="headerlink" title="ICP 优化"></a>ICP 优化</h4><p>​    当索引取出时，会根据 WHERE 语句条件进行判断，这一优化是适用于联合索引，或者 WHERE 语句中包含主键值的情况。</p><h2 id="写入链路的优化"><a href="#写入链路的优化" class="headerlink" title="写入链路的优化"></a>写入链路的优化</h2><h3 id="MongoDB-写入链路优化"><a href="#MongoDB-写入链路优化" class="headerlink" title="MongoDB 写入链路优化"></a>MongoDB 写入链路优化</h3><p>​    MongoDB 的写入链路主要做了以下几点优化：Check Point、Copy On Write、无锁 B+ 树、Insert List、事务组提交。</p><h4 id="Check-Point"><a href="#Check-Point" class="headerlink" title="Check Point"></a>Check Point</h4><p>​    Check Point 技术允许 MongoDB 按照每一秒的频率对整个 B+ 树进行刷盘操作，这使得大量的写入操作在写入日志后不需要立刻进行刷盘，只需要写入到内存当中。结合Copy On Write可以使得 B+ 树在正常刷脏的过程中也不会阻塞写入。</p><h4 id="Copy-On-Write"><a href="#Copy-On-Write" class="headerlink" title="Copy On Write"></a>Copy On Write</h4><p>​    Copy On Write 技术是在上一 Check Point 的基础上在内存中新开辟内存区域进行写入，这样做的好处主要有两点：第一是很好地区分了脏页，在刷脏的过程中减小了遍历的范围，提高了刷脏的效率，第二是能够减少刷脏过程中的阻塞时间，如果一页在刷脏过程中被写入，那么将会立刻开辟出一个新的缓冲区，写入操作将会写入到该缓冲区的跳跃表中，并不会造成写入的阻塞（但并不意味着不会增加写入的时间，事实上，在刷脏时写入将会等待缓冲区的分配，这会稍微延长写入时间）。</p><h4 id="Insert-List"><a href="#Insert-List" class="headerlink" title="Insert List"></a>Insert List</h4><p>​    MongoDB 中所有的写入操作并不是在原有的位置上更新。每一个页表中都有多个跳跃表，插入操作会将值插入到统一的缓冲区内，并且在跳跃表中增加指向该值的指针，并且跳跃表是可以做到无锁并发的，可以大大提高写入的性能。但是这同时会造成读取链路变长，在读取时需要首先查找原有的值数组，然后再对跳跃表进行遍历。</p><h4 id="无锁-B-树"><a href="#无锁-B-树" class="headerlink" title="无锁 B+ 树"></a>无锁 B+ 树</h4><p>​    这里主要是针对 B+ 树节点的分裂优化，由于 B+ 树节点的分裂会造成写入的阻塞，在 MongoDB 中只有单个节点短时间内插入过多数据时，才会允许 B+树节点的分裂，其余情况下，只有在 Check Point 或者冷淘汰过程中才会进行节点的分裂。所以 MongoDB 中内存中页面的大小可能与硬盘中的页面大小不相同，在刷入硬盘中时，会将内存中的页面分为几个较小的页面写入到硬盘中。</p><p>​    单个节点插入过多数据时，会将最后一个插入跳跃表放入到新的节点中，这一过程是可以做到不阻塞的（先将剩下的插入操作引导至新的页面中，随后再将旧节点拷贝到新的页面上）。但是这种设计会对热点数据的读取性能造成一定的影响，最新插入的数据需要更多的查询次数，降低了读取性能。</p><h4 id="事务组提交"><a href="#事务组提交" class="headerlink" title="事务组提交"></a>事务组提交</h4><p>​    事务组提交是数据库系统中比较常见的优化，但 MongoDB 与MySQL的组提交有所不同。MongoDB 中组提交的缓冲区很小，并且每次组提交后都会进行刷盘，而 MySQL 中时以文件的形式来进行刷盘的。MongoDB 中，一次组提交中线程会将 log 拷贝到缓冲区中，拷贝完成按照 log 的序列号进行提交，不会造成不同组的乱序提交。</p><h3 id="MySQL-的写入链路优化"><a href="#MySQL-的写入链路优化" class="headerlink" title="MySQL 的写入链路优化"></a>MySQL 的写入链路优化</h3><p>MySQL 写入的优化主要集中在如何将随机 IO 转化为顺序 IO 上，这是因为在设计时 MySQL 的 B+树索引主要是存储在硬盘上的。</p><h4 id="插入缓冲区"><a href="#插入缓冲区" class="headerlink" title="插入缓冲区"></a>插入缓冲区</h4><p>​    辅助索引的写入是统一写入到缓冲区后，再进行刷盘操作。这一优化是因为辅助索引通常并不是聚集的，直接写入会造成随机 IO，通常引入这样一个缓冲区，可以结合异步 IO 机制将随机 IO 转换为顺序 IO，提高刷盘时的性能。</p><h4 id="Check-Point-技术"><a href="#Check-Point-技术" class="headerlink" title="Check Point 技术"></a>Check Point 技术</h4><p>​    MySQL 中同样是采取了该技术，当数据需要写入时会将对应的页读取到内存中，然后在内存中进行修改，随后该页并不会被立刻刷入到硬盘中，而是会由 master 线程进行刷盘。MySQL 中的该设计其实主要是考虑到热数据的问题，刚刚写入的数据被再次修改和读取的概率是比较大的，这一举措不仅优化了写入性能，还能够优化读取性能。</p><h4 id="事务组提交-1"><a href="#事务组提交-1" class="headerlink" title="事务组提交"></a>事务组提交</h4><p>​    bin log 的组提交机制类似于 MongoDB。redo log 则是采用多个文件缓冲和双指针的机制，一个指针指向当前写入的文件缓冲区，另外一个指针指向需要刷盘的缓冲区，实现无锁写入。MySQL 的bin log组提交被 wiredtiger 中的 journal 组提交所借鉴，这确实是一个比较巧妙的设计，但是 MongoDB 中将应用层的日志也当做数据库中的记录，这一设计了避免了bin log 需要和 redo log 分开进行提交的缺陷。</p><h4 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h4><p>​    异步 IO 是 MySQL 其他许多优化的基础，异步 IO 允许操作系统将多个 IO 操作合并并且重新排列顺序，使之更加符合硬盘的写入顺序。 </p><h4 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h4><p>​    这一操作在固态硬盘时代好像是一个负优化，一般会关闭</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>​    MongoDB 的写入链路是比读取链路要短的，这一点与 MySQL 正好相反。对于单独的事务来看，由于应用层日志是不需要单独提交的，所以 MongoDB 的 WAL 写入理论上是要比 MySQL 快的，（事务在写入 WAL 后就可以返回）。</p><p>​    在大量事务写入的情况下，很容易会造成热点页刷脏的问题。由于 MongoDB 允许内存与硬盘中 B+树大小不相同，并且针对内存中的 B+ 树做了写入优化，大量写入的情况下会优先写入到内存缓冲区中，并且优先在内存中进行分裂。在处理这种瞬时写入压力时，MongoDB 的设计会更加好，这主要是 MongoDB 的设计考虑到了大量的内存缓冲，并且牺牲了一部分读取性能换来的。</p><p>​    最主要的是，MySQL 作为关系型数据库，其事务隔离等级要求较高，这同样会造成较大的性能损耗，例如外键约束、间隙锁等。</p><p>​    但是，MongoDB 在指定主键插入时，由于插入的位置可能并不是页面内最后一个跳跃表，这样就可能会导致创建出多个新页面才能够将插入位置放入到新页面中，或者来不及进行内存节点分裂，导致页面被锁住禁止写入，这样会造成较大的性能毛刺。因为要插入一个非常大的跳跃表，并且还要完成多个页面的持久化。此外，指定主键时，如果数据库体量较大，导致大部分数据不能够常驻内存，MongoDB 可能还需要从硬盘中读取数据来确保主键是唯一的，这样就导致数据量较大时指定主键的插入性能非常低。</p><p>​    所以，MongoDB 并不适合存储那些由用户指定，并且需要保证唯一性的数据，例如用户名称等，而订单编号这种情况可以直接使用 uuid 进行插入。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WiredTiger 日志组提交</title>
      <link href="/2022/10/27/WiredTiger%E6%97%A5%E5%BF%97%E7%BB%84%E6%8F%90%E4%BA%A4/"/>
      <url>/2022/10/27/WiredTiger%E6%97%A5%E5%BF%97%E7%BB%84%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="WiredTiger-日志组提交"><a href="#WiredTiger-日志组提交" class="headerlink" title="WiredTiger 日志组提交"></a>WiredTiger 日志组提交</h1><p>Wiredtiger 中的日志系统设计参考了论文 Scalability of write-ahead logging on multicore and multisocket hardware，链接为 <a href="https://infoscience.epfl.ch/record/170505/files/aether-smpfulltext.pdf%E3%80%82">https://infoscience.epfl.ch/record/170505/files/aether-smpfulltext.pdf。</a> </p><p>以下内容参考了官方文章 <a href="https://www.mongodb.com/blog/post/breaking-wired-tiger-logjam-write-ahead-log">https://www.mongodb.com/blog/post/breaking-wired-tiger-logjam-write-ahead-log</a></p><h2 id="日志组提交模式"><a href="#日志组提交模式" class="headerlink" title="日志组提交模式"></a>日志组提交模式</h2><p>用户在写日志时，对于日志缓冲区的竞争是无锁的，只使用原子标志来进行同步。日志写入的流程如下：</p><p><img src="/images/mlog.png" alt="mlog"></p><p>在 Slot 的竞争阶段，不同的线程会竞争修改Slot 的原子标志。若修改成功，则线程需要负责分配下一个 Slot；若修改失败，则会根据返回的 entry 位置，将日志拷贝到 Slot 中；如果下一个Slot 分配完成，则本 Slot 禁止写入，返回的 entry &lt; 0，线程需要再次竞争下一个 Slot。</p><p>当线程完成 Slot 的写入，可以根据日志写入等级选择返回时机，而最后一个完成写入的线程则需要负责将 Slot 写入硬盘缓冲区，若该 Slot 中有现成要求写入硬盘，则进行刷盘操作。</p><h2 id="自由调控日志等级"><a href="#自由调控日志等级" class="headerlink" title="自由调控日志等级"></a>自由调控日志等级</h2><p>由于每一个用户线程都深度参与了日志的提交过程，用户线程具有三个时机可以返回：1、写入日志缓冲区。2、写入硬盘缓冲区。3、写入硬盘。这种自由度允许了 MongoDB 的 CRUD 操作具备了更高的调控等级：不写日志、日志写入缓冲区、日志写入硬盘，对于一些高写入压力的场景，如分布式日志，数据采集系统，可以根据具体情况来选择日志等级，加快客户端的提交速度。</p><h2 id="轻量级缓冲区"><a href="#轻量级缓冲区" class="headerlink" title="轻量级缓冲区"></a>轻量级缓冲区</h2><p>相比于 InnoDB 中采用 Log File 缓冲区，WiredTiger 中的缓冲区量级要更小。这是因为 MongoDB 中需要写入日志的线程数量更多，经常会大于 CPU 的核数，如果采用大缓冲区，各个线程之间对锁的竞争力度会很大。采用更小的缓冲区，并且采用 join 机制，虽然各个线程仍然存在竞争，但是竞争失败并不会阻塞线程，只是会调整线程的活动模式。这种设计在面对短时间内的高并发写入，能够保证日志写入的高效性。</p><h2 id="无后台线程负责写入日志"><a href="#无后台线程负责写入日志" class="headerlink" title="无后台线程负责写入日志"></a>无后台线程负责写入日志</h2><p>传统的后台线程写入的日志模式在无日志缓冲区时会陷入阻塞，而唤醒线程则需要花费 20us 左右的时间，而这一延迟按照论文中的方法是可以优化的，也就是 Wiredtiger 中采取的日志模式。当发生 少量写入操作到达———短时间空闲———少量写入操作到达，这种情况；传统的后台日志写入模式可能就会损耗较大的性能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Wiredtiger 中的日志组提交的设计来源于 MongoDB 的特殊需求：大量的事务线程同时提交事务，大量日志不需要较高的写入等级。该日志系统主要思想可以概括为以下几点：</p><ul><li>日志组提交采取锁来同步，但获取锁失败并不会阻塞线程</li><li>并发写入日志缓冲区不需要加锁</li><li>日志缓冲区写入硬盘需要使用版本号约束</li><li>每个线程可以选择日志的同步等级</li><li>不需要后台线程写入日志</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LevelDB 学习备忘</title>
      <link href="/2022/05/30/LevelDB%20%E5%AD%A6%E4%B9%A0%E5%A4%87%E5%BF%98/"/>
      <url>/2022/05/30/LevelDB%20%E5%AD%A6%E4%B9%A0%E5%A4%87%E5%BF%98/</url>
      
        <content type="html"><![CDATA[<h1 id="LevelDB-学习备忘"><a href="#LevelDB-学习备忘" class="headerlink" title="LevelDB 学习备忘"></a>LevelDB 学习备忘</h1><h2 id="LevelDB-设计出发点"><a href="#LevelDB-设计出发点" class="headerlink" title="LevelDB 设计出发点"></a>LevelDB 设计出发点</h2><p>​        LevelDB 是一个<strong>轻量级，写优先，批量读，硬盘存储</strong>的K-V嵌入式数据库，这是其许多设计和优化的出发点。为了保证读性能中查找操作的可用性，一段数据必须要被有序地放入到数据库中，并且最优的算法复杂度是固定的——O(nlogn)，这意味着数据被放入预定位置延迟是具有最小值的，即写操作必定会具有固定的延迟。LevelDB 的设计就是如果合理地利用结构来优化这个延迟，来获得最小的写入延迟，核心技巧就是将数据写入数据库的操作分解，并且尽可能地将操作放入后台线程中运行，以此来获得最小的用户输入延迟，从而获得优异的批量写入性能，并且同时保证一定的读性能。</p><p>​        LevelDB 的典型应用之一是作为临时存储——在本地临时存储用户的工作数据，当工作确认提交后再整体发送给其他数据库。</p><h2 id="LevelDB-的写入延迟优化"><a href="#LevelDB-的写入延迟优化" class="headerlink" title="LevelDB 的写入延迟优化"></a>LevelDB 的写入延迟优化</h2><p>​        不同于其他的单机数据库形式，LevelDB 的设计更多地用于嵌入式数据库，因此必须要保证数据库的系统资源占用较小。LevelDB 的写入延迟优化的核心思想是进行数据写入操作的分解，牺牲一定的总操作时间，来换取每一步操作的低延迟，从而实现较低的用户操作延迟以及较低的系统资源占用。</p><p>​        总体来看，LevelDB 中数据的写入流程可以被分解为：</p><ul><li>WAL 日志：目的为获得低用户写入延迟</li><li>批写入缓冲：目的为获得较少的线程同步次数</li><li>内存缓冲表：目的为优化用户修改近期数据的需要</li><li>SSTFile 以及合并：目的为减少系统占用，优化读性能</li></ul><h3 id="WAL-日志"><a href="#WAL-日志" class="headerlink" title="WAL 日志"></a>WAL 日志</h3><p>​        虽然将数据有序地写入数据库中的延迟最小是 O(nlogn)，但是只是将数据持久化到硬盘中的延迟只有 O(1)。利用 WAL 操作，用户调用 <code>Put()</code>操作时，操作被追加到 WAL 文件中即可对用户操作返回成功。实际设计中，LevelDB 将操作记录到内存缓冲区后，再写入到 WAL 文件中，后台线程会根据内存缓冲区完成后续的数据写入操作。由于 WAL 文件流时追加形式，并且是持续打开的，不需要寻址，因此该速度非常快。</p><h3 id="批写入缓冲"><a href="#批写入缓冲" class="headerlink" title="批写入缓冲"></a>批写入缓冲</h3><p>​        在 LevelDB 中，具有一个缓冲区用于存储用户的写入操作。只有当该缓冲区满时，或者经过一段时间后，后端线程才会将该缓冲区中的数据真正写入到内存中的跳跃表中。这一设计主要的优点如下：</p><ul><li>优化跳跃表写入时间：跳跃表写入操作需要进行查找，查找操作是插入延时的主要原因。利用批写入缓冲，可以将用户的 N 个操作根据键值进行排序，在进行跳跃表写入时，最坏情况下只需要从头遍历一次跳跃表，大大节约了查找的时间。</li><li>符合用户操作习惯：用户在执行插入操作时，可能会在短期内多次更新同一个值，这样可以将多次插入操作合并为一次。</li><li>优化线程同步：跳跃表是需要由多个后台线程共享的（插入线程，持久化线程，读取线程），执行写入操作时是需要进行加锁的。执行批写入时，写入时间更短，获取锁的时间更短，同时唤醒其他线程的时机也更少，对线程同步是有益的。</li></ul><p>​        批量写入也有一定的弊端，主要是数据库宕机时会增加恢复时间，但总体来说对数据库性能的影响很小。</p><h3 id="MMAP-跳跃表"><a href="#MMAP-跳跃表" class="headerlink" title="MMAP (跳跃表)"></a>MMAP (跳跃表)</h3><p>​        mmap 主要是实现了缓冲区的功能，将多次写入硬盘的操作合并为一次写入。由于操作系统的调度机制，频繁进行 IO 的线程优先级是比较低的，线程频繁进行 IO 操作会浪费很多时间在调度上。同时，使用内存缓冲区时，可以将整个表进行数据压缩操作，节约硬盘的存储空间。</p><p>​        跳跃表是一个综合来看比较优异的数据结构。对比跳跃表、哈希表、红黑树三种典型的数据结构，哈希表并不是一种顺序容器，在迭代操作的时候可能会遇到问题（迭代器失效），红黑树的插入操作因为涉及到旋转，时间常数会比较高，插入性能略差。而跳跃表可以提供顺序迭代访问，并且插入数据时比较简单，很容易实现无锁结构，易于并发访问，因此 LevelDB、Redis 等一些内存数据库经常会使用跳跃表进行缓存操作。</p><p>​        MMAP 的惰性删除机制：在引入惰性删除机制前，对跳跃表的操作需要分为四类：读、写、删除、修改。其中，写、删除操作因为涉及链表的重构，是需要写并发控制才能够运行的；而另外两种操作，并不涉及到链表内部节点的修改，只需要将值设置为原子量就可以进行并发访问了。在引入惰性删除机制后，通过修改节点的标志量来标记删除，当 MMAP 持久化时再删除节点，这样就将删除操作变更为了修改操作，能够大大提升对内存表的并发访问量。</p><h3 id="SSTFile"><a href="#SSTFile" class="headerlink" title="SSTFile"></a>SSTFile</h3><p>​        为了保证读性能的可用性，必须将键值对放入预期的位置。如果数据库简单地将所有数据在硬盘中有序排列，那么每次将 MMAP 中的数据插入到硬盘的操作时间复杂度就是 O(nlogn)，但是这样会导致一次插入操作的系统占用过高。LevelDB 设计了一套分层存储机制来代替传统的存储机制。</p><p>​        SSTFile 是数据在硬盘中的组织形式，不同的 SSTFile 分为不同的层级（ 0 - n ），文件内部的键值对是有序排列的，Level 0 之外的文件在层级之间也是有序排列的。每次 MMAP 中的数据需要持久化时，会生成一个 Level 0 的 SSTFile，如果一个 Level 对应的文件数量过多会触发合并操作。这样设计，高层级的数据是有序的旧数据，低层级因为单个文件数据量很小，因此无序存储也不会过多地影响系统的读性能。每次进行读取操作时，从低层次往高层次进行查找，直到找到数据。</p><p>​        很显然，这种设计会造成写扩大：同样的数据被写入硬盘多次才保证了全局一致性；但是这种写扩大是被分摊到多个不同的时间节点的，虽然总的写入时间加大了，但是却能够确保每个时间点的系统占用很小。因为 SSTFile 的合并是被动的，数据库只会惰性地检查每个层级是否满足合并条件，并且确保一次只存在一个合并操作；此外，如果一次合并操作花费过多的时间，那么数据库还会中断本次操作并选择延迟执行，以防止MMAP 不能及时持久化到硬盘中。</p><h3 id="修改和删除数据"><a href="#修改和删除数据" class="headerlink" title="修改和删除数据"></a>修改和删除数据</h3><p>​        由于数据库采用层级的查找机制，当用户需要进行旧数据的修改时（MMAP 中数据并不存在）；LevelDB 其实并不会对文件中的数据进行查找，而是直接将新的数据写入到 MMAP 中，并不需要删除掉旧数据。因此，在 LevelDB 中，修改操作其实已经退化为了写入操作。同样地，删除操作也只会在 MMAP 中查找数据，若未查询到数据，则会在 MMAP 中插入一条删除记录。</p><p>​        这种优化是因为 LevelDB 面向的应用场景中，用户更加倾向于频繁修改最近的数据，而旧数据的修改可能只会零散的发生，因此额外的硬盘占用量是很小的。</p><h2 id="LevelDB-的读取优化"><a href="#LevelDB-的读取优化" class="headerlink" title="LevelDB 的读取优化"></a>LevelDB 的读取优化</h2><p>​        LevelDB 是一个批处理的数据库系统，这种应用场景下，读取操作是具有显著特征的。</p><ul><li>用户可能会多次修改最近的数据，如不小心输入错误的数据。</li><li>对于旧的数据，用户可能会批量读取并进行操作。</li></ul><p>​        由于 LevelDB 本身存在两个缓冲区，因此已经满足了修改最近数据的需求，基本上只有对旧数据的读取需要进行大规模优化。</p><h3 id="文件索引与布隆过滤器"><a href="#文件索引与布隆过滤器" class="headerlink" title="文件索引与布隆过滤器"></a>文件索引与布隆过滤器</h3><p>​        文件索引是一个经典的文件读取优化模式。在 LevelDB 中，每个 SSTFile 都会在内存中保留一个索引，索引包含了数据日期，最大键值、最小键值、最近操作时间、最近读取次数等一系列信息。如果 MMAP 中没有查询到用户需要的数据，那么就会触发对 SSTFile 的查找，在每个高层级中键值是有序的，因此可以在层级中对键值对执行二分查找；对于无序的Level 0 数据，因为文件数量很小，执行顺序查找也不会有较高的性能损失。</p><p>​        通过键值范围确定可能的 SSTFile 文件后，LevelDB 还需要通过布隆过滤器来保证该数据存在的可能性；只有成功通过布隆过滤器，数据库才会将文件读取到内存中。同样，文件的内部也是有序的，同样可以执行二分查找，降低查找的时间复杂度。被读取到内存中的文件会缓存一段时间，以此来应对用户多次读取同一段数据的需要。</p><h3 id="版本控制-MVCC"><a href="#版本控制-MVCC" class="headerlink" title="版本控制 MVCC"></a>版本控制 MVCC</h3><p>​        LevelDB 中写入操作是直接写入到最上层级的，并不会被读操作读到，因此唯一可能出现的冲突是 SSTFile 合并操作与读操作的冲突，使用简单的 MVCC 并发控制就可以避免冲突。</p><p>​        执行读操作时，LevelDB 会将对应文件的引用量加一；当执行迭代器操作时，会将当前全部文件标注引用。当合并操作被触发，原有的文件需要删除时，根据文件的引用量来判断是否真正执行删除操作；若引用不为 0，则进行惰性删除机制，当引用为 0 时再自动触发删除操作。</p><h3 id="迭代器遍历操作"><a href="#迭代器遍历操作" class="headerlink" title="迭代器遍历操作"></a>迭代器遍历操作</h3><p>​        LevelDB 的读场景存在大量的批量读取，使用迭代器进行数据库的遍历有助于用户简化代码。但由于 LevelDB 中修改和删除操作并不会真正地删除掉旧数据，因此在遍历数据库时必须采取一定措施来防止用户读取过期数据。</p><p>​        LevelDB 中只提供全局有序的迭代器操作，并且能够保证数据的有效性。具体做法为：在每个 Level 上都创建一个内部迭代器，当调用迭代器 <code>MoveNext()</code>操作时，使用类似归并的思想进行操作，这样就能够消除过期数据带来的影响。同时，在创建一个迭代器时，会自动创建一个快照，快照只记录需要访问的文件并声明引用，并不会直接复制数据。</p><h3 id="防止读扩大"><a href="#防止读扩大" class="headerlink" title="防止读扩大"></a>防止读扩大</h3><p>​        LevelDB 的层级读取机制并不能很好地处理一种情景：用户短时间内需要频繁读取一段老数据。该情况下，每次都需要从头开始查找，会消耗过多的查询时间，同时还会造成读取的文件过大，这是需要进行优化的。具体的优化措施为：开辟一片最近读内存缓冲区，将最近读取过的数据存入缓冲区中。缓冲区采用一定的置换策略，并且保证在缓冲区内被多次读取的数据会被持久化到 Level 0 中。</p><h2 id="LevelDB-的系统占用优化"><a href="#LevelDB-的系统占用优化" class="headerlink" title="LevelDB 的系统占用优化"></a>LevelDB 的系统占用优化</h2><p>​        当 LevelDB 作为嵌入式数据库使用时，必须要保证较低的内存和 CPU 占用来维持整体软件的性能。类似于写入操作，LevelDB 完成相应功能的总时间也是具有优化上限的，只有采用分割任务的方法，才能保持长时间的低系统占用。</p><h3 id="内存池与-Slice"><a href="#内存池与-Slice" class="headerlink" title="内存池与 Slice"></a>内存池与 Slice</h3><p>​        LevelDB 内部的内存分配是使用内存池进行分配的，内存池具有效率高、能够避免系统级内存碎片的优点。数据库进程如果只是使用系统调用来简单分配内存，不仅会出现内存频繁申请和销毁的情况，长时间运行还会造成系统级内存碎片，导致系统可用内存下降。</p><p>​        使用内存池会引入较为繁琐的内存管理，因此 LevelDB 引入 <code>Slice</code> 数据结构来简化内存分配。 <code>Slice</code> 是字符串指针和字符串长度的集合，LevelDB 中的所有数据段底层都被存储为 <code>Slice</code> 格式，所有内存申请都是建立在内存池的基础上的，并且会尽量保证持有的内存区域尽可能小。</p><h3 id="SSTFile-合并"><a href="#SSTFile-合并" class="headerlink" title="SSTFile 合并"></a>SSTFile 合并</h3><p>​        SSTFile 合并操作会评估当前数据库的系统占用情况，并且会保证一次合并操作并不会持续过长时间。如果一次合并操作耗时过长，该合并操作会被中断，并且选择合适的时机再次执行。                </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保持后台线程不随主线程退出</title>
      <link href="/2022/04/17/2022-04-17-%E4%BF%9D%E6%8C%81%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%E4%B8%8D%E9%9A%8F%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA/"/>
      <url>/2022/04/17/2022-04-17-%E4%BF%9D%E6%8C%81%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%E4%B8%8D%E9%9A%8F%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>在 linux 系统中，线程是最小的调度单元，主线程与进程内的其余线程享受公平调度，同时也允许主线程退出后进程内其余线程继续运行。但是在编程中，当 main 函数 return 之后，所有的线程均会退出。这是因为 main 函数中的 return 和 exit 系统调用是等效的。如果 main 函数正常结束，那么进程内的所有内存、线程描述符等都会被回收，因此其余线程无法继续运行。</p><p>但有时候，我们并不希望后台线程直接退出，而是想让其完成一些善后工作。例如在进行图形化编程时，后台有线程正在执行某些操作（如重写文件、使用缓冲区向系统写入数据），我们希望这个操作不存在中间态，而直接阻塞主线程退出会导致图形界面退出时卡住。这种场景下，我们可以使用系统调用<code>pthread_exit</code>函数使主线程退出时并不会调用 exit，从而避免进程退出。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 MongoDB 复制集踩坑</title>
      <link href="/2022/04/12/%E8%AE%B0%E5%BD%95-MongoDB-%E5%A4%8D%E5%88%B6%E9%9B%86%E8%B8%A9%E5%9D%91/"/>
      <url>/2022/04/12/%E8%AE%B0%E5%BD%95-MongoDB-%E5%A4%8D%E5%88%B6%E9%9B%86%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>本文记录在部署 MongoDB 复制集时遇到的一些小坑和解决方法。</p><h2 id="docker-环境下-ip-设置错误导致无法访问"><a href="#docker-环境下-ip-设置错误导致无法访问" class="headerlink" title="docker 环境下 ip 设置错误导致无法访问"></a>docker 环境下 ip 设置错误导致无法访问</h2><p>在第一次部署 MongoDB 时，为了方便而选择了使用 docker 容器进行部署。部署过程中完全依照<a href="https://www.mongodb.com/docs/manual/tutorial/deploy-replica-set/">官方的教程</a>，但是最终部署的集群却无法在 docker 网络外以副本集模式访问。在调试过程中发现在 docker 网络内部可以进行访问，因此猜测可能是 DNS 或者监听的问题。</p><p>最终定位到问题在于初始化时选择的 host 错误。官方教程在初始化时，使用的命令如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 container name 初始化</span></span><br><span class="line"><span class="comment">// 只能够在 docker 网络内部访问</span></span><br><span class="line">rs.<span class="title function_">initiate</span>( &#123;</span><br><span class="line">   _id : <span class="string">&quot;rs0&quot;</span>,</span><br><span class="line">   <span class="attr">members</span>: [</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">0</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb0.example.net:27017&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">1</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb1.example.net:27017&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">2</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb2.example.net:27017&quot;</span> &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>官方的教程在部署过程中直接使用了 container name 作为 MongoDB 实例的 HostName，由于所有的副本集是部署在同一个 docker 网络中，所以可以通过 docker DNS 功能来实现服务发现。而在 docker 网络外部，无法使用 docker DNS 服务，因此不能够正确地访问集群。</p><p>经过修改后，将集群初始化命令修改为以下形式，可以正常访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容器使用 publish 端口</span></span><br><span class="line"><span class="comment">// 集群使用宿主机 ip 初始化</span></span><br><span class="line"><span class="comment">// 使其可以接受容器外部访问</span></span><br><span class="line">rs.<span class="title function_">initiate</span>( &#123;</span><br><span class="line">   _id : <span class="string">&quot;rs0&quot;</span>,</span><br><span class="line">   <span class="attr">members</span>: [</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">0</span>, <span class="attr">host</span>: <span class="string">&quot;宿主机ip:port&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">1</span>, <span class="attr">host</span>: <span class="string">&quot;宿主机ip:port&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">2</span>, <span class="attr">host</span>: <span class="string">&quot;宿主机ip:port&quot;</span> &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="宿主机-ip-变更，集群失效"><a href="#宿主机-ip-变更，集群失效" class="headerlink" title="宿主机 ip 变更，集群失效"></a>宿主机 ip 变更，集群失效</h2><p>上述部署方式，虽然解决了容器外部访问的问题，但是在一次网关配置的修改后，集群所在的宿主机 ip 发生了变化，导致之前部署的 ip 无法访问，需要修改集群的配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分容器 ip 改变，集群中仍有 master</span></span><br><span class="line">rs.<span class="title function_">reconfig</span>( &#123;</span><br><span class="line">   _id : <span class="string">&quot;rs0&quot;</span>,</span><br><span class="line">   <span class="attr">members</span>: [</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">0</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb0.example.net:27017&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">1</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb1.example.net:27017&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">2</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb2.example.net:27017&quot;</span> &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部容器 ip 改变</span></span><br><span class="line"><span class="comment">// 部分容器 ip 改变，集群中仍有 master</span></span><br><span class="line">rs.<span class="title function_">reconfig</span>( &#123;</span><br><span class="line">   _id : <span class="string">&quot;rs0&quot;</span>,</span><br><span class="line">   <span class="attr">members</span>: [</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">0</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb0.example.net:27017&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">1</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb1.example.net:27017&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">2</span>, <span class="attr">host</span>: <span class="string">&quot;mongodb2.example.net:27017&quot;</span> &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;，&#123;<span class="attr">force</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>最好的部署方式还是在网关处部署一个 DNS 服务，用于集群的域名管理。</p><h2 id="网络吞吐量过大，查询不稳定"><a href="#网络吞吐量过大，查询不稳定" class="headerlink" title="网络吞吐量过大，查询不稳定"></a>网络吞吐量过大，查询不稳定</h2><p>由于在部署中利用了 MongoDB Gridfs 功能作为基础架构作为深度学习的标记、训练、测试的数据集来源，在我们的使用场景中，经常会需要从 MongoDB 集群中批量访问 500 张以上 15M 左右的图像。在最初的本地测试中，我测试了批量从 MongoDB 中读取 1000 张图像，所以运行速度一直非常稳定，保持在一张图像 150ms 左右的速度，这对我们来说是比较满意的性能。</p><p>但是将 MongoDB 集群投入到使用中，我们发现对图像的获取速度非常不稳定，有时获取一张图像只需要 200ms 左右，有时获取一张图像却需要 3~4 s。大部分情况下获取一张图像需要 1s 左右，而且 MongoDB 性能的波动非常严重，不符合我们最初的测试效果。</p><p>最初猜测是由于 MongoDB 中数据存储不合理，导致数据集查询较慢。但查询 MongoDB 的慢查询日志后，发现所有的查询操作均不是慢查询操作。通过 top 命令查询 MongoDB 部署的主机进行监控，发现在查询过程中，CPU 的占用率一直在 20%左右。正在一筹莫展时，突然发现主机的网卡占用率非常高，猜测是网络的问题。</p><p>利用 wireshark 抓包后，发现在查询过程中有大量 TCP 重传，可能是由于网络阻塞比较严重。经过排查后，发现是实验室的网关性能过差。</p><p>最终，更换了实验室网关，并且将需要批量查询图像的主机通过网线直接与 MongoDB 部署主机相连，最终批量查询的时间稳定在 200ms 左右。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 C++ protobuf 动态消息一次踩坑</title>
      <link href="/2021/12/07/%E8%AE%B0%E5%BD%95-C++-protobuf-%E5%8A%A8%E6%80%81%E6%B6%88%E6%81%AF%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91/"/>
      <url>/2021/12/07/%E8%AE%B0%E5%BD%95-C++-protobuf-%E5%8A%A8%E6%80%81%E6%B6%88%E6%81%AF%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>尽量 C++ 并不直接支持反射的功能，但是 protobuf 自行实现了一套反射的功能，用于动态生成消息。protobuf 提供了两种方式用于生成动态消息，一种是调用一个 message 实例的 <code>New()</code>接口，另外一种则是通过导入 proto 文件，利用工厂类实现生成。这两种方式生成的消息类型都是 <code>google::protobuf::Message*</code>，即 protobuf 消息的基类。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>由于通过反射的方式对 <code>google::protobuf::DynamicMessageFactory</code>生成的消息进行赋值较为麻烦，因此想通过 <code>google::protobuf::down_cast&lt;T&gt;()</code>方法对生成的消息进行向下转换。使用一下代码段进行测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input input;</span><br><span class="line"><span class="comment">// 使用 New 接口生成消息</span></span><br><span class="line"><span class="keyword">auto</span> newedMessage = input.<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装了 DynamicMessageGenerator，生成消息</span></span><br><span class="line">Message * generatedMessage = generator.<span class="built_in">paramToMessage</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;this_is_str&quot;</span>, <span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Generated Content:\n&quot;</span> &lt;&lt;generatedMessage-&gt;<span class="built_in">DebugString</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 generatedMessage 赋值给 newedMessage</span></span><br><span class="line">newedMessage-&gt;<span class="built_in">ParseFromString</span>(generatedMessage-&gt;<span class="built_in">SerializeAsString</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> downNewed = google::protobuf::internal::<span class="built_in">DownCast</span>&lt; Input *&gt;(newedMessage);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;downNewed Content:\n&quot;</span>&lt;&lt; downNewed-&gt;<span class="built_in">DebugString</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> downGenerated = google::protobuf::internal::<span class="built_in">DownCast</span>&lt; Input *&gt;(generatedMessage);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;downGenerated Content:\n&quot;</span>&lt;&lt; downGenerated-&gt;<span class="built_in">DebugString</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>但是这样使用会导致使用动态工厂生成的消息抛出类型检查错误，错误信息为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出信息</span></span><br><span class="line">Generated Content:</span><br><span class="line">strVal: <span class="string">&quot;this_is_str&quot;</span></span><br><span class="line">intVal: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">downNewed Content:</span><br><span class="line">strVal: <span class="string">&quot;this_is_str&quot;</span></span><br><span class="line">intVal: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Assertion failed: (f == <span class="literal">nullptr</span> || <span class="built_in">dynamic_cast</span>&lt;To&gt;(f) != <span class="literal">nullptr</span>), function down_cast, file casts.h, line <span class="number">94.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应 protobuf 代码段</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> To, <span class="keyword">typename</span> From&gt;     <span class="comment">// use like this: down_cast&lt;T*&gt;(foo);</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> To <span class="title">down_cast</span><span class="params">(From* f)</span> </span>&#123;                   <span class="comment">// so we only accept pointers</span></span><br><span class="line">  <span class="comment">// Ensures that To is a sub-type of From *.  This test is here only</span></span><br><span class="line">  <span class="comment">// for compile-time type checking, and has no overhead in an</span></span><br><span class="line">  <span class="comment">// optimized build at run-time, as it will be optimized away</span></span><br><span class="line">  <span class="comment">// completely.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">implicit_cast</span>&lt;From*, To&gt;(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(NDEBUG) &amp;&amp; PROTOBUF_RTTI</span></span><br><span class="line">  <span class="built_in">assert</span>(f == <span class="literal">nullptr</span> || <span class="built_in">dynamic_cast</span>&lt;To&gt;(f) != <span class="literal">nullptr</span>);  <span class="comment">// RTTI: debug mode only!</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;To&gt;(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码中的提醒信息，将 CMake 的构建方式设置为 Release 模式， assert 代码被跳过，测试程序可以正常运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Generated Content:</span><br><span class="line">strVal: <span class="string">&quot;this_is_str&quot;</span></span><br><span class="line">intVal: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">downNewed Content:</span><br><span class="line">strVal: <span class="string">&quot;this_is_str&quot;</span></span><br><span class="line">intVal: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">downGenerated Content:</span><br><span class="line">strVal: <span class="string">&quot;this_is_str&quot;</span></span><br><span class="line">intVal: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里的一行 assert 代码在 Debug 模式时确实会比较麻烦，算是一个小坑吧。</p><h2 id="动态工厂反射简单封装"><a href="#动态工厂反射简单封装" class="headerlink" title="动态工厂反射简单封装"></a>动态工厂反射简单封装</h2><p>由于动态工厂的接口直接用起来非常麻烦，需要使用多个类才能完成反射的赋值，因此将这几个类进行封装，并最终通过一行代码进行动态消息生成。这里主要是通过 C++中的类型检查和动态参数来完成的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> google::protobuf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> google::protobuf::compiler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicGenerator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 构造函数，主要负责从硬盘中读取 proto 文件并导入内存</span></span><br><span class="line">  <span class="comment">/// \param disk_path 读取路径</span></span><br><span class="line">  <span class="comment">/// \param proto_name proto 文件名</span></span><br><span class="line">  <span class="built_in">DynamicGenerator</span>(<span class="type">const</span> std::string &amp;disk_path,<span class="type">const</span> std::string &amp;proto_name) :</span><br><span class="line">  <span class="built_in">m_factory</span>(<span class="keyword">new</span> DynamicMessageFactory), <span class="built_in">source</span>(<span class="keyword">new</span> DiskSourceTree) &#123;</span><br><span class="line">    source-&gt;<span class="built_in">MapPath</span>(<span class="string">&quot;&quot;</span>, disk_path);</span><br><span class="line">    importer.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Importer</span>(&amp;*source, &#123;&#125;));</span><br><span class="line">    <span class="comment">//runtime compile foo.proto</span></span><br><span class="line">    importer-&gt;<span class="built_in">Import</span>(proto_name);</span><br><span class="line">    pool = importer-&gt;<span class="built_in">pool</span>();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 获得反射赋值后的 Message</span></span><br><span class="line">  <span class="comment">/// \tparam Types 模板参数，允许每一个 param 类型不同</span></span><br><span class="line">  <span class="comment">/// \param type Message 类型描述符</span></span><br><span class="line">  <span class="comment">/// \param params Message 参数，需要按照定义顺序输入</span></span><br><span class="line">  <span class="comment">/// \return 反射赋值后的 Message 指针</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Types&gt;</span></span><br><span class="line"><span class="function">  Message *<span class="title">paramToMessage</span><span class="params">(<span class="type">const</span> Descriptor *type, Types ... params)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Message *tempo = m_factory-&gt;<span class="built_in">GetPrototype</span>(type);</span><br><span class="line">    Message *message = tempo-&gt;<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Reflection *reflection = message-&gt;<span class="built_in">GetReflection</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>...(params) &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">addValues</span>(input, reflection, message, params...);</span><br><span class="line"></span><br><span class="line">    field_id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> DescriptorPool *pool;</span><br><span class="line">  std::unique_ptr&lt;DynamicMessageFactory&gt; m_factory;</span><br><span class="line">  std::unique_ptr&lt;DiskSourceTree&gt; source;</span><br><span class="line">  std::unique_ptr&lt;Importer&gt; importer;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> field_id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值实现，利用 Reflection 设置指定 field 的值</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span></span></span><br><span class="line"><span class="function">  <span class="title">addValues</span><span class="params">(<span class="type">const</span> Descriptor *input, <span class="type">const</span> Reflection *reflection, Message *message,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> Type &amp;param)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> field = input-&gt;<span class="built_in">FindFieldByNumber</span>(field_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (field == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Invalid field_id.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_same_v&lt;Type, std::string&gt; || std::is_same_v&lt;Type, <span class="type">const</span> <span class="type">char</span> *&gt;)</span> </span>&#123;</span><br><span class="line">      reflection-&gt;<span class="built_in">SetString</span>(message, field, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;Type, <span class="type">int</span>&gt;) &#123;</span><br><span class="line">      reflection-&gt;<span class="built_in">SetInt32</span>(message, field, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;Type, <span class="type">float</span>&gt;) &#123;</span><br><span class="line">      reflection-&gt;<span class="built_in">SetFloat</span>(message, field, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;Type, <span class="type">double</span>&gt;) &#123;</span><br><span class="line">      reflection-&gt;<span class="built_in">SetDouble</span>(message, field, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Unknown Type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(param).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    field_id++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接口，依次递归调用每一个 params</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type, <span class="keyword">typename</span> ...Types&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">addValues</span><span class="params">(<span class="type">const</span> Descriptor *input, <span class="type">const</span> Reflection *reflection, Message *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> Type &amp;param, <span class="type">const</span> Types &amp;... params)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addValues</span>(input, reflection, message,  param);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addValues</span>(input, reflection, message,params...);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 并发编程实践笔记</title>
      <link href="/2021/08/23/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/23/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="序论"><a href="#序论" class="headerlink" title="序论"></a>序论</h1><h2 id="并发的一些基本概念"><a href="#并发的一些基本概念" class="headerlink" title="并发的一些基本概念"></a>并发的一些基本概念</h2><ul><li><p>并发：在单个系统中可以同时执行多个独立的任务，这些任务可是不是在同一时刻开始的。<strong>并发的关注点为任务分离和任务响应</strong></p></li><li><p>并行：是指系统在同一时刻创建出多个并发的线程，这些任务的开始间隔很小，近似为同一时刻。<strong>并行的关注点再数据批量处理</strong></p></li><li><p>C++中，同一进程的线程之间是共享同一片内存地址的；而进程之间的内存地址之间是隔离开的。因此，进程之间的通信十分复杂，或通信速度较慢；而线程之间的通信简单，且速度很快。</p></li><li><p>并发的缺点：并发的设计和维护的代价非常大，也更容易引起错误。过多的线程也会造成系统的运行效率下降。</p></li><li><p>C++标准库对系统底层工具进行了封装，<strong>这代表其会产生一定的抽象代价</strong>     </p></li></ul><h2 id="并行的常用方式"><a href="#并行的常用方式" class="headerlink" title="并行的常用方式"></a>并行的常用方式</h2><ul><li>任务并行：将一个大任务分为几部分，各自单独运行。数据分批次，算法是整体的。<strong>任务并行常常用来提升任务运行速度</strong></li><li>数据并行：将一个算法分为几部分，形成线程之间的流水线工作。<strong>数据并行常常用来提升数据吞吐量</strong></li></ul><h2 id="并发编程常用思想"><a href="#并发编程常用思想" class="headerlink" title="并发编程常用思想"></a>并发编程常用思想</h2><p>​    下面介绍的是在并发编程中经常会用到的一些模式和思想。</p><h3 id="函数化编程"><a href="#函数化编程" class="headerlink" title="函数化编程"></a>函数化编程</h3><p>​    函数化编程是指函数的结果只依赖于传入函数的参数，而不依赖于外部的状态。通常所说的外部状态有：全局变量，外部域变量、系统参数等，<strong>注意不要忽略系统参数</strong>。函数化编程具有以下的优点：</p><ul><li><strong>可再现性</strong>：函数化编程的结果与输入一一对应，可以避免一些预料之外的错误。</li><li><strong>低条件竞争</strong>：函数化编程不依赖外部参数，因而很难会发生条件竞争。</li><li><strong>高并发</strong>：采用函数化编程，可以在同一时刻并发多个线程，而不会造成阻塞。</li></ul><h3 id="通信顺序处理"><a href="#通信顺序处理" class="headerlink" title="通信顺序处理"></a>通信顺序处理</h3><p>​    通信顺序处理是指线程之间的消息只通过消息队列传递，而不使用共享地址空间。由于 C++线程共享一块地址空间，所以 C++只能够模拟而非真正实现通信顺序处理。</p><p>​    基于通信顺序处理，可以实现多线程下的有限状态机</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>​    指数据结构在多线程环境下，无数据的丢失和损毁，所有的数据需要维持原样且无条件竞争。    <strong>单纯使用锁会导致序列化，即线程只能轮流访问被保护的数据；在数据结构这个节点上并不能实现真正的并发</strong>；线程安全的含义：</p><ul><li>确保无线程能看到修改够数据结构的“不变量”时的状态，即<strong>数据修改对任何线程是原子的</strong></li><li>小心会引起条件竞争的接口，提供完整操作的函数，而非<strong>操作步骤</strong></li><li>注意数据结构的行为是否会产生异常，从而确保“不变量”的状态，即<strong>实现“异常-安全”</strong></li><li>降低死锁概率，限制锁的范围，降低锁的粒度，避免嵌套锁的存在。</li></ul><h1 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h1><h2 id="简单地定义一个模板的初始化"><a href="#简单地定义一个模板的初始化" class="headerlink" title="简单地定义一个模板的初始化"></a>简单地定义一个模板的初始化</h2><p>C++线程是一个模板类，提供的函数对象和数据（除 <code>std::ref()</code>外）都会被复制到新的线程中去，<strong>如果拷贝后主线程的函数或数据发生变化不会造成子线程的变化，这可能会导致一些错误</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">int</span> &amp; num)</span></span>&#123; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">createFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用类的成员函数时要加上 &amp;类型::</span></span><br><span class="line">    <span class="comment">//默认参数需要拷贝到新线程中去，除非显示使用 std::ref</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(&amp;SomeClass::someFunction,<span class="keyword">this</span>,std::ref(num))</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个线程可以被 Join 一次，主线程运行至 join 处</span></span><br><span class="line"><span class="comment">//会等待其他线程运行完毕</span></span><br><span class="line"><span class="keyword">if</span>(thread1.joinable)</span><br><span class="line">thread1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//detach 通常用来分离守护线程,被分离后的线程不能 Join</span></span><br><span class="line"><span class="comment">//守护线程：没有显显式的用户接口，在后台持续运行，可能会贯穿整个应用生命周期</span></span><br><span class="line">thread1.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//yield 用来主动让出时间片，即若有其他线程在等待，则优先让其他线程运行</span></span><br><span class="line">thread1.<span class="built_in">yield</span>();</span><br></pre></td></tr></table></figure><ul><li>std::thread 变量是一个右值类型，不能够拷贝和赋值，只能够使用 std::move 进行移动操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设有两个线程 thread1、thread2 </span></span><br><span class="line"></span><br><span class="line">thread1 = thread2 <span class="comment">//这是错误的</span></span><br><span class="line">thread1.<span class="built_in">swap</span>(thread2);<span class="comment">//thread1和 thread2 相互交换</span></span><br><span class="line"></span><br><span class="line">thread1 = std::<span class="built_in">move</span>(thread2)<span class="comment">// thread2交给 thread1 管理，自身变为空值；thread1原本的会直接被终止，不抛出异常</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//函数可以返回一个 std::thread 类型的对象</span></span><br><span class="line">std::thread <span class="built_in">createThread</span>()&#123;</span><br><span class="line">  <span class="comment">//返回的对象必须被初始化</span></span><br><span class="line">  std::thread <span class="built_in">t</span>();</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有关 thread 的一些操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程的标识符</span></span><br><span class="line">std::this_thread::<span class="built_in">get_id</span>();<span class="comment">//获得当前运行线程的 id</span></span><br><span class="line">thread1.<span class="built_in">get_id</span>();<span class="comment">//获得 thread1 的 id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得允许运行的最大线程数量</span></span><br><span class="line"><span class="comment">//注意，这个数量并不是安全的，因为同一时间在多个线程中调用会返回同一个值</span></span><br><span class="line"><span class="comment">//如果按照这个数量来创建线程，往往会超出系统负载</span></span><br><span class="line"><span class="type">int</span> max_thread_num = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>多线程编程中的“异常-安全”</li></ul><h1 id="线程间的共享数据——mutex"><a href="#线程间的共享数据——mutex" class="headerlink" title="线程间的共享数据——mutex"></a>线程间的共享数据——mutex</h1><p>​    问题来源：当多个线程同时访问一个共享的数据时，它只保留刚刚读取时的信息，若读取后数据被更新，线程并不会保证其所使用的数据为最新版本。当多个线程同时要修改一个数据，就会引发一些问题，这叫作条件竞争。<strong>条件竞争是时间敏感的，通常难以在 debug 模式下进行复现</strong></p><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>​    c++中的基本互斥量有三种：<code>std::mutex</code> 、 <code>std::shared_mutex</code>和<code>std::recursive_mutex</code>。互斥量本身不绑定任何一个数据，它相当于标志出一个临界区，使用同一个互斥量的线程不能够进入同一个临界区，而非禁止访问资源。</p><p>​    <code>std::shared_mutex</code> 是一个<strong>读者-写者锁</strong>。用它来保护一个数组的时候，允许在不同的元素上进行读写操作；即他只会保护被写的那一个元素，而非是保护整个数组。</p><p>​    <code>std::recursive_mutex</code>是一个<strong>嵌套锁</strong>。嵌套锁用于并发访问的类上，用于解决成员函数之间的嵌套使用。如一个类中有 A 和 B 两个函数，两个函数都具有独立功能，但 B 依赖于 A 实现，且 A 和 B 都使用了锁。使用嵌套锁可以解决这个问题，但<strong>不推荐</strong>。推荐——将公共部分提取出来作为 private 函数，再设计两套接口来分别调用这个函数。</p><h3 id="使用互斥量"><a href="#使用互斥量" class="headerlink" title="使用互斥量"></a>使用互斥量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;<span class="comment">//不推荐直接对 mutex 进行操作</span></span><br><span class="line">  <span class="comment">//临界区</span></span><br><span class="line">&#125;<span class="comment">//离开作用域时退出临界区</span></span><br></pre></td></tr></table></figure><h3 id="避免指针指向临界区资源"><a href="#避免指针指向临界区资源" class="headerlink" title="避免指针指向临界区资源"></a>避免指针指向临界区资源</h3><p>使用互斥量时，防止有指针指向临界区内的数据，互斥量向底层传递，不向顶层传递</p><p>互斥量可以锁住一个对象本身以及其所用到的所有资源，但是不能够锁住指向这个对象的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *_ptr=&amp;i;<span class="comment">//通过_ptr 可以指向i</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;<span class="comment">//不推荐直接对 mutex 进行操作</span></span><br><span class="line">  <span class="comment">//临界区</span></span><br><span class="line">  i++;</span><br><span class="line">&#125;<span class="comment">//离开作用域时退出临界区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">  *_ptr--;<span class="comment">//虽然 someFunction 中对 i 上锁，但是通过指针仍然可以访问该数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口间的条件竞争"><a href="#接口间的条件竞争" class="headerlink" title="接口间的条件竞争"></a>接口间的条件竞争</h3><p>​    接口间的竞争来源：考虑一个 STL 标准容器，其中的 empty 在调用时测试的可能是一个不空的数组，但是这个值返回时可能会有其他线程更改了数组，导致数组变为空的。</p><p>​    解决方法有几种：</p><ol><li><p>在多线程程序中，尽量避免定义一些描述数据结构“状态”的函数，如 <code>size()、empty()</code>等。</p></li><li><p>将状态函数使用时对整个数据结构加锁（会导致其他线程阻塞，并发度下降）</p></li><li><p>将状态函数与其他功能函数集成在一起，如使用 try_pop，若失败返回一个空变量。</p></li></ol><h3 id="使用互斥量可能造成死锁问题"><a href="#使用互斥量可能造成死锁问题" class="headerlink" title="使用互斥量可能造成死锁问题"></a>使用互斥量可能造成死锁问题</h3><p>​    死锁来源：不同线程尝试进入临界区的顺序不同，锁住互斥量的顺序不同。</p><ul><li><p>按照一定的优先级顺序来声明信号量，确保锁住互斥量的顺序是一致的。</p><p><strong>优先锁住高频率使用的互斥量，从而来降低线程之间的竞争</strong></p></li><li><p>使用 <code>std::lock()</code>来一次性锁住多个互斥量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx1,mtx2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在声明lock 时，相当于向系统一次性申请多个互斥量</span></span><br><span class="line">std::<span class="built_in">lock</span>(mtx1,mtx2);</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1,std::adopt_lock)</span></span>;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2,std::adopt_lock)</span></span>;</span><br><span class="line"><span class="comment">//如果 lock1 或 lock2 发生异常，那么将会自动释放所有互斥量</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>std::scoped_lock&lt;&gt;</code>来一次性锁住多个互斥量，<strong>C++17标准</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx1,mtx2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在声明lock 时，相当于向系统一次性申请多个互斥量</span></span><br><span class="line"><span class="function">std::scoped_lock <span class="title">guard</span><span class="params">(mtx1,mtx2)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>当线程已经进入临界区后，尽量避免调用其他用户提供的代码</p><p><strong>因为其他用户可能在底层使用了锁，可能会造成死锁</strong></p></li><li><p>在多线程环境下，访问有回路的数据结构，如图、双向列表等要规定访问顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个可能会造成死锁的例子</span></span><br><span class="line"><span class="comment">//假设有一个列表 A-B-C</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////thread1 执行功能从 A 结点删除 B</span></span><br><span class="line"><span class="comment">////thread2 执行功能从 B 结点删除 A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////规定互斥量必须从 A 开始按照顺序获取，才不会造成死锁</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="使用层级互斥锁来避免死锁"><a href="#使用层级互斥锁来避免死锁" class="headerlink" title="使用层级互斥锁来避免死锁"></a>使用层级互斥锁来避免死锁</h2><p>​    层次锁：高层次的锁将无法锁住低层次的锁，从而可以按照层级来设计代码，防止层级之间的死锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hierarchical_mutex <span class="title">high_level_mutex</span><span class="params">(<span class="number">10000</span>)</span></span>; <span class="comment">// 1</span></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">low_level_mutex</span><span class="params">(<span class="number">5000</span>)</span></span>; <span class="comment">// 2</span></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">other_mutex</span><span class="params">(<span class="number">6000</span>)</span></span>; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">do_low_level_stuff</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">low_level_func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(low_level_mutex)</span></span>; <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">do_low_level_stuff</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">high_level_stuff</span><span class="params">(<span class="type">int</span> some_param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">high_level_func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(high_level_mutex)</span></span>; <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">high_level_stuff</span>(<span class="built_in">low_level_func</span>()); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">high_level_func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">other_stuff</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">high_level_func</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">do_other_stuff</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_b</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(other_mutex)</span></span>; <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">other_stuff</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock()"></a><code>std::unique_lock()</code></h2><p>这是一个“延边锁”，通常运用在提前声明互斥量，但不直接加锁的情况下（如一个循环中）。<strong>std::unique_lock 开销较大</strong></p><p><strong>将锁声明在外部作用域中，在内部作用域需要不停地进行加锁和解锁</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx,std::defer_lock)</span></span>;<span class="comment">//这里声明了互斥量，但是并没有真正加锁</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">std::<span class="built_in">lock</span>(lk);<span class="comment">//在这里才真正被加锁</span></span><br><span class="line"><span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////std::unique_lock 也可以被传递//////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">getLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx,std::adopt_lock)</span></span>;</span><br><span class="line">  <span class="comment">////这里锁住一些变量</span></span><br><span class="line">  <span class="keyword">return</span> lk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="锁的粒度与线程阻塞"><a href="#锁的粒度与线程阻塞" class="headerlink" title="锁的粒度与线程阻塞"></a>锁的粒度与线程阻塞</h2><p>​    锁的粒度是一个摆手术语，用来描述通过一个锁保护的数据量的大小。</p><ul><li><p>若锁的粒度过大，可能会造成线程的竞争激烈，许多线程因为无法进入临界区而被阻塞，从而大大降低系统的并发性。</p></li><li><p>但过小粒度的锁，会造成锁本身占用系统的资源过大，而且也会造成程序的设计维护问题。</p></li><li><p><strong>只有当一个程序准备好所有资源后，再去请求一个锁，可以明显地降低线程的阻塞</strong></p></li></ul><h2 id="资源初始化——std-call-once"><a href="#资源初始化——std-call-once" class="headerlink" title="资源初始化——std::call_once"></a>资源初始化——<code>std::call_once</code></h2><p>​    资源初始化是一个看似简单，但其实十分复杂的问题，使用<code>std::call_once</code>可以显著降低多线程中资源初始化的风险。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::once_flag resource_flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initCamera</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createCamera</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//注意，这里的使用和 std::thread 类似，函数不能加（），如果是类内函数需要标注</span></span><br><span class="line">std::<span class="built_in">call_once</span>(resource_flag,initCamera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免使用双重锁"><a href="#避免使用双重锁" class="headerlink" title="避免使用双重锁"></a>避免使用双重锁</h2><h1 id="并发同步操作"><a href="#并发同步操作" class="headerlink" title="并发同步操作"></a>并发同步操作</h1><p>​    期望值解决的是线程之间应当如何解决通信问题。使用共享内存区域进行线程通信的方法虽然简单，但是在无形之中阻塞了程序，造成工作效率的下降；并且，使用<code>std::thread</code>是无法进行函数的右值返回的，因而需要<strong>条件变量</strong>和<strong>期望值</strong>来解决线程之间的简单通信问题。</p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>​    STL 中条件变量主要有两种：<code>std::condition_variable</code>以及<code>std::condition_variable_any</code>。后者可以接受任何锁类型，但是开销较大，一般只采用前一种类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function">std::condition_variable cond</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="comment">/////////一系列功能///////////</span></span><br><span class="line">cond.<span class="built_in">notify_one</span>();</span><br><span class="line">  cond.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////等待的地方要和通知的地方实用相同的锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;<span class="comment">//注意，等待这里建议使用 unique_lock，因为解锁更加方便</span></span><br><span class="line">cond.<span class="built_in">wait</span>(lk,[]()&#123;<span class="comment">// 如果不满足后续条件，那么将会解锁 lk</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;)<span class="comment">//只有在接收了通知并且 lambda 表达式返回 true 时才能进入临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><h2 id="期望值std-future"><a href="#期望值std-future" class="headerlink" title="期望值std::future"></a>期望值<code>std::future</code></h2><p>​    期望值用于<strong>仅仅等待一次的情况</strong>；使用<code>std::condition_varivable</code>时，每次尝试进入临界区都会进行等待，这对于<strong>重复调用的函数</strong>会造成较差的性能。</p><p>​    期望值分为唯一期望值<code>std::future&lt;&gt;</code> 以及<code>std::shared_future&lt;&gt;</code>。后者可以被多个线程使用，前者只能被使用一次。<strong>两者都是只能被移动而不能够被拷贝</strong></p><h3 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a><code>std::async</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">someFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里函数名同样也是不能带括号，其他规则同 thread</span></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; future1 = std::<span class="built_in">async</span>(someFuncion，std::launch::async);<span class="comment">//函数必须在该线程上运行</span></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; future2 = std::<span class="built_in">async</span>(someFuncion，std::launch::defered);<span class="comment">//需要结果时才会运行</span></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; future3 = std::<span class="built_in">async</span>(someFuncion，std::launch::defered|std::launch::async);<span class="comment">//由系统选择</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result = future2.<span class="built_in">get</span>();<span class="comment">//使用 get()函数来调取结果，future2 在这里才会被运行</span></span><br></pre></td></tr></table></figure><h3 id="std-packaged-task-lt-gt"><a href="#std-packaged-task-lt-gt" class="headerlink" title="std::packaged_task&lt;&gt;"></a><code>std::packaged_task&lt;&gt;</code></h3><p>​    <code>std::packaged_task&lt;函数类型（函数参数类型）&gt;</code>这是用来打包一个函数任务的，通常用来在主线程将任务打包并将结果期望绑定，再将运行放入子线程中。    </p><p>​    <strong>当打包的任务出现异常时，该异常会被自动传播到主线程去，需要在主线程解决</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////packaged_task仅仅是将一个可执行任务打包，而并没有执行这个任务</span></span><br><span class="line"><span class="comment">////future 相当于一个指针，指向一个 packaged_task 的返回值。</span></span><br><span class="line"><span class="comment">////当使用 future 的时候，线程会等待返回结果（如果没有运行就会一直等待）</span></span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">tsk</span><span class="params">(test)</span></span>;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = tsk.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">////使用 std::move将 packaged_task 放入一个线程中</span></span><br><span class="line"><span class="function">std::thread <span class="title">th</span><span class="params">(std::move(tsk), <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> val = fut.<span class="built_in">get</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Main thread gets value &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">th.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><h3 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a><code>std::promise</code></h3><p>​    <code>std::promise</code>允许用户自由地在子线程和主线程之间<strong>合适的位置来处理异常</strong>。可以实现子线程不抛出异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设这是一个将要单独在一个线程中运行的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">someFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      promise.<span class="built_in">set_value</span>(<span class="number">1</span>);<span class="comment">// 正常运行，将结果送入期望中</span></span><br><span class="line">  &#125;<span class="built_in">catch</span>()&#123;</span><br><span class="line">    promise.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());<span class="comment">//promise 会直接在子线程中对异常进行处理，而非送回到主线程去</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="共享期望-std-shared-future"><a href="#共享期望-std-shared-future" class="headerlink" title="共享期望 std::shared_future"></a>共享期望 std::shared_future</h2><p>​    共享期望允许多个线程共同获取一个结果，如何初始化一个共享期望：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////////////直接绑定//////////////////</span></span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">tsk</span><span class="params">(test)</span></span>;</span><br><span class="line">std::shared_future&lt;<span class="type">int</span>&gt; fut = tsk.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////绑定已有期望///////////////</span></span><br><span class="line">std::shared_future&lt;<span class="type">int</span>&gt; fut = future.<span class="built_in">share</span>();</span><br></pre></td></tr></table></figure><h2 id="限定等待时间"><a href="#限定等待时间" class="headerlink" title="限定等待时间"></a>限定等待时间</h2><p>​    除了按照条件等待，线程之间还可以设置等待时间，用于防止过长的等待而造成的线程阻塞。</p><h3 id="C-中的时钟"><a href="#C-中的时钟" class="headerlink" title="C++中的时钟"></a>C++中的时钟</h3><p>​    C++的时钟库是<code>&lt;chrono&gt;</code>，该库可以调用系统时间（是一个不稳定的时钟：稳定时钟的节拍均匀且不可调整；系统时钟通常可以调整节拍）。</p><p>​    C++时钟量，两个时间点相减表示一个时间段；时间点加减时间段等于时间点，<strong>会发生隐式的类型转换</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定时钟节拍：</span></span><br><span class="line">std::ratio&lt;<span class="number">1</span>,<span class="number">25</span>&gt;<span class="comment">//代表一秒钟有 25 个节拍</span></span><br><span class="line">std::ratio&lt;<span class="number">5</span>,<span class="number">2</span>&gt;<span class="comment">//代表五秒钟有两个节拍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取系统时钟当前的时间</span></span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>()</span><br><span class="line">  </span><br><span class="line"><span class="comment">//如何表示一段时延，第一个参数是数据类型，第二个参数是单位</span></span><br><span class="line">std::chrono::duration&lt;,&gt;</span><br><span class="line">std::chrono::duration&lt;<span class="type">int</span>,std::ratio&lt;<span class="number">60</span>,<span class="number">1</span>&gt;&gt;</span><br><span class="line">std::chrono::<span class="built_in">duration</span>&lt;<span class="type">long</span> <span class="type">long</span>, std::milli&gt;(<span class="number">100</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//使用 std::chrono::时间量来表示时间段</span></span><br><span class="line">std::chrono::<span class="built_in">nanoseconds</span>(<span class="number">15</span>);<span class="comment">//表示15纳秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间变量之间的相互转化</span></span><br><span class="line">std::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">54802</span>)</span></span>;</span><br><span class="line">std::chrono::seconds s = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(ms);</span><br></pre></td></tr></table></figure><h3 id="std-wait-for"><a href="#std-wait-for" class="headerlink" title="std::wait_for"></a><code>std::wait_for</code></h3><p>​    <code>std::wait_for</code>    用来限制等待线程期望值的时间，但实际等待的时间一般会比指定的时间要长，因为等待期间处理机可能会将线程调出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; future1 = std::<span class="built_in">async</span>(someFuncion，std::launch::async);</span><br><span class="line"><span class="comment">//////////////////////////限定线程只等待期望值35ms/////////////////////////////////</span></span><br><span class="line"><span class="keyword">if</span>(future.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>)) == std::future_status::ready)</span><br><span class="line">  future.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 wait_for 可能会返回的结果：</span></span><br><span class="line">std::future_status::ready<span class="comment">//代表等待的线程已经完成，期望值可以被 get</span></span><br><span class="line">std::future_status::deferred<span class="comment">//代表等待的线程被阻滞（没有在运行）</span></span><br><span class="line">std::future_status::timeout<span class="comment">//代表等待的线程运行超时了</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//////////对 condition_variable 使用 wait_for()/////////////</span></span><br><span class="line">std::condition_variable cond;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">cond.<span class="built_in">wait</span>(lk,std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>));</span><br></pre></td></tr></table></figure><h3 id="std-wait-until"><a href="#std-wait-until" class="headerlink" title="std::wait_until"></a><code>std::wait_until</code></h3><p>​    相比于<code>std::wait_for</code>，<code>std::wait_until</code>等待的时间由绝对时间决定；因此搭配时间点加时间段，可以实现等待准确的指定时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; future1 = std::<span class="built_in">async</span>(someFuncion，std::launch::async);</span><br><span class="line"><span class="comment">//////////////////////////限定线程只等待期望值35ms/////////////////////////////////</span></span><br><span class="line"><span class="keyword">if</span>(future.<span class="built_in">wait_for</span>(std::chrono::system_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>)</span><br><span class="line">                   == std::future_status::ready)</span><br><span class="line">  future.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><h3 id="互斥时间锁"><a href="#互斥时间锁" class="headerlink" title="互斥时间锁"></a>互斥时间锁</h3><p>​    互斥时间锁是一种与时间相关联的互斥信号量，其在尝试进入临界区时，会限定一段时间，当限定的时间结束后，仍未进入临界区，将会放弃进入临界区的行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::timed_mutextmtx;</span><br><span class="line">std::recursive_timed_mutexrtmtx;</span><br><span class="line"><span class="comment">//尝试在 35ms 的时间内获进入临界区，返回返回值为 bool 类型</span></span><br><span class="line">tmtx.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>));</span><br><span class="line">rtmtx.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>));</span><br></pre></td></tr></table></figure><h3 id="std-experimental-额外功能"><a href="#std-experimental-额外功能" class="headerlink" title="std::experimental 额外功能"></a>std::experimental 额外功能</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::experimental::when_all<span class="comment">//用来收集多个线程的期望</span></span><br><span class="line"></span><br><span class="line">std::experimental::when_any<span class="comment">//用来收集多个线程中任意一个的期望</span></span><br></pre></td></tr></table></figure><h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p>​    原子操作是指不可被分割的操作；即对于处理机来说，原子操作只有两个状态：未开始、已完成。</p><p>​    原子操作经常被用于指定线程访问的顺序从而实现无锁编程，相较于互斥信号量，占用的系统资源更少；但是相应地编程难度也大大提升。</p><p>​    <strong>原子操作的用法</strong>：</p><ul><li>作为一个通信的标识符，在线程间传递完成状态等信息。</li><li>作为一个模板，在数据结构修改时作为间接容器来存储要 I/O 的数据。<strong>当获得原子变量的权限后，才能进行修改</strong></li></ul><h2 id="C-中的原子类型"><a href="#C-中的原子类型" class="headerlink" title="C++中的原子类型"></a>C++中的原子类型</h2><p>​    C++的标准原子类型定义在头文件<code>&lt;atomic&gt;</code>中，这些所有的操作都是原子的。<strong>但其中的大部分都是使用互斥锁来模拟的（性能比用户使用互斥锁要好很多），只有 std::atomic_flag 是保证无锁的。</strong></p><p>​    <strong>C++中的标准原子类型不能进行拷贝和赋值，没有相关的操作符，但可以隐式转化成对应的内置类型。</strong></p><p>​    C++中的原子类型可以分为 std::atomic_flag 和 std::atomic&lt;&gt;。前者保证无锁，后者通常是有锁的。</p><table><thead><tr><th align="center">原子类型</th><th align="center">相关特化类</th></tr></thead><tbody><tr><td align="center">atomic_bool</td><td align="center">std::atomic<bool></td></tr><tr><td align="center">atomic_char</td><td align="center">std::atomic<char></td></tr><tr><td align="center">atomic_schar</td><td align="center">std::atomic<signed char></td></tr><tr><td align="center">atomic_uchar</td><td align="center">std::atomic<unsigned char></td></tr><tr><td align="center">atomic_int</td><td align="center">std::atomic<int></td></tr><tr><td align="center">atomic_uint</td><td align="center">std::atomic<unsigned int></td></tr><tr><td align="center">atomic_short</td><td align="center">std::atomic<short></td></tr><tr><td align="center">atomic_ushort</td><td align="center">std::atomic<unsigned short></td></tr><tr><td align="center">atomic_long</td><td align="center">std::atomic<long></td></tr><tr><td align="center">atomic_ulong</td><td align="center">std::atomic<unsigned long></td></tr><tr><td align="center">atomic_llong</td><td align="center">std::atomic<long long></td></tr><tr><td align="center">atomic_ullong</td><td align="center">std::atomic<unsigned long long></td></tr><tr><td align="center">atomic_char16_t</td><td align="center">std::atomic<char16_t></td></tr><tr><td align="center">atomic_char32_t</td><td align="center">std::atomic<char32_t></td></tr><tr><td align="center">atomic_wchar_t</td><td align="center">std::atomic<wchar_t></td></tr></tbody></table><h2 id="std-atomic-flag"><a href="#std-atomic-flag" class="headerlink" title="std::atomic_flag"></a><code>std::atomic_flag</code></h2><p>​    <code>std::atomic_flag</code>代表了一个bool 标志，可以在<strong>“设置”</strong>和<strong>“清除”</strong>两个状态之间转换。其初始化的标志位是“清除”状态。它具有两个个成员函数<code>clear()</code>、<code>test_and_set()</code>，前者是一个存储操作，后者是一个“读-改-写”操作。<code>test_and_set()</code>操作意味着，若读取出的值和要设置的值相同则无操作，若不同则设置为新值。</p><p>​    <code>std::atomic_flag</code>对象不能被拷贝和赋值，因为这两种操作会破坏其原子性。<strong>经常被用于实现自旋锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 std::atomic_flag 实现一个自旋锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpinLockMutex</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::atomic_flag flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SpinLockMutex</span>() : <span class="built_in">flag</span>(ATOMIC_FLAG_INIT)&#123;&#125;<span class="comment">//std::atomic_flag的唯一构造方式</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire));<span class="comment">//尝试对std::atomic_flag上锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    flag.<span class="built_in">clear</span>(std::memory_order_release);<span class="comment">//清除锁</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="std-atomic-lt-gt"><a href="#std-atomic-lt-gt" class="headerlink" title="std::atomic&lt;&gt;"></a><code>std::atomic&lt;&gt;</code></h2><p>​    <code>std::atomic&lt;bool&gt;</code>能够自由选择初始化的值，并且可以使用非原子的 bool 类型进行构造，但其具有抽象代价，不保证无锁。     <code>std::atomic&lt;bool&gt;</code>具有三个基本的成员函数：存储操作<code>store()</code>、加载操作<code>load()</code>、“读-改-写”操作<code>exchange()</code>；还具备两个特殊的“比较/交换”操作：<code>compare_exchange_weak()</code>、<code>compare_exchange_strong()</code>。</p><ul><li><strong>“比较/交换”操作</strong>：是原子类型编程的基石，它比较原子变量的当前值和一个期望值。当两值相等时，存储所提供的值；当两值不等时，期望值会被更新为原子变量中的值。<code>compare_exchange_weak()</code>不保证存储操作成功、<code>compare_exchange_strong()</code>保证存储操作成功。</li></ul><p>​    <code>std::atomic&lt;T*&gt;</code>继承了<code>std::atomic&lt;bool&gt;</code>的全部操作，只是返回类型不同；此外还具有“读-改-写”操作<code>fetch_add()</code>和<code>fetch_sub()</code>，用于在存储地址上进行<strong>原子加法和原子减法</strong>。</p><ul><li>除了基本类型外，用户可以用 class来自定义一个原子变量，前提是<strong>必须有拷贝赋值运算符，即不能有虚函数和基类，并且必须使用编译器默认创建的拷贝赋值操作</strong>。</li></ul><p>​    原子类型的操作函数具有两种调用方式，一种是作为原子变量的成员函数使用，另外一种是直接采用非成员函数的调用方式。非成员函数的调用方式通常是在成员函数名前加上“atomic_”前缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员函数版调用</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; aint;</span><br><span class="line">aint.<span class="built_in">load</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//非成员函数版本调用</span></span><br><span class="line">std::<span class="built_in">atomic_load</span>(&amp;atomic_var,new_value);</span><br><span class="line">std::<span class="built_in">atomic_load_explicit</span>(&amp;atomic_var,new_value,std::memory_order_release);<span class="comment">//需要指定内存序</span></span><br></pre></td></tr></table></figure><h2 id="操作排序"><a href="#操作排序" class="headerlink" title="操作排序"></a>操作排序</h2><p>​    利用原子操作可以实现对不同操作的排序，从而实现线程之间的有序，这是依赖于原子操作的同步发生与先行发生的。</p><ul><li><p>同步发生：同步发生只能在原子类型之间进行，即同一原子变量的原子操作具有同步传递性，改变后的状态会立刻传递给任何需要用到该原子变量的线程中去。</p></li><li><p>先行发生：先行发生发生在非原子操作上，且依赖于同步发生。即同步发生的原子操作可以视为一个时间点，在此时间点基础上，若一个操作先于该原子操作，则具有先行性。（A-原子解锁，原子锁-B，那么 A 会先于 B 发生）。</p><p>C++一共具有三种内存模型和六种内存操作，其对应关系如下：</p><ul><li><p><strong>排序一致性序列</strong>，对应memory_order_seq_cst</p></li><li><p><strong>获取-释放序列</strong>，对应 memory_order_consume,memory_order_acquire,memory_order_release,memory_order_acq_rel</p></li><li><p><strong>松散序列</strong>，对应 memory_order_relaxed</p><p><a href="https://blog.csdn.net/wxj1992/article/details/103656486?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.base&spm=1001.2101.3001.4242">对几种内存操作的详细介绍</a></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个简单的原子操作排序，①永远在②前面</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; count;</span><br><span class="line"><span class="comment">///////////thread1/////////////</span></span><br><span class="line"><span class="type">int</span> signal;<span class="comment">//操作顺序①</span></span><br><span class="line">count.<span class="built_in">store</span>(signal,std::memory::release);</span><br><span class="line"><span class="comment">///////////thread2/////////////</span></span><br><span class="line"><span class="type">int</span> received_signal = count.<span class="built_in">load</span>(std::memory::acquire);</span><br><span class="line">std::cout &lt;&lt; received_singal;<span class="comment">//操作顺序②</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><p>​    栅栏对内存序列进行约束，使其无法对任何数据进行修改。栅栏属于全局操作，执行栅栏操作可以影响到线程中的其他原子操作。<strong>利用栅栏操作可以在不依赖原子变量的情况下实现排序</strong>。</p><p>​    <strong>栅栏既可以和栅栏进行同步，也可以和原子操作进行同步</strong>。</p><p>​    栅栏一共分为六种，分别具有不同的效果：</p><table><thead><tr><th align="left">内存序列类型</th><th>栅栏类型</th><th align="center">栅栏效果</th></tr></thead><tbody><tr><td align="left">memory_order_relaxed</td><td>没有任何效果</td><td align="center">无效果</td></tr><tr><td align="left">memory_order_acquire/memory_order_consume</td><td>acquire fence</td><td align="center">阻止loadstore重排和storestore重排</td></tr><tr><td align="left">memory_order_release</td><td>release fence</td><td align="center">阻止loadload重排和loadstore重排</td></tr><tr><td align="left">memory_order_acq_rel</td><td>full fence</td><td align="center">防止loadload、loadstore、storestore重排</td></tr><tr><td align="left">memory_order_seq_cst</td><td>保证有单独全序的full fence</td><td align="center">防止loadload、loadstore、storestore重排</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用栅栏进行同步的实例</span></span><br><span class="line"><span class="function">std::string <span class="title">computation</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">( std::string )</span></span>;</span><br><span class="line"> </span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; arr[<span class="number">3</span>] = &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;<span class="comment">//use atomic data to communicate</span></span><br><span class="line">std::string data[<span class="number">1000</span>] <span class="comment">//non-atomic data</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Thread A, compute 3 values</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadA</span><span class="params">( <span class="type">int</span> v0, <span class="type">int</span> v1, <span class="type">int</span> v2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//assert( 0 &lt;= v0, v1, v2 &lt; 1000 );</span></span><br><span class="line">data[v0] = <span class="built_in">computation</span>(v0);</span><br><span class="line">data[v1] = <span class="built_in">computation</span>(v1);</span><br><span class="line">data[v2] = <span class="built_in">computation</span>(v2);</span><br><span class="line">std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);</span><br><span class="line">std::<span class="built_in">atomic_store_explicit</span>(&amp;arr[<span class="number">0</span>], v0, std::memory_order_relaxed);</span><br><span class="line">std::<span class="built_in">atomic_store_explicit</span>(&amp;arr[<span class="number">1</span>], v1, std::memory_order_relaxed);</span><br><span class="line">std::<span class="built_in">atomic_store_explicit</span>(&amp;arr[<span class="number">2</span>], v2, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Thread B, prints between 0 and 3 values already computed.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> v0 = std::<span class="built_in">atomic_load_explicit</span>(&amp;arr[<span class="number">0</span>], std::memory_order_relaxed);</span><br><span class="line"><span class="type">int</span> v1 = std::<span class="built_in">atomic_load_explicit</span>(&amp;arr[<span class="number">1</span>], std::memory_order_relaxed);</span><br><span class="line"><span class="type">int</span> v2 = std::<span class="built_in">atomic_load_explicit</span>(&amp;arr[<span class="number">2</span>], std::memory_order_relaxed);</span><br><span class="line">std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);</span><br><span class="line"><span class="comment">// v0, v1, v2 might turn out to be -1, some or all of them.</span></span><br><span class="line"><span class="comment">// otherwise it is safe to read the non-atomic data because of the fences:</span></span><br><span class="line"><span class="keyword">if</span>( v0 != <span class="number">-1</span> ) &#123; <span class="built_in">print</span>( data[v0] ); &#125;</span><br><span class="line"><span class="keyword">if</span>( v1 != <span class="number">-1</span> ) &#123; <span class="built_in">print</span>( data[v1] ); &#125;</span><br><span class="line"><span class="keyword">if</span>( v2 != <span class="number">-1</span> ) &#123; <span class="built_in">print</span>( data[v2] ); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于锁的并发数据结构"><a href="#基于锁的并发数据结构" class="headerlink" title="基于锁的并发数据结构"></a>基于锁的并发数据结构</h1><p>​    被用于共享的数据结构需要进行专门设计，否则可能会造成死锁、线程阻塞等一系列问题。以下是并发数据结构的设计目标：</p><ul><li><p>确保无线程能看到修改够数据结构的“不变量”时的状态，即<strong>数据修改对任何线程是原子的</strong></p></li><li><p>小心会引起条件竞争的接口，提供完整操作的函数，而非<strong>操作步骤</strong></p></li><li><p>注意数据结构的行为是否会产生异常，从而确保“不变量”的状态，即<strong>实现“异常-安全”</strong></p></li><li><p>降低死锁概率，限制锁的范围，降低锁的粒度，避免嵌套锁的存在。</p></li><li></li></ul><h1 id="无锁并发数据结构"><a href="#无锁并发数据结构" class="headerlink" title="无锁并发数据结构"></a>无锁并发数据结构</h1><p>​    无锁并发结构基于原子操作，通常是<strong>无阻塞的</strong>，<strong>自旋的</strong>；即处于等待状态下的线程会处于一个空循环load()状态，而不会进入阻塞状态。通常情况下，无锁结构的性能要优于有锁结构。</p><ul><li><strong>并发最大化</strong>：无锁结构可以允许多个不同功能的线程并发地访问数据结构，但不允许具有相同功能的线程同时访问。</li><li><strong>增加鲁棒性</strong>：有锁结构中，若一个线程在获取锁状态下被终止，共享数据结构将被破坏。</li><li><strong>访问线程无限制</strong>：通过操作顺序的约束，理论上无访问线程的限制。</li><li><strong>无死锁问题</strong>：因为没有使用互斥量，故不会发生死锁。</li><li><strong>不正确使用可能会降低整体性能</strong>：乒乓缓存等效应存在，对设计要求很高。不当设计会降低性能。</li></ul><h2 id="需要注意的一些问题"><a href="#需要注意的一些问题" class="headerlink" title="需要注意的一些问题"></a>需要注意的一些问题</h2><ul><li>尽可能使用<code>std::memory_order_seq_cst</code>，该内存序列是总序的，实现比较简单。只有在<strong>该内存序列上完成了所要设计的相关功能后，才考虑使用其他序列进行性能优化</strong></li><li>无锁并发数据结构不能在任何一个线程中删除某一节点，因此<strong>使用智能指针来进行管理</strong></li><li><strong>“ABA 问题”</strong>：数据结构中的值被交换出后，进行了一些修改导致不合法（尤其是），再被交换回数据结构会造成一系列问题。</li><li><strong>识别忙等待和帮助其他线程</strong>：当线程处于等待过程中，可以让其帮助正在工作的线程完成工作。</li></ul><h1 id="并发代码设计"><a href="#并发代码设计" class="headerlink" title="并发代码设计"></a>并发代码设计</h1><p>​    本章主要讲如何从系统的角度来设计并发代码，即如何分配工作使得代码的效率更高。</p><p>​    “可扩展”代码：随着系统的核数增加，代码的性能增加，理想情况下是线性增长的。</p><h2 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h2><p>​    将一个大任务分为几部分，各自单独运行。数据分批次，算法是整体的。<strong>常常用来提升任务运行速度</strong></p><ul><li>递归划分：每个任务线程都有开辟子线程的能力，会短时间内产生大量的线程，每个线程负责完成一小部分工作。</li></ul><h2 id="任务划分"><a href="#任务划分" class="headerlink" title="任务划分"></a>任务划分</h2><p>​    将任务看成几个部分，每个部分分别用一个线程独立完成工作。</p><p>​    <strong>当通过任务类型进行划分时，不应该让各个线程处于完全隔离的状态，而是采用流水线的方式进行并发</strong></p><h2 id="避免共享内存"><a href="#避免共享内存" class="headerlink" title="避免共享内存"></a>避免共享内存</h2><p>​    在多线程环境下使用共享内存可能会造成许多性能问题，<strong>尽量避免线程访问外部数据</strong>，<strong>尽量使用指针访问外部数据</strong></p><ul><li><p><strong>乒乓缓存</strong>：因为每个线程的内部变量是独立的，若有多个线程同时访问一个共享数据结构，会导致该数据结构不停地在每个处理机缓存中拷贝（每个线程都要保留最新状态），大大降低运行效率。</p><p>解决方法：使用互斥量对多行缓存进行保护，提高锁的粒度</p></li><li><p><strong>伪共享</strong>：因为处理器缓存是以行来存储的，若一个内存行的数据被多个线程所使用（数据粒度太小），会大大降低数据访问的速度（因为一个内存行一次只能被一个线程访问）。</p><p>解决方法：内存对齐、数据紧凑</p></li><li><p><strong>休眠造成缓存转移</strong>：当一个使用缓存的线程休眠后，可能被调至其他处理机运行，从而导致缓存的复制。</p><p>解决方法：已经使用缓存区的线程，防止其休眠或被调度</p></li></ul><h2 id="异常-安全"><a href="#异常-安全" class="headerlink" title="异常-安全"></a>异常-安全</h2><p>​    多线程环境下，要求在发生异常的情况下<strong>不抛出异常，保持共享数据结构的安全性</strong>，显然会带来额外的开销。<strong>每个线程必须在退出前处理好所有异常，保证异常不被抛出和传播（特殊情况，如果一个工作线程（不与主线程外交互），可以在其主线程上统一处理异常）</strong></p><p>​    通常，可能出现异常的情况有：</p><ul><li><strong>分配资源</strong>：创建对象，创建指针，开辟内存区域等。</li><li><strong>内存异常</strong>：内存溢出，指针越界等。</li><li><strong>指针异常</strong>：更改指针绑定时失败。</li><li><strong>函数调用</strong>：函数调用时，底层可能会抛出一些异常</li></ul><h1 id="高级线程管理"><a href="#高级线程管理" class="headerlink" title="高级线程管理"></a>高级线程管理</h1><p>​    仅仅采用创建线程对象的方式是难以在线程的整个生命周期对其进行管理的，如果需要对线程进行更加灵活和精细的管理，常常需要引入“线程池”和“中断线程”的方式来进行管理。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>​    <strong>线程池</strong>集中管理相似度较高的一组任务。这些任务被提交到线程池中的任务将并发执行，提交的任务将会挂在任务队列 上。队列中的每一个任务都会被池中的工作线程所获取，当任务执行完成后，再回到线程池中获取下一个任务。</p><p>​    <strong>线程池中的线程并不是直接运行任务函数，而是运行一个从任务队列中调用任务并加以运行的函数，这是为了方便线程池的初始化。</strong></p><p>​    高级线程池通常具备以下几个模块：</p><ul><li><p><strong>共享任务队列</strong>：用户将需要被运行的任务投入到共享任务队列中等待被调用。</p></li><li><p><strong>期望队列</strong>：期望队列与共享任务队列中的任务绑定，用户从此处获取运行结果。</p></li><li><p><strong>线程池</strong>：集中构造、析构和管理的一组线程，在线程空闲时使用 yield 或者尝试任务窃取。</p></li><li><p><strong>本地任务队列</strong>：线程池中的线程将共享任务队列拷贝到本地，避免因任务量过小导致乒乓缓存。</p></li><li><p><strong>任务窃取</strong>：当线程无任务可以运行时，可以尝试从其他线程的本地任务队列中窃取。</p></li></ul><h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>​    <strong>中断线程</strong>是对<code>std::thread</code>的一层封装，允许用户主动地去中断线程，被中断的线程会完成一些<strong>必要工作</strong>后退出。</p><h1 id="并行算法"><a href="#并行算法" class="headerlink" title="并行算法"></a>并行算法</h1><p>​    C++17版本引入了一些并行算法（保证线程安全），建议直接使用。这些并行算法是对之前标准库的重载，用法与函数名相同，<strong>只是引入了一个额外的策略参数（第一个）</strong>，策略参数一共有三种，被定义在<code>&lt;execution&gt;</code>头文件中：</p><ul><li><code>std::execution::seq</code>：要求函数的所有操作都在当前线程下<strong>单线程</strong>完成，<strong>不并行且不并发</strong>。</li><li><code>std::execution::par</code>：在多个线程中执行，并且线程各自具有自己的顺序任务。即<strong>并行但不并发。</strong></li><li><code>std::execution::par_unseq</code>：算法在多个线程中执行，并且线程可以具有并发的多个任务。即<strong>并行和并发。</strong></li></ul><p>​    执行并发算法时，如果算法运行触发了异常机制，且该异常未在调用算法的线程中被捕获，那么算法会自动调用<code>std::terminate</code>来中断。</p><p>​    标准库中的大多数被执行策略重载的算法都在 <code>&lt;algorithm&gt;</code> 和 <code>&lt;numeric&gt;</code>头文件中，目前已经包括：</p><p>​    all_of，any_of， none_of，for_each，for_each_n，find，find_if，find_end，find_first_of，adjacent_find， count，count_if，mismatch，equal，search，search_n，copy，copy_n，copy_if，move， swap_ranges，transform，replace，replace_if，replace_copy，replace_copy_if，fill， fill_n，generate，generate_n，remove，remove_if，remove_copy，remove_copy_if，unique， unique_copy，reverse，reverse_copy，rotate，rotate_copy，is_partitioned，partition， stable_partition，partition_copy，sort，stable_sort，partial_sort，partial_sort_copy， is_sorted，is_sorted_until，nth_element，merge，inplace_merge，includes，set_union， set_intersection，set_difference，set_symmetric_difference，is_heap，is_heap_until， min_element，max_element，minmax_element，lexicographical_compare，reduce， transform_reduce，exclusive_scan，inclusive_scan，transform_exclusive_scan， transform_inclusive_scan和adjacent_difference</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
